<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CS152 on Notes</title>
    <link>http://zedchance.github.io/notes/CS152/</link>
    <description>Recent content in CS152 on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://zedchance.github.io/notes/CS152/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS152-lecture-20210601</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210601/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210601/</guid>
      <description>Course orientation #  Syllabus #  152-syllabus.pdf  Notes during orientation #   Programming will be required in each module, programming intensive Brush up on probability of simple events, simple conditional events Shallow introduction into groups and fields Class is only 5 weeks and 2 days long, so extremely accelerated, at least 20 hrs/week needed Hybrid class, half videos posted, and half live. Class will start at 1, and go until lecture finishes, then unrecorded open office hour 5 modules, starts on thursdays  Permutation functions and C programming Symmetric encryption Hashing and authentication Asymmetric cryptography and algorithms on large number Crytographic systems   Exams on week 3 and 5 Group quizzes on tuesdays, in breakout rooms on Zoom Last day is comprehensive final Take all assignments seriously, nothing is dropped  Brief introduction to cryptography #   Communication in the presence of adversaries</description>
    </item>
    
    <item>
      <title>CS152-lecture-20210603</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210603/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210603/</guid>
      <description>Data programming #  File: Topics in C programming useful for cryptography  Count the number of even chars #  in C #  #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdint.h&amp;gt; int num_even(void * p, int nbytes) { uint32_t * p32 = (uint32_t *) p; int nitems = nbytes / 4; int acc = 0; for (int i = 0; i &amp;lt; nitems; i++) if (p32[i] % 2 == 0) acc = acc + 1; return acc; } int main() { uint8_t buf[] = {0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00}; printf(&amp;#34;%d\n&amp;#34;, num_even(buf, 8)); return 0; } Depending on the endian, the output is either 0 or 2.</description>
    </item>
    
    <item>
      <title>CS152-lecture-20210604</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210604/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210604/</guid>
      <description>Bitwise manipulations #  File: Slides  Data is a sequence of bytes in memory, whether we receive it from a file or network. We will use unsigned int types to avoid sign extension. These manipulations are powerful in cryptography.
We can also move the bits back and forth using left/right shifts. Bits that shift off the end are gone for good, and 0s are added on the opposite end (in unsigned types).</description>
    </item>
    
    <item>
      <title>CS152-lecture-20210607</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210607/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210607/</guid>
      <description>Distinguishing games #  File: Distinguishing.pdf  Cryptography used to be based on both the pedigree of the creator, and the amount of time it takes until someone can crack it. With modern cryptography, crytographers can prove that their algorithms work. The attack can be skipped if its proven that there are no weaknesses.
When we encrypt a plaintext, we want the ciphertext to look like random bits.
How do we know that the cipher is a good cipher?</description>
    </item>
    
    <item>
      <title>CS152-lecture-20210608</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210608/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210608/</guid>
      <description>How are permutations made? #  To create a permutation we will
 Compose simple steps, each with a different mathematical structure, providing confusion and diffusion.  we can use add, because it is in   \( Z_{2^{32}} \)   xor, because it is in  \( Z_{2} \)   and rotate, because it is non-linear (not represented by a linear equation)    Adding on its own makes a predictable structure, but if we xor after and then rotate we can get a much more confusing structure.</description>
    </item>
    
    <item>
      <title>CS152-lecture-20210610</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210610/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210610/</guid>
      <description>Symmetric encryption #  Files:
 Intro to SSE programming https://www.crypto-textbook.com/download/Understanding-Cryptography-Chapter4.pdf   Recall that encryption is to be used for private communication. Before a message is encrypted its called a plaintext, and after its been encrypted its called a ciphertext. The ciphertext is then decrypted to get the plaintext.
Recall that we defined
perm384bc(k, x) = perm384(k xor x) xor k Remember, perm384 is a public random permutation, so its not enough for secrecy.</description>
    </item>
    
    <item>
      <title>CS152-lecture-20210611</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210611/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210611/</guid>
      <description>Fields #  A field is
 A collection of   \( F \)  objects Two binary operations  \( \times \)  and  \( &amp;#43; \)  closed on  \( F \)  .  \( F \)  contains multiplicative identity 1 where  \( (1 \times y) = y \)  for all  \( y \)  in  \( F \)  .</description>
    </item>
    
    <item>
      <title>CS152-lecture-20210613</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210613/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210613/</guid>
      <description>Block cipher encryption mode examples #  For these examples, consider
    \( E: \{0,1\}^6 \to \{0,1\}^6 \)    \( E(x) = \text{ROTL } (x,2) \)   If needed   \( \text{nonce} = 101 \)    \( \text{IV} = 110111 \)   Counters start at &amp;lt;1&amp;gt; 10* padding    Encrypt the following
0000 1111 0000 1111 ECB #  Since we are using block sizes of 6 bits, we are encrypting</description>
    </item>
    
    <item>
      <title>CS152-lecture-20210615</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210615/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210615/</guid>
      <description>Stream ciphers #  A stream cipher is a function that takes
 a key   \( k \)   a nonce  \( n \)     \[\begin{aligned} \underbrace{\{0,1\}^k}_\text{key} \times \underbrace{\{0,1\}^n}_\text{nonce} \to \underbrace{\{0,1\}^*}_\text{key stream} \end{aligned}\]  Note on notation: a set raised to an asterisk  ( * )  the strings 0 or more length that can be made from the set items.  Our ciphertext is acquired via</description>
    </item>
    
    <item>
      <title>CS152-lecture-20210617</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210617/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210617/</guid>
      <description>OpenSSL example from previous lecture, finished #  cbc_encrypt.c #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;openssl/evp.h&amp;gt; #define BLK_LEN 16 #define BUF_LEN 512  // NOTE!! For clarity&amp;#39;s sake, this example has no error checking. // In real code you need to test for errors and handle them.  int main(int argc, const char* argv[]) { int len, bytes_read; char passphrase[256]; unsigned char key[32]; // Receive SHA-2-256 hash of user pass phrase  unsigned char iv[BLK_LEN]; unsigned char in_buf[BUF_LEN]; unsigned char out_buf[BUF_LEN+BLK_LEN]; EVP_MD_CTX *mdctx; if (argc !</description>
    </item>
    
  </channel>
</rss>
