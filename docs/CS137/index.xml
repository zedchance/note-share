<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CS137 on Notes</title>
    <link>http://zedchance.github.io/notes/CS137/</link>
    <description>Recent content in CS137 on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://zedchance.github.io/notes/CS137/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS137-lecture-20210126</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210126/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210126/</guid>
      <description>csc137syl Spring-2021.docx</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210128</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210128/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210128/</guid>
      <description>Ch1.pdf</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210202</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210202/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210202/</guid>
      <description>CSc 137 Presentation -Topics-1-1.docx
How to convert 5.375 to a floating point representation using IEEE 754:
 Convert the number to a binary representation Start with the whole part: 5 101 Then do the fractional part: .375 Using successive multiplication   \[0.375 * 2 = 0 &amp;#43; .75 \\ 0.75 * 2 = 1 &amp;#43; .5 \\ 0.5 * 5 = 1 &amp;#43; .0 \]  So .375 = .</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210204</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210204/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210204/</guid>
      <description>Continued from last lecture:
How to convert 5.375 to a floating point representation using IEEE 754:
  Convert the number to a binary representation Start with the whole part: 5 = 101. Then do the fractional part: .375 Using successive multiplication
  \[ \begin{aligned} 0.375 * 2 = 0 &amp;#43; .75 \\ 0.75 * 2 = 1 &amp;#43; .5 \\ 0.5 * 5 = 1 &amp;#43; .0 \end{aligned} \]  So .</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210209</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210209/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210209/</guid>
      <description>Ch2.pdf
LUT = lookup table
SOP = sum of products
DeMorgan&amp;rsquo;s theorem #   Two or more variables NAND&amp;rsquo;d together is the same as the two terms inverted and OR&amp;rsquo;d  Two or more variables NOR&amp;rsquo;d together is the same as the two variables inverted and AND&amp;rsquo;d together   Lets show this via tables for these two equations:
  \[\begin{aligned} F1 &amp;amp;= F2 \\ \neg(A \cdot B) &amp;amp;= \neg A &amp;#43; \neg B \end{aligned}\]  Here is a table for  \(F1\)  :</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210211</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210211/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210211/</guid>
      <description>A Karnaugh map is a graphical representation of a logic function. The map for   \(n\)  -input logic function is an array with  \(2^n\)  cells, (one for each possible input combination). To represent a logic function in a k-map, we copy the 1s from the truth table to the corresponding cells. Implicants are squares or rectangles made up of minterms Pairs of adjacent 1 cells in the k-map have minterms that differ in ONLY 1 variable The minterm pairs can be combined into a single product term using the generalization of theorem T10:  T10) = term   Thus, we can use k-maps to simplify the sum of the function.</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210216</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210216/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210216/</guid>
      <description>Ch3.pdf
Propagation delay is the time delta between the input and the output.
Design of a full adder #  Carry Propagate Adder (CPA)
 Full adder is an arithmetic logic unit or circuit to add two single digit numbers with Carry-in It is still combinational circuit with inputs Ax and Bx  Sx is the sum (1 bit) C-in carry in Cx is the carry out   Adder is also called Ripple Carry Adder (RCA) Fundamental circuit for an adder and has longest propagation delay that is proportional to the number of the carry bits  To estimate the propagation delay of an   \( n \)  -bit CPA:</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210218</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210218/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210218/</guid>
      <description>CPA cont. #  Design a 1-bit full adder #     Ax Bx C-in Sx C-out     0 0 0 0 0   0 0 1 1 0   0 1 0 1 0   0 1 1 0 1   1 0 0 1 0   1 0 1 0 1   1 1 0 0 1   1 1 1 1 1    We can reduce the diagonals in Sx: note that Sx is true if only 1 of the inputs is on, or all are on (this is XOR).</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210223</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210223/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210223/</guid>
      <description>CS137-lecture-20210223 #  DeMorgan&amp;rsquo;s Theorem #  Theorem 1:   \(\neg(x \cdot y) = \neg x &amp;#43; \neg y\)  Theorem 2:  \(\neg(x &amp;#43; y) = \neg x \cdot \neg y\)  Steps to convert to all NAND gates:
  Replace each NOT gate with its equivalent NAND gate. Connecting the inputs of a NAND gate makes a NOT gate.
  Place two NOT gates on each of signals going into the final OR.</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210225</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210225/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210225/</guid>
      <description>Multiplexers #  An everyday example of a multiplexer is a TV remote.
 Selecting of data or information is a critical function in a digital system and computers. A multiplexer (mux for short) is a digital switch. Mux is a circuit used to select and route any of the several inputs to an output signal. Mux is a combination circuit, it has the following:     \( 2^n \)  inputs  \( n \)  control inputs, selector signals one set of output   For a mux, the value of the control inputs (selector signal) determines the data input that is selected.</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210302</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210302/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210302/</guid>
      <description>Sequential Circuits #  In combinational circuits, the outputs are only dependent on the inputs. In sequential circuits, the outputs depend on the inputs, and the previous state of the circuit.
Core modules #  S-R Latches
 Latches are basic building blocks of flip-flops (basic memory unit) A 1 bit latch will store 1 bit, 4 bit latch stores 4 bits, and so forth &amp;hellip; Two types of memory elements based on the type of trigger that is suitable to operate Latches, asynchronous Latches operate with an enable signal, which is level sensitive  D flip-flop</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210304</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210304/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210304/</guid>
      <description>Sequential circuits cont. #  Creating the S-R latch cont. #        \( S \)    \( R \)    \( Q_t \)    \( Q_{t&amp;#43;1} \)       0 0  \( Q_t \)    \( Q_t \)     0 1 0 0   1 0 1 1   1 1  Undefined     \( Q_{t &amp;#43; 1} \)  is the &#34;</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210309</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210309/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210309/</guid>
      <description>Exam 1 review #  </description>
    </item>
    
    <item>
      <title>CS137-lecture-20210316</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210316/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210316/</guid>
      <description>Sequential circuits #  Ch5.pdf
 All small and large sequential circuits are made of flip-flops and set of combinational circuits. Contrary to combinational circuits, a sequential circuit design has states and transitions from current state to next state. A sequential circuit design problem is typically modeled as a finite state diagram (FSD). An FSD consists of circles as states and arrows as transitions, which specifies the behavior of the system.</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210318</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210318/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210318/</guid>
      <description>FSM cont. #  Design rules #   If we cannot determine function(s) of combinational circuit(s) in advance:  Model FSM as FSD  May need to design bit-slice 1st   Determine number of flip flops (dependent on the number of states you need) Convert the FSD to truth table Find minimal expressions for next state variable(s) and output(s) Draw the complete circuit with flip-flops   Otherwise  Use bit-serial design with known modules Or, bit-parallel design with known modules    Example #  Lets design a Moore state machine that accepts the string   \( 101 \)  .</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210330</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210330/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210330/</guid>
      <description>Finite state machine design cont. #  Moore machines #   Output depends only upon present state If input changes, output does not change More number of states are required There is more hardware requirement They react slower to inputs (one clock cycle later) Synchronous output and state generation Output is placed on states Easy to design  Step 1: create a FSD
Step 2: determine the minimum number of states/bits required to store states</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210401</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210401/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210401/</guid>
      <description>Finite state machine design cont. #  Moore machine design cont. #  Recall
  \[\begin{aligned} d_0 &amp;amp;= x \\ d_1 &amp;amp;= \overline{x} q_0 &amp;#43; x q_1 \overline{q_0} \\ Z &amp;amp;= q_0 q_1 \end{aligned}\]  Step 5: Circuit diagram
Mealy machine design #   Output depends on present state as well as present input If input changes, output also changes Less number of states are required There is less hardware requirements They react faster to inputs Asynchronous output generation Output is placed on transitions It is difficult to design  We will design a Mealy machine that detects the same overlapping &amp;ldquo;101&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210406</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210406/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210406/</guid>
      <description>Mealy machine design cont. #  Recall:
  \[\begin{aligned} d_0 &amp;amp;= x \\ d_1 &amp;amp;= q_0 \\ Z &amp;amp;= q_1 x \end{aligned}\]  Sequential circuits: large design #  </description>
    </item>
    
    <item>
      <title>CS137-lecture-20210408</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210408/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210408/</guid>
      <description>Large design sequential circuits #  RTN (register transfer notation) is used to describe an operation of a data path
 Formally describes the data path operation  </description>
    </item>
    
    <item>
      <title>CS137-lecture-20210413</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210413/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210413/</guid>
      <description>Sequential circuits, large design cont. #   Data path contains two adder modules and one adder/subtractor module The single mode controls the functions of the adder/subtractor modules    Data path that computes either of these:   \[\begin{aligned} &amp;amp;A &amp;#43; B &amp;#43; C &amp;#43; D \\ &amp;amp;A &amp;#43; B &amp;#43; C - D \end{aligned}\]    Equation that estimates the minimum clock period ( \( \tau \)  ) required to run the data path</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210415</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210415/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210415/</guid>
      <description>Memory technology #  IM = instruction memory, DM = data memory
RAM = random access memory, ROM = read only memory
EEPROM = electrically erasable programmable read only memory
SRAM = static RAM, DRAM = dynamic RAM
Peak memory bandwidth example #     \( 32\text{ bits} \cdot \frac{1\text{ byte} }{8\text{ bits} } = 4 \text{ bytes} \\ \)   \( 1\text{ MB} = 1,000,000 \text{ bytes} \\ \)   \( 1 \text{ Hz} = 1 \text{ cycle/second}\\ \)   \( 1 \text{ MHz} = 1,000,000 \text{ cycles/second} \\\)   \( 100 \text{ MHz} = 100,000,000 \text{ cycles/second} \\\)  So,</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210420</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210420/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210420/</guid>
      <description>Exam 2 review #  Sequential circuit small design #   All small and large sequential circuits are made of flip flops and sets of combination circuits Contrary to CC (combination circuits), a sequential circuit design has states and transitions from a current state to the next state A sequential circuit design problem is typically modeled as a finite state diagram FSD consists of circles as states and arcs (arrows) as transitions, which specifies the behavior of a sequential circuit FSD is systematically converted into circuit called finite state machine Finite state machines designs categorized into Mealy, Moore, or hybrid Mealy is a FSM whose output values are determined by its current e state and input.</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210427</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210427/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210427/</guid>
      <description>Instruction set architectures #   SIMD = single instruction multiple data RISC = reduced instruction set computer CISC = complex instruction set computer ACC = accumulator  Types of instructions #  AES = advanced encryption standard
High level language program to execution #  Instruction cycle #  Data path has four main tasks
 fetch decode execute  may access data memory (another cache)   write  </description>
    </item>
    
    <item>
      <title>CS137-lecture-20210429</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210429/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210429/</guid>
      <description>ISA cont. #  Stack architecture #  Example stack style assembly to compute A = B * (C + D)
PUSH (C) ; stack &amp;lt;- M[C] PUSH (D) ; stack &amp;lt;- M[D] ADD ; stack &amp;lt;- (C) + (D) ; values popped, added, result pushed PUSH (B) ; stack &amp;lt;- M[B] MUL ; stack &amp;lt;- ((C) + (D)) * (B) ; values popped, multiplied, result pushed POP (A) ; M[A] &amp;lt;- (((C) + (D)) * (B)) ; value popped and stored in memory Accumulator architecture #  LD = load</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210506</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210506/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210506/</guid>
      <description>ISA cont. #  RISC â€“ reduced instruction set computer #  Some RISC style assembly to calculate   \( A = B \cdot (C &amp;#43; D) \)  LD R1, (C) ; R1 &amp;lt;- M[C] LD R2, (D) ; R2 &amp;lt;- M[D] ADD R3, R1, R2 ; R3 &amp;lt;- R1 + R2 LD R4, (B) ; R4 &amp;lt;- M[B] MUL R5, R3, R4 ; R5 &amp;lt;- R3 * R4 ST (A), R5 ; M[A] &amp;lt;- R5 Design example: Accumulator ISA #  </description>
    </item>
    
  </channel>
</rss>
