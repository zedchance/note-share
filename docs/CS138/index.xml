<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CS138 on Notes</title>
    <link>http://zedchance.github.io/notes/CS138/</link>
    <description>Recent content in CS138 on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://zedchance.github.io/notes/CS138/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS138-lecture-20210126</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210126/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210126/</guid>
      <description>syllabus_CSC138.pdf</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210128</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210128/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210128/</guid>
      <description>Chapter_1_Intorduction to Computer Networks and the Internet.pdf</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210202</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210202/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210202/</guid>
      <description>NAT = network address translator
The packet transmission delay is the delay that it takes your computer to send the packet to the link. (Your car from the garage to the driveway).
HFC = hybrid fiber coax
Without fiber optic cable we could not span networks across oceans.
Between the source and destination, what if there are N routers?
((N+1) \frac{L}{R})
The entire packet must fully arrive at the router before being transmitted.</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210204</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210204/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210204/</guid>
      <description>FDM = frequency division multiplexer TDM = time division multiplexer</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210209</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210209/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210209/</guid>
      <description>The jump from 11 to 12 is crossing the atlantic ocean.
So the answer is min(Rs, Rc).
Layering can be harmful because each layer is only responsible for its own job, so if the presentation layer doesn&amp;rsquo;t encrypt, no other layers job to do that.
Internet protocol stack is a practical perspective, ISO/OSI reference model is a reference perspective. The missing layers (presentation, session) must be implemented in the application layer if needed.</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210211</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210211/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210211/</guid>
      <description>RE: Wireshark lab 1. This is an intro to the wireshark software.
observe that the en0 has activity. Double click the card with activity to start packet analyzing.
 Hl), Hn = IP address, Ht = port number
Each time the packet goes thru a router, it must go up to the network layer and back down.
At the destination, the layers are removed on the way up to the application layer.</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210216</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210216/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210216/</guid>
      <description>Broadcast can only be based on UDP, because you don&amp;rsquo;t know where to make a connection.
11 tcp connections are needed in total
RTT = round trip time</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210218</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210218/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210218/</guid>
      <description>https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/http-delay-estimation/index.html
In piplining, the object requests are &amp;ldquo;back to back&amp;rdquo;
The proxy server can have a web cache copy so it doesn&amp;rsquo;t have to request the origin again.
Cache
 hit, the request was cached miss, the request was not cached  </description>
    </item>
    
    <item>
      <title>CS138-lecture-20210223</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210223/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210223/</guid>
      <description>Average rate to browsers:
  \[\begin{aligned} 100\text{ K } \cdot 15/\text{ sec } = 1.5 \text{ MBps } \end{aligned}\]  So our LAN utilization is:
 \[\begin{aligned} \frac{1.5 \text{ Mbps }}{10 \text{ Mbps}} = 15\% \end{aligned}\]  And the access link utilization is:
 \[\begin{aligned} \frac{1.5 \text{ Mbps }}{1.54 \text{ Mbps}} = 99\% \end{aligned}\]  Access link utilization:
 \[\begin{aligned} 99\% \cdot 0.6 = 58\% \end{aligned}\]  Total delay:</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210225</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210225/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210225/</guid>
      <description>Domain name system #  DNS is a application layer service, it is run at the network edge.
 ttl = &amp;ldquo;time to leave&amp;rdquo;, expiration time NS = name server, this is the point of contact CNAME = canonical name, this is where you can specify a smaller name for a long name MX = mailserver  Query and response are the same format.
dig asks for the IP address of a site.</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210302</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210302/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210302/</guid>
      <description>DNS cont. #  For a backup authoritative DNS server (secondary), resource records inserted into .com TLD DNS server, by DNS registrar:
(networkutopia.com, dns2.networkutopia.com, NS, TTL) (dns2.networkutopia.com, 212.212.212.2, A, TTL) In your company&amp;rsquo;s authoritative DNS server, you should have the following resource records for web server, email server (etc):
(www.networkutopia.com, somethingelse.networkutopia.com, CNAME, TTL) (somethingelse.networkutopia.com, 212.212.212.56, A, TTL) (networkutopia.com, mailserver.networkutopia.com, MX, TTL) (mailserver.networkutopia.com, 212.212.212.89, A, TTL) DNS Poisoning #  Lets say its the first time that we are visiting a site, we will first ask the local DNS &amp;hellip;</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210304</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210304/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210304/</guid>
      <description>Socket programming #  UDP Client in Python #  SOCK_DGRAM means it will use UDP. The server&amp;rsquo;s socket is always open.
UDPClient.py:
from socket import * serverName = &amp;#39;hostname&amp;#39; serverPort = 12000 clientSocket = socket(AF_NET, SOCK_DGRAM) message = raw_input(&amp;#39;Input lowercase sentence:&amp;#39;) clientSocket.sendto(message, (serverName, serverPort)) modifiedMessage, serverAddress = clientSocket.recvfrom(2048) print modifiedMessage clientSocket.close() UDPClient.py
from socket import * serverPort = 12000 serverSocket = socket(AF_INET, SOCK_DGRAM) serverSocket.bind((&amp;#39;&amp;#39;, serverPort)) print &amp;#39;The server is ready to receieve&amp;#39; while 1: message, clientAddress = serverSocket.</description>
    </item>
    
  </channel>
</rss>
