<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CS138 on Notes</title>
    <link>http://zedchance.github.io/notes/CS138/</link>
    <description>Recent content in CS138 on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://zedchance.github.io/notes/CS138/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS138-lecture-20210126</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210126/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210126/</guid>
      <description>syllabus_CSC138.pdf</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210128</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210128/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210128/</guid>
      <description>Chapter_1_Intorduction to Computer Networks and the Internet.pdf</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210202</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210202/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210202/</guid>
      <description>NAT = network address translator
The packet transmission delay is the delay that it takes your computer to send the packet to the link. (Your car from the garage to the driveway).
HFC = hybrid fiber coax
Without fiber optic cable we could not span networks across oceans.
Between the source and destination, what if there are N routers?
  \( (N&amp;#43;1) \frac{L}{R} \)  The entire packet must fully arrive at the router before being transmitted.</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210204</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210204/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210204/</guid>
      <description>FDM = frequency division multiplexer TDM = time division multiplexer</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210209</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210209/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210209/</guid>
      <description>The jump from 11 to 12 is crossing the atlantic ocean.
So the answer is min(Rs, Rc).
Layering can be harmful because each layer is only responsible for its own job, so if the presentation layer doesn&amp;rsquo;t encrypt, no other layers job to do that.
Internet protocol stack is a practical perspective, ISO/OSI reference model is a reference perspective. The missing layers (presentation, session) must be implemented in the application layer if needed.</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210211</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210211/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210211/</guid>
      <description>RE: Wireshark lab 1. This is an intro to the wireshark software.
observe that the en0 has activity. Double click the card with activity to start packet analyzing.
 Hl = MAC address, Hn = IP address, Ht = port number
Each time the packet goes thru a router, it must go up to the network layer and back down.
At the destination, the layers are removed on the way up to the application layer.</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210216</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210216/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210216/</guid>
      <description>Broadcast can only be based on UDP, because you don&amp;rsquo;t know where to make a connection.
11 tcp connections are needed in total
RTT = round trip time</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210218</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210218/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210218/</guid>
      <description>https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/http-delay-estimation/index.html
In piplining, the object requests are &amp;ldquo;back to back&amp;rdquo;
The proxy server can have a web cache copy so it doesn&amp;rsquo;t have to request the origin again.
Cache
 hit, the request was cached miss, the request was not cached  </description>
    </item>
    
    <item>
      <title>CS138-lecture-20210223</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210223/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210223/</guid>
      <description>Average rate to browsers:
  \[\begin{aligned} 100\text{ K } \cdot 15/\text{ sec } = 1.5 \text{ MBps } \end{aligned}\]  So our LAN utilization is:
 \[\begin{aligned} \frac{1.5 \text{ Mbps }}{10 \text{ Mbps}} = 15\% \end{aligned}\]  And the access link utilization is:
 \[\begin{aligned} \frac{1.5 \text{ Mbps }}{1.54 \text{ Mbps}} = 99\% \end{aligned}\]  Access link utilization:
 \[\begin{aligned} 99\% \cdot 0.6 = 58\% \end{aligned}\]  Total delay:</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210225</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210225/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210225/</guid>
      <description>Domain name system #  DNS is a application layer service, it is run at the network edge.
 ttl = &amp;ldquo;time to leave&amp;rdquo;, expiration time NS = name server, this is the point of contact CNAME = canonical name, this is where you can specify a smaller name for a long name MX = mailserver  Query and response are the same format.
dig asks for the IP address of a site.</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210302</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210302/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210302/</guid>
      <description>DNS cont. #  For a backup authoritative DNS server (secondary), resource records inserted into .com TLD DNS server, by DNS registrar:
(networkutopia.com, dns2.networkutopia.com, NS, TTL) (dns2.networkutopia.com, 212.212.212.2, A, TTL) In your company&amp;rsquo;s authoritative DNS server, you should have the following resource records for web server, email server (etc):
(www.networkutopia.com, somethingelse.networkutopia.com, CNAME, TTL) (somethingelse.networkutopia.com, 212.212.212.56, A, TTL) (networkutopia.com, mailserver.networkutopia.com, MX, TTL) (mailserver.networkutopia.com, 212.212.212.89, A, TTL) DNS Poisoning #  Lets say its the first time that we are visiting a site, we will first ask the local DNS &amp;hellip;</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210304</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210304/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210304/</guid>
      <description>Socket programming #  UDP Client in Python #  SOCK_DGRAM means it will use UDP. The server&amp;rsquo;s socket is always open.
UDPClient.py:
from socket import * serverName = &amp;#39;hostname&amp;#39; serverPort = 12000 clientSocket = socket(AF_NET, SOCK_DGRAM) message = raw_input(&amp;#39;Input lowercase sentence:&amp;#39;) clientSocket.sendto(message, (serverName, serverPort)) modifiedMessage, serverAddress = clientSocket.recvfrom(2048) print modifiedMessage clientSocket.close() UDPServer.py
from socket import * serverPort = 12000 serverSocket = socket(AF_INET, SOCK_DGRAM) serverSocket.bind((&amp;#39;&amp;#39;, serverPort)) print &amp;#39;The server is ready to receieve&amp;#39; while 1: message, clientAddress = serverSocket.</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210309</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210309/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210309/</guid>
      <description>Transport Layer #  Transport services #   Application Layer  App &amp;lt;-&amp;gt; app such as Outlook (email)   Transport layer  Process &amp;lt;-&amp;gt; process Data -&amp;gt; segments/datagrams Segment contains transport header + data portions from email   Network layer  Machine &amp;lt;-&amp;gt; machine Network header + segment    Rectangle = app, Diamond = socket, Circle = process
Multiplexing/demultiplexing #  Connectionless transport: UDP #  </description>
    </item>
    
    <item>
      <title>CS138-lecture-20210311</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210311/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210311/</guid>
      <description>UDP cont. #  Principles of reliable data transfer #  Expected features
 No bit errors No loss of data   Problems
 Bit error Data loss   Solutions
 Error detection (checksum) Data recovery    So how do we do recovery? We learn from human to human conversation, &amp;ldquo;pardon?&amp;quot; to recover data loss in the conversation.
Feedback: ACK for positive, NAK for negative.
So the receiver will send an ACK if the packet was received without loss, otherwise it&amp;rsquo;ll send NAK.</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210316</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210316/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210316/</guid>
      <description>Review for exam #  Example question set for Ch 1-2 #    What are the layers in TCP/IP protocol stack?
Application, transport, network, link, physical
  What are layers in OSI reference model?
Extra 2 layers are presentation and
  What is the major difference between packet switching and circuit switching?
Circuit reserves some resources, packet switchings allows sharing
  What is the difference between routing and forwarding?</description>
    </item>
    
    <item>
      <title>CS138-lecture-20210330</title>
      <link>http://zedchance.github.io/notes/CS138/CS138-lecture-20210330/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS138/CS138-lecture-20210330/</guid>
      <description>Piplined protocols #  Go-back-n #  unacked = unacknowledged = no ACK response, not confirmed for success yet.
The number of bits needed for a   \( k \)  -bit sequence numbers is  \( 2^k - 1 \)  . The window size is  \( N = 2^k \)  .
The packet number that can be used for cumulative ack should be the largest number before any gap.</description>
    </item>
    
  </channel>
</rss>
