<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>quicksort on Notes</title>
    <link>http://zedchance.github.io/notes/tags/quicksort/</link>
    <description>Recent content in quicksort on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://zedchance.github.io/notes/tags/quicksort/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS130-lecture-20200921</title>
      <link>http://zedchance.github.io/notes/CS130/CS130-lecture-20200921/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS130/CS130-lecture-20200921/</guid>
      <description>Annoucements #  First assignment open
Mergesort cont. #  Solution to last exercise:
 The first sort method:
 space complexity is O(n) running time is  The second method
 space complexity is O(1) running time is O(nlog(n))  An example of a stable sorting algorithm:
Unsorted: [3(1), 2, 1, 5, 3(2)] (where the (1) indicates that it is the first 3 in the array)
Sorted: [1, 2, 3(1), 3(2), 5] this is stable [1, 2, 3(2), 3(1), 5] this is unstable</description>
    </item>
    
    <item>
      <title>CS130-lecture-20200923</title>
      <link>http://zedchance.github.io/notes/CS130/CS130-lecture-20200923/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS130/CS130-lecture-20200923/</guid>
      <description>Annoucements #  Assignment 1 has unlimited attempts, the last attempt counts.
Substrings #  Quicksort cont. #  Space complexity is O(1). Running time is O(n).
Exercise posted:
Space complexity best case is O(log(n)), and worst case is O(n). Running time best case is O(log(n)), and worst case is O(n).</description>
    </item>
    
    <item>
      <title>CS130-lecture-20200928</title>
      <link>http://zedchance.github.io/notes/CS130/CS130-lecture-20200928/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS130/CS130-lecture-20200928/</guid>
      <description>Dev environment #  JDK 11 JUnit 5 Module with all docs for setup
Filenames: assignment1_ZedChance.zip
Quicksort exercise solutions #  Quicksort cont. #  Runningtime is O(n)
Priority queues #  a is complete b is complete c is incomplete d is not a binary tree e is incomplete f is complete
a is a height of 0 b-d is a height of 1 e-f is a height of 2</description>
    </item>
    
    <item>
      <title>CS130-sorting-algorithms</title>
      <link>http://zedchance.github.io/notes/CS130/CS130-sorting-algorithms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS130/CS130-sorting-algorithms/</guid>
      <description>Merge #  Merge.java
/** * Mergesort algorithm implemented from Algorithms (Sedgewick, Wayne) * Section 2.2, pg. 270 */ public class Merge { private static Comparable[] aux; public static void sort(Comparable[] a) { aux = new Comparable[a.length]; sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { // sort a[lo..hi]  if (hi &amp;lt;= lo) return; // base case  int mid) / 2; // find mid point  sort(a, lo, mid); // sort left half (recursive call)  sort(a, mid + 1, hi); // sort right half (recursive call)  merge(a, lo, mid, hi); // merge 2 sorted arrays  } private static void merge(Comparable[] a, int lo, int mid, int hi) { // merge a[lo.</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210929</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210929/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210929/</guid>
      <description>Quicksort #  The way that the array is divided matters.
Partitioning the array using Hoare&amp;rsquo;s partition #  i will move toward the right until it reaches a element that is bigger or equal to the pivot point. j will move to the right until it finds a element that is less thatn or equal to the pivot point. i and j will swap as long as the pointers haven&amp;rsquo;t crossed paths.</description>
    </item>
    
    <item>
      <title>CS140-lecture-20211014</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20211014/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20211014/</guid>
      <description>Recurrences cont #  Recursion tree method #  Another method to solve recurrences is to draw a recursion tree, where each node gets a cost. The cost of each node is the additional work done on each recursive call (not recursive call itself).
The leaf nodes are the base cases. The idea is to identify a pattern, and use a known series to evaluate that pattern.
Then, after identifying the sum of each level of the tree, you then sum all the level&amp;rsquo;s themselves (except the base level, the leaves).</description>
    </item>
    
  </channel>
</rss>
