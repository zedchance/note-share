<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>reductions on Notes</title>
    <link>http://zedchance.github.io/notes/tags/reductions/</link>
    <description>Recent content in reductions on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://zedchance.github.io/notes/tags/reductions/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS135-lecture-20210428</title>
      <link>http://zedchance.github.io/notes/CS135/CS135-lecture-20210428/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS135/CS135-lecture-20210428/</guid>
      <description>Acceptance algorithm #  Decision problems #  A decision problem is a problem that has a binary answer, true or false (or accept and reject). A decision problem may be something like: &amp;ldquo;given   \( x \)  , is  \( x \)  prime?&amp;rdquo; We can use decision problems to prove the limitations for Turing machines, because there isn&amp;rsquo;t a pumping lemma for Turing machines.
If we can show that a decision problem can&amp;rsquo;t be solved, then we can show that computers can&amp;rsquo;t solve the same problem.</description>
    </item>
    
    <item>
      <title>CS135-lecture-20210511</title>
      <link>http://zedchance.github.io/notes/CS135/CS135-lecture-20210511/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS135/CS135-lecture-20210511/</guid>
      <description>More reduction examples #  Recap on reductions: A reduction is simply a hypothetical algorithm.
ASolver(a) ... BSolver(...) ... ASolver relies on the existence of BSolver. So ASolver reduces to BSolver. So if BSolver exists, then ASolver exists.
Acceptance problem #  If we have an algorithm accept(m,x), we are wondering if we run the algorithm m on input x, it will either output &amp;ldquo;accept&amp;rdquo; or &amp;ldquo;reject&amp;rdquo;. The claim is there is no algorithm that can produce this on all inputs (m,x).</description>
    </item>
    
    <item>
      <title>CS152-lecture-20210621</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210621/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210621/</guid>
      <description>Cryptographic hash functions #  Hashing takes a very large domain and maps it to a smaller codomain. For this to scale nicely,
 the hash function must be fast the outputs must be fairly random in distribution  A hash function can be defined as   \( H : \{0,1\}^* \to \{0,1\}^b \)  , where  \( b \)  is the output block length.
Recall: a set raised to an asterisk means the set of all strings made from that set.</description>
    </item>
    
  </channel>
</rss>
