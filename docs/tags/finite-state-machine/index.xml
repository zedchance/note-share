<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>finite state machine on Notes</title>
    <link>http://zedchance.github.io/notes/tags/finite-state-machine/</link>
    <description>Recent content in finite state machine on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://zedchance.github.io/notes/tags/finite-state-machine/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS137-lecture-20210316</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210316/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210316/</guid>
      <description>Sequential circuits #  Ch5.pdf
 All small and large sequential circuits are made of flip-flops and set of combinational circuits. Contrary to combinational circuits, a sequential circuit design has states and transitions from current state to next state. A sequential circuit design problem is typically modeled as a finite state diagram (FSD). An FSD consists of circles as states and arrows as transitions, which specifies the behavior of the system.</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210318</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210318/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210318/</guid>
      <description>FSM cont. #  Design rules #   If we cannot determine function(s) of combinational circuit(s) in advance:  Model FSM as FSD  May need to design bit-slice 1st   Determine number of flip flops (dependent on the number of states you need) Convert the FSD to truth table Find minimal expressions for next state variable(s) and output(s) Draw the complete circuit with flip-flops   Otherwise  Use bit-serial design with known modules Or, bit-parallel design with known modules    Example #  Lets design a Moore state machine that accepts the string   \( 101 \)  .</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210330</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210330/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210330/</guid>
      <description>Finite state machine design cont. #  Moore machines #   Output depends only upon present state If input changes, output does not change More number of states are required There is more hardware requirement They react slower to inputs (one clock cycle later) Synchronous output and state generation Output is placed on states Easy to design  Step 1: create a FSD
Step 2: determine the minimum number of states/bits required to store states</description>
    </item>
    
    <item>
      <title>CS137-lecture-20210401</title>
      <link>http://zedchance.github.io/notes/CS137/CS137-lecture-20210401/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS137/CS137-lecture-20210401/</guid>
      <description>Finite state machine design cont. #  Moore machine design cont. #  Recall
  \[\begin{aligned} d_0 &amp;amp;= x \\ d_1 &amp;amp;= \overline{x} q_0 &amp;#43; x q_1 \overline{q_0} \\ Z &amp;amp;= q_0 q_1 \end{aligned}\]  Step 5: Circuit diagram
Mealy machine design #   Output depends on present state as well as present input If input changes, output also changes Less number of states are required There is less hardware requirements They react faster to inputs Asynchronous output generation Output is placed on transitions It is difficult to design  We will design a Mealy machine that detects the same overlapping &amp;ldquo;101&amp;rdquo;.</description>
    </item>
    
  </channel>
</rss>
