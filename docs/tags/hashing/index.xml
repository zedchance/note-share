<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hashing on Notes</title>
    <link>http://zedchance.github.io/notes/tags/hashing/</link>
    <description>Recent content in hashing on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://zedchance.github.io/notes/tags/hashing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS130-lecture-20201109</title>
      <link>http://zedchance.github.io/notes/CS130/CS130-lecture-20201109/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS130/CS130-lecture-20201109/</guid>
      <description>Hash codes should use all of the fields.
Any perms of strings with the same letters will have the same hashcode, therefore this is a bad hash function.
The worst case runtime for put is O(n). The best case runtime for put is O(1). Space complexity for put is O(1).
Best case runtime for get is O(1) and worst case is O(n). Space complexity for get is O(1).
The load factor is the number of key value pairs (N) divided by the table size (M), so (\frac{10}{5}).</description>
    </item>
    
    <item>
      <title>CS130-lecture-20201116</title>
      <link>http://zedchance.github.io/notes/CS130/CS130-lecture-20201116/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS130/CS130-lecture-20201116/</guid>
      <description>C goes to the next open value because they collide
resize is called if the table is &amp;gt;= being half full.
The first 8 insertions before the resize:
Put the existing keys (they rehash), then continue putting the rest of the list
A is true B is false C is true (another case of A basically) D is false (another case of B)
For get: best case runtime is O(1), worst case is O(n).</description>
    </item>
    
    <item>
      <title>CS152-lecture-20210617</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210617/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210617/</guid>
      <description>OpenSSL example from previous lecture, finished #  cbc_encrypt.c #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;openssl/evp.h&amp;gt; #define BLK_LEN 16 #define BUF_LEN 512  // NOTE!! For clarity&amp;#39;s sake, this example has no error checking. // In real code you need to test for errors and handle them.  int main(int argc, const char* argv[]) { int len, bytes_read; char passphrase[256]; unsigned char key[32]; // Receive SHA-2-256 hash of user pass phrase  unsigned char iv[BLK_LEN]; unsigned char in_buf[BUF_LEN]; unsigned char out_buf[BUF_LEN+BLK_LEN]; EVP_MD_CTX *mdctx; if (argc !</description>
    </item>
    
    <item>
      <title>CS152-lecture-20210621</title>
      <link>http://zedchance.github.io/notes/CS152/CS152-lecture-20210621/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS152/CS152-lecture-20210621/</guid>
      <description>Cryptographic hash functions #  Hashing takes a very large domain and maps it to a smaller codomain. For this to scale nicely,
 the hash function must be fast the outputs must be fairly random in distribution  A hash function can be defined as   \( H : \{0,1\}^* \to \{0,1\}^b \)  , where  \( b \)  is the output block length.
Recall: a set raised to an asterisk means the set of all strings made from that set.</description>
    </item>
    
  </channel>
</rss>
