<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>context-free grammar on Notes</title>
    <link>http://zedchance.github.io/notes/tags/context-free-grammar/</link>
    <description>Recent content in context-free grammar on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://zedchance.github.io/notes/tags/context-free-grammar/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS135-lecture-20210310</title>
      <link>http://zedchance.github.io/notes/CS135/CS135-lecture-20210310/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS135/CS135-lecture-20210310/</guid>
      <description>Context-free grammars #  Recall, for regular languages: regular expressions are generators, and finite automata are recognizers. Context-free grammars are the recognizers of context free languages.
Any string we can make in this process is in the language. Any string we can&amp;rsquo;t make in this process is not in the language.
So   \( \{a^n b^n: \text{n is integer}\} \)  is context free. Remember, we couldn&amp;rsquo;t describe this language using regular expressions because finite automata don&amp;rsquo;t have memory.</description>
    </item>
    
    <item>
      <title>CS135-lecture-20210315</title>
      <link>http://zedchance.github.io/notes/CS135/CS135-lecture-20210315/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS135/CS135-lecture-20210315/</guid>
      <description>Parse trees and Ambiguity #  Parse trees are graphical representations of what each non-terminal produces during a derivation.
An example of a parse tree:
  \( S \to AB \\ A \to aaA \mid \lambda \\ B \to bbB \mid b\)  This grammar produces all strings that have an even number of  \( a \)  &amp;rsquo;s and an odd number of  \( b \)  &amp;rsquo;s.</description>
    </item>
    
    <item>
      <title>CS135-lecture-20210329</title>
      <link>http://zedchance.github.io/notes/CS135/CS135-lecture-20210329/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS135/CS135-lecture-20210329/</guid>
      <description>CFG to PDA algorithm #  Starting from a CFG and going to a PDA is a lot easier than going the other way.
Lets start out with this grammar:
  \( S \to AB \\ A \to aA \mid \lambda \\ B \to bB \mid \lambda\)  We can start our PDA by drawing 3 states, one start and one accept.
The first transition triple is  \( \lambda, \empty, S \empty \)  , and the second transition is  \( \lambda, \empty, \empty \)  .</description>
    </item>
    
  </channel>
</rss>
