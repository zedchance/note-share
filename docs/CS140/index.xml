<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CS140 on Notes</title>
    <link>http://zedchance.github.io/notes/CS140/</link>
    <description>Recent content in CS140 on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://zedchance.github.io/notes/CS140/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS140-lecture-20210830</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210830/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210830/</guid>
      <description>Course orientation #  Syllabus #  File: 140-syllabus.pdf  Notes during orientation #   Regular quizzes 2 exams Modules has prerecorded lectures Homework assignments not graded Can watch videos during Zoom meeting, or prior Generally 1 quiz per lecture (calendar at end of syllabus), given at the first class after the last day of the lecture Turn in work as single PDF file  Methods of proof #  File: 140-methods_of_proof.</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210901</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210901/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210901/</guid>
      <description>A note on learning in this class #  On different levels of learning
We will strive for about 60% of problems being level 3.
When working on a problem, there can be 3 outcomes
 could solve it could not solve it solved, but incorrect  If solved incorrectly, tracing back to the exact part that went wrong can be really beneficial.
Methods of proof cont. #  An easy starting example #  Suppose that   \( x &amp;gt; 3 \)  , is  \( x^2-2y &amp;gt; 5 \)  ?</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210907</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210907/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210907/</guid>
      <description>Asymptotic notation cont #  Big Omega #  Omega is lower bound (where Big O is upper bound).
Examples #     \[\begin{aligned} 5n^2 = \Omega(n) \end{aligned}\]   \( \exists c,n_0 \)  such that  \( 0 \leq c_n \leq 5 n^2 \)  So,  \[\begin{aligned} c \leq 5n \end{aligned}\]  so  \( c = 1 \)  and  \( n_0 = 1 \)  .</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210913</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210913/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210913/</guid>
      <description>Backtracking #  Recursive programming can be divided into two categories. One category creates the solution, and the other searches for the solution.
When searching, we want to consider backtracking.
We can search these decision trees for our solution in the solution space. When looking for a solution, if we ever reach a subtree that doesn&amp;rsquo;t meet our criteria, we can backtrack.
Strategies #  Examples #  Pretend that our maze is represented with 0 and 1, a 2D array where 0 is a wall and 1 is not, something like this:</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210915</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210915/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210915/</guid>
      <description>Recursion #  Recursive tracing #  m(648) m(72) m(9) return 9 My trace
m(348) a = m(34) a = m(3) return 33 a = 33 b = m(4) return 44 b = 44 return 3344 a = 3344 b = m(8) return 88 b = 88 return 334488 pow example #  My solution
pow(b, e): if e == 0: return 1 return b * pow(b, e - 1) Trace</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210927</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210927/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210927/</guid>
      <description>Divide and conquer #    \[\begin{aligned} T(n) &amp;amp;= 2T \left( \frac{n}{2} \right) &amp;#43; \Theta (n) \\ &amp;amp;= \Theta(n\log n) &amp;amp;\text{divide and conquer}\\ T(n) &amp;amp;= T(n-1) &amp;#43; \Theta(n) \\ &amp;amp;= \Theta(n^2) &amp;amp;\text{naive approach} \end{aligned}\]  A problem divided into any ratio, with the rest of the problem a complement of the original input, the overall complexity will still be  \( \Theta(n \lg n) \)  .
Mergesort #  Mergesort does not sort in place.</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210929</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210929/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210929/</guid>
      <description>Quicksort #  The way that the array is divided matters.
Partitioning the array using Hoare&amp;rsquo;s partition #  i will move toward the right until it reaches a element that is bigger or equal to the pivot point. j will move to the right until it finds a element that is less thatn or equal to the pivot point. i and j will swap as long as the pointers haven&amp;rsquo;t crossed paths.</description>
    </item>
    
    <item>
      <title>CS140-lecture-20211006</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20211006/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20211006/</guid>
      <description>Common divide and conquer problems #  Counting Inversions #  Inversions are the number of out of order pairs in an array of numbers. We can use the amount of inversions as a ranking for multiple arrays.
If we consider the first array as sorted (the indices), we can use the second array&amp;rsquo;s indices as a rank to compare.
When we try and count inversions, we are given an array of   \( n \)  numbers.</description>
    </item>
    
  </channel>
</rss>
