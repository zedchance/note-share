<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CS140 on Notes</title>
    <link>http://zedchance.github.io/notes/CS140/</link>
    <description>Recent content in CS140 on Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://zedchance.github.io/notes/CS140/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CS140-lecture-20210830</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210830/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210830/</guid>
      <description>Course orientation #  Syllabus #  File: 140-syllabus.pdf  Notes during orientation #   Regular quizzes 2 exams Modules has prerecorded lectures Homework assignments not graded Can watch videos during Zoom meeting, or prior Generally 1 quiz per lecture (calendar at end of syllabus), given at the first class after the last day of the lecture Turn in work as single PDF file  Methods of proof #  File: 140-methods_of_proof.</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210901</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210901/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210901/</guid>
      <description>A note on learning in this class #  On different levels of learning
We will strive for about 60% of problems being level 3.
When working on a problem, there can be 3 outcomes
 could solve it could not solve it solved, but incorrect  If solved incorrectly, tracing back to the exact part that went wrong can be really beneficial.
Methods of proof cont. #  An easy starting example #  Suppose that   \( x &amp;gt; 3 \)  , is  \( x^2-2y &amp;gt; 5 \)  ?</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210907</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210907/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210907/</guid>
      <description>Asymptotic notation cont #  Big Omega #  Omega is lower bound (where Big O is upper bound).
Examples #     \[\begin{aligned} 5n^2 = \Omega(n) \end{aligned}\]   \( \exists c,n_0 \)  such that  \( 0 \leq c_n \leq 5 n^2 \)  So,  \[\begin{aligned} c \leq 5n \end{aligned}\]  so  \( c = 1 \)  and  \( n_0 = 1 \)  .</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210913</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210913/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210913/</guid>
      <description>Backtracking #  Recursive programming can be divided into two categories. One category creates the solution, and the other searches for the solution.
When searching, we want to consider backtracking.
We can search these decision trees for our solution in the solution space. When looking for a solution, if we ever reach a subtree that doesn&amp;rsquo;t meet our criteria, we can backtrack.
Strategies #  Examples #  Pretend that our maze is represented with 0 and 1, a 2D array where 0 is a wall and 1 is not, something like this:</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210915</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210915/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210915/</guid>
      <description>Recursion #  Recursive tracing #  m(648) m(72) m(9) return 9 My trace
m(348) a = m(34) a = m(3) return 33 a = 33 b = m(4) return 44 b = 44 return 3344 a = 3344 b = m(8) return 88 b = 88 return 334488 pow example #  My solution
pow(b, e): if e == 0: return 1 return b * pow(b, e - 1) Trace</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210927</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210927/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210927/</guid>
      <description>Divide and conquer #    \[\begin{aligned} T(n) &amp;amp;= 2T \left( \frac{n}{2} \right) &amp;#43; \Theta (n) \\ &amp;amp;= \Theta(n\log n) &amp;amp;\text{divide and conquer}\\ T(n) &amp;amp;= T(n-1) &amp;#43; \Theta(n) \\ &amp;amp;= \Theta(n^2) &amp;amp;\text{naive approach} \end{aligned}\]  A problem divided into any ratio, with the rest of the problem a complement of the original input, the overall complexity will still be  \( \Theta(n \lg n) \)  .
Mergesort #  Mergesort does not sort in place.</description>
    </item>
    
    <item>
      <title>CS140-lecture-20210929</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20210929/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20210929/</guid>
      <description>Quicksort #  The way that the array is divided matters.
Partitioning the array using Hoare&amp;rsquo;s partition #  i will move toward the right until it reaches a element that is bigger or equal to the pivot point. j will move to the right until it finds a element that is less thatn or equal to the pivot point. i and j will swap as long as the pointers haven&amp;rsquo;t crossed paths.</description>
    </item>
    
    <item>
      <title>CS140-lecture-20211006</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20211006/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20211006/</guid>
      <description>Common divide and conquer problems #  Counting Inversions #  Inversions are the number of out of order pairs in an array of numbers. We can use the amount of inversions as a ranking for multiple arrays.
If we consider the first array as sorted (the indices), we can use the second array&amp;rsquo;s indices as a rank to compare.
When we try and count inversions, we are given an array of   \( n \)  numbers.</description>
    </item>
    
    <item>
      <title>CS140-lecture-20211014</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20211014/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20211014/</guid>
      <description>Recurrences cont #  Recursion tree method #  Another method to solve recurrences is to draw a recursion tree, where each node gets a cost. The cost of each node is the additional work done on each recursive call (not recursive call itself).
The leaf nodes are the base cases. The idea is to identify a pattern, and use a known series to evaluate that pattern.
Then, after identifying the sum of each level of the tree, you then sum all the level&amp;rsquo;s themselves (except the base level, the leaves).</description>
    </item>
    
    <item>
      <title>CS140-lecture-20211025</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20211025/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20211025/</guid>
      <description>Graph basics #  In basic graphs, self loops and multiple edges between vertices are not considered. The number of edges are calculated by
  \[\begin{aligned} |E| = \binom{n}{2} = \frac{n(n-1)}{2} = \Theta(n^2) \end{aligned}\]  A directed graph is
 strongly connected if there is a path from any vertex to any other vertex in the direction of edges unilaterally connected if for any 2 vertices there is a directed path to and from each vertices weakly connected if there is a path from any vertex to any other vertex, but not in the direction of edges  Representing graphs #  Adjacency lists #  Note: The total length of linked lists for directed graph is less than the total length of linked lists for the undirected graph in this example.</description>
    </item>
    
    <item>
      <title>CS140-lecture-20211027</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20211027/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20211027/</guid>
      <description>Variable length encoding #  If we want to compress a file, we need to represent each symbol with a string of binary digits. If our strings are variable length, then that means the representation for any symbol should not be the prefix of the representation of another symbol.
Huffman codes #  The value at each node is the frequency of symbols in the subtree. The leaves represent symbols, and each left or right child represents a 0 or 1.</description>
    </item>
    
    <item>
      <title>CS140-lecture-20211101</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20211101/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20211101/</guid>
      <description>Dynamic programming #  Dynamic programming is an algorithm design technique. In dynamic programming, you solve the problem bottom-up (as opposed to top-down in divide and conquer).
Another trait of dynamic programming is that when a sub problem is solved, it is only solved once (which may not be the case in divide and conquer).
 Notice that multiple sub problems are solved multipled times  Assembly line scheduling problem #      \( e_n \)  is the arrival time in assembly line  \( n \)    \( a_{i,j} \)  is the time it takes at station  \( j \)  in assembly line  \( i \)    \( t_{i,j} \)  is the transfer time  \( x_n \)  is the exit times for assembly line  \( n \)     the idea is that  \( a_{1,j} \)  has the optimal subproblem solution to  \( a_{1,j-1} \)  and the optimal subproblem solution to  \( a_{2,j-1} \)  in it  So in general</description>
    </item>
    
    <item>
      <title>CS140-lecture-20211108</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20211108/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20211108/</guid>
      <description>Matrix-chain multiplication #   total time complexity of   \( \Theta(mnp) \)    Optimal parenthesization #   this results in exponential complexity  So let&amp;rsquo;s use dynamic programming:
 make sure to start with the base case, when i = j, the main diagonal of the array   then, we can start to fill in the spaces to the top right of each base case.</description>
    </item>
    
    <item>
      <title>CS140-lecture-20211110</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20211110/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20211110/</guid>
      <description>Memoization #  Elements of dynamic programming #  Longest common subsequence #   base cases along left and top edge   see which subproblems are needed to solve current sub problem   our next level after base cases is the top left corner   nested loops   another order to solve   can also go by columns   overall runtime is   \( \Theta(n) \)  where  \( n = i &amp;#43; j \)  , the sum of the 2 sequences  My solution in Python  Output</description>
    </item>
    
    <item>
      <title>CS140-lecture-20211117</title>
      <link>http://zedchance.github.io/notes/CS140/CS140-lecture-20211117/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://zedchance.github.io/notes/CS140/CS140-lecture-20211117/</guid>
      <description>Some more dynamic programming examples #  Segmented least squares #   if we connected all points between each other, there would be zero error we want a trade off between accuracy and number of segments   imagine connecting the last 2 points, and then attaching it to the rest of the optimal solution or connecting the last 3 points and attaching it to the rest of the optimal solutions and so on&amp;hellip;  Weighted activity selection #      \( O(n \lg n) \)  complexity (sort)  The knapsack problem revisited #  Automated memoization #  Flow network #   notation is &amp;ldquo;capacity / flow&amp;rdquo;  Max flow #  Ford-Fulkerson method #   can increase flow by 5   lower path is not an augmenting edge, flow cannot increase   there is no augmenting path left (can&amp;rsquo;t find path from source to sink), so the max flow of the previous graph is the answer   the max flow of the network will be less than or equal to a cut   the max flow is the min cut  Edmonds-Karp algorithm #  Multiple sources or sinks #  Bipartite matching #  </description>
    </item>
    
  </channel>
</rss>
