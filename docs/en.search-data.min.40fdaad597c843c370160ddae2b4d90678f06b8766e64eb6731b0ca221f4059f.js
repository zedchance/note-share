'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/notes/CS10/',title:"CS10",section:"Lecture Notes",content:"CS10 – Intro to Computer Science #    CS10-labs    processing\n   "}),a.add({id:1,href:'/notes/CS12/',title:"CS12",section:"Lecture Notes",content:"CS12 – Programming Concepts and Methods I #    CS12-lecture-notes    java\n   "}),a.add({id:2,href:'/notes/CS13/',title:"CS13",section:"Lecture Notes",content:"CS13 – Programming Concepts and Methods II #    CS13-lecture-notes    java\n   "}),a.add({id:3,href:'/notes/CS130/',title:"CS130",section:"Lecture Notes",content:"CS130 – Data Structures and Algorithms #    CS130-exercise-solutions-1       CS130-lecture-20200831    syllabus\n   CS130-lecture-20200902    asymptotic notation\nrecursion\ntail recursion\n   CS130-lecture-20200909    space complexity\ntime complexity\n   CS130-lecture-20200914    time complexity\nspace complexity\n   CS130-lecture-20200916    mergesort\n   CS130-lecture-20200921    mergesort\nquicksort\n   CS130-lecture-20200923    quicksort\n   CS130-lecture-20200928    priority queues\nquicksort\n   CS130-lecture-20200930    heapsort\npriority queues\n   CS130-lecture-20201005    heapsort\n   CS130-lecture-20201007    count sort\nheapsort\nradix sort\n   CS130-lecture-20201012    binary search\nradix sort\nsymbol table\n   CS130-lecture-20201014    binary search\n   CS130-lecture-20201019    binary search\n   CS130-lecture-20201021    review\n   CS130-lecture-20201028    2-3 search tree\nred-black BST\n   CS130-lecture-20201102    2-3 search tree\nred-black BST\n   CS130-lecture-20201104    red-black BST\nB-tree\nunordered symbol table\n   CS130-lecture-20201109    unordered symbol table\nhashing\n   CS130-lecture-20201116    unordered symbol table\nhashing\nlinear probing\n   CS130-lecture-20201118    symbol table\ndisjoint set\n   CS130-lecture-20201123    disjoint set\nunion find\n   CS130-lecture-20201125    graph\nundirected graph\ndepth first search\n   CS130-lecture-20201130    graph\nbreadth first search\ndirected graph\ntopological sort\n   CS130-lecture-20201202    graph\nweighted graph\nminimum spanning tree\ntopological sort\nedge weighted digraph\nkosaraju\u0026#39;s algorithm\nprim\u0026#39;s algorithm\nkruskal\u0026#39;s algorithm\n   CS130-lecture-20201207    shortest path tree\ndijkstra\u0026#39;s algorithm\nbellman-ford algorithm\nturing machine\nNP-completeness\n   CS130-lecture-20201209    review\n   CS130-priority-queues       CS130-sorting-algorithms    mergesort\nquicksort\n   "}),a.add({id:4,href:'/notes/CS131/',title:"CS131",section:"Lecture Notes",content:"CS131 – Software Engineering #    CS131-lecture-20200901    software engineering\n   CS131-lecture-20200903    software engineering\nsoftware development life cycles\nagile\n   CS131-lecture-20200908    agile\n   CS131-lecture-20200910    agile\nscrum\n   CS131-lecture-20200915    use case\n   CS131-lecture-20200917    agile\n   CS131-lecture-20200922    contextual inquiry\n   CS131-lecture-20200924    scrum\nuser stories\n   CS131-lecture-20200929    human computer interaction\ncontextual inquiry\n   CS131-lecture-20201001    contextual inquiry\n   CS131-lecture-20201006    737 Boeing disaster\n   CS131-lecture-20201008    human computer interaction\n   CS131-lecture-20201013       CS131-lecture-20201015    git\n   CS131-lecture-20201020    REST\n   CS131-lecture-20201022    software architecture\ncrc\n   CS131-lecture-20201027    sprint review\n   CS131-lecture-20201029    software architecture\n   CS131-lecture-20201103    UML\nclass diagrams\n   CS131-lecture-20201105    UML\nclass diagrams\nsoftware design\n   CS131-lecture-20201110    class diagrams\nUML\nsoftware design\ncode design\n   CS131-lecture-20201112    code design\n   CS131-lecture-20201119    implementation\nstatic analysis\ndynamic analysis\nrefactoring\n   CS131-lecture-20201124    project management\nverification/validation\n   CS131-lecture-20201201    verification/validation\n   CS131-lecture-20201203    verification/validation\n   CS131-lecture-20201208    devops\n   CS131-study-guide-1       CS131-study-guide-2       CS131-study-guide-3       CS131-study-guide-4       "}),a.add({id:5,href:'/notes/CS133/',title:"CS133",section:"Lecture Notes",content:"CS133 – Object Oriented Computer Graphics #    CS133-lecture-20210125    abstraction\nmodularity\ncoupling\ncohesion\nencapsulation\n   CS133-lecture-20210208    UML\nsoftware design\nclean code\n   CS133-lecture-20210210    inheritance\npolymorphism\ninterfaces\n   CS133-lecture-20210215    GUI\ncodename one\n   CS133-lecture-20210217    codename one\nevent driven\ncommand design\nobserver design\n   CS133-lecture-20210227    software design\ndesign patterns\n   CS133-lecture-20210301    design patterns\n   CS133-lecture-20210307    clean code\n   CS133-lecture-20210310    color theory\nGUI\n   CS133-lecture-20210314    GUI\ncodename one\n   CS133-lecture-20210407    transformations\n   CS133-lecture-20210423    animation\nsound\nmultiple dispatch\n   CS133-lecture-20210504    transformations\nsound\n   CS133-lecture-20210513    threads\nmultitasking\n   CS133-lecture-20210519    app distribution\n   "}),a.add({id:6,href:'/notes/CS134/',title:"CS134",section:"Lecture Notes",content:"CS134 – Database Management Systems #    CS134-lecture-20210601    syllabus\nDBMS\n   CS134-lecture-20210602    DBMS\nER model\n   CS134-lecture-20210603    ER model\n   CS134-lecture-20210607    ER model\nrelational model\n   CS134-lecture-20210608    relational model\nkeys\n   CS134-lecture-20210609    relational model\nschema\n   CS134-lecture-20210610    relational model\nrelational algebra\n   CS134-lecture-20210614    relational algebra\n   CS134-lecture-20210615    relational algebra\n   CS134-lecture-20210616    relational algebra\n   CS134-lecture-20210617    SQL\n   CS134-lecture-20210621    SQL\n   CS134-lecture-20210623    SQL\n   CS134-lecture-20210624    SQL\n   CS134-lecture-20210628    SQL\n   CS134-lecture-20210629    SQL\nfunctional dependency\nnormalization\n   CS134-lecture-20210702    normalization\nstorage\n   CS134-lecture-20210707    storage\nindexing\n   "}),a.add({id:7,href:'/notes/CS135/',title:"CS135",section:"Lecture Notes",content:"CS135 – Computer Theory and Programming Languages #    CS135-hw-20210203       CS135-hw-20210302    racket\n   CS135-lecture-20210126       CS135-lecture-20210129    finite automata\n   CS135-lecture-20210201    finite automata\n   CS135-lecture-20210204    regular expressions\n   CS135-lecture-20210205    finite automata\nregular expressions\n   CS135-lecture-20210209    pumping lemma\n   CS135-lecture-20210216    regular expressions\nfinite automata\n   CS135-lecture-20210217    pumping lemma\n   CS135-lecture-20210218    immutability\nracket\n   CS135-lecture-20210225    tail recursion\naccumulators\nracket\n   CS135-lecture-20210227    functional programming\nrecursion\nracket\n   CS135-lecture-20210307    racket\nmergesort\nlambdas\nclosure\n   CS135-lecture-20210309    tail recursion\nracket\n   CS135-lecture-20210310    context-free grammar\npush-down automata\n   CS135-lecture-20210311    push-down automata\n   CS135-lecture-20210315    context-free grammar\nparse trees\nambiguity\n   CS135-lecture-20210318    context-free language\npumping lemma\n   CS135-lecture-20210329    context-free grammar\npush-down automata\npumping lemma\n   CS135-lecture-20210405    compilers\nlexers\nparsers\n   CS135-lecture-20210407    lexers\n   CS135-lecture-20210419    lexers\nparsers\nrecursive-descent predictive-parsing\n   CS135-lecture-20210423    turing machine\n   CS135-lecture-20210426    parsers\n   CS135-lecture-20210428    turing machine\nreductions\n   CS135-lecture-20210505    brainfuck\n   CS135-lecture-20210511    reductions\nbrainfuck\n   "}),a.add({id:8,href:'/notes/CS137/',title:"CS137",section:"Lecture Notes",content:"CS137 – Computer Organization #    CS137-lecture-20210126    syllabus\n   CS137-lecture-20210128       CS137-lecture-20210202    IEEE754\n   CS137-lecture-20210204    IEEE754\n   CS137-lecture-20210209    combinational circuits\ndemorgan\u0026#39;s theorem\n   CS137-lecture-20210211    karnaugh map\n   CS137-lecture-20210216    full adder\n   CS137-lecture-20210218    full adder\n   CS137-lecture-20210223    demorgan\u0026#39;s theorem\n   CS137-lecture-20210225    multiplexers\n   CS137-lecture-20210302    sequential circuits\n   CS137-lecture-20210304    sequential circuits\ns-r latch\n   CS137-lecture-20210309    review\n   CS137-lecture-20210316    sequential circuits\nfinite state machine\n   CS137-lecture-20210318    sequential circuits\nfinite state machine\n   CS137-lecture-20210330    sequential circuits\nfinite state machine\nmoore machine\n   CS137-lecture-20210401    finite state machine\nmoore machine\nmealy machine\n   CS137-lecture-20210406    mealy machine\nsequential circuits\n   CS137-lecture-20210408    sequential circuits\n   CS137-lecture-20210413    sequential circuits\n   CS137-lecture-20210415    memory\n   CS137-lecture-20210420    review\n   CS137-lecture-20210427    instruction set architecture\n   CS137-lecture-20210429    instruction set architecture\n   CS137-lecture-20210506    instruction set architecture\n   CS137-lecture-20210511    instruction set architecture\n   CS137-lecture-20210513    review\n   "}),a.add({id:9,href:'/notes/CS138/',title:"CS138",section:"Lecture Notes",content:"CS138 – Computer Networking and Internet #    CS138-lecture-20210126    syllabus\n   CS138-lecture-20210128    network edge\n   CS138-lecture-20210202    network edge\nnetwork core\n   CS138-lecture-20210204    network core\ndelay\nloss\nthroughput\n   CS138-lecture-20210209    network core\ndelay\nthroughput\n   CS138-lecture-20210211    protocol layers\nnetwork security\nnetwork history\napplication layer\n   CS138-lecture-20210216    application layer\nhttp\n   CS138-lecture-20210218    http\ncookies\nproxy\n   CS138-lecture-20210223    web caching\nftp\nemail\n   CS138-lecture-20210225    dns\n   CS138-lecture-20210302    dns\np2p\n   CS138-lecture-20210304    sockets\n   CS138-lecture-20210309    transport layer\nUDP\n   CS138-lecture-20210311    UDP\n   CS138-lecture-20210316    review\n   CS138-lecture-20210330    piplined protocols\ngo-back-n\nselective repeat\n   CS138-lecture-20210401    TCP\n   CS138-lecture-20210406    TCP\nflow control\ncongestion control\n   CS138-lecture-20210408    TCP\ncongestion control\nthroughput\nnetwork layer\n   CS138-lecture-20210413    review\nvirtual circuits\ndatagrams\n   CS138-lecture-20210415    network layer\nswitching fabrics\ninternet protocol\nIPv4\n   CS138-lecture-20210420    network layer\nIPv4\nDHCP\nNAT\nICMP\nIPv6\n   CS138-lecture-20210422    routing algorithms\ndijkstra\u0026#39;s algorithm\nintra-as\nIGP\nbroadcast/multicast\n   CS138-lecture-20210427    link layer\ncyclic redundancy check\nmultiple access protocols\nCSMA\n   CS138-lecture-20210429    multiple access protocols\nCSMA\nLAN\n   CS138-lecture-20210504    LAN\ndata centers\nreview\n   CS138-lecture-20210506    network security\nRSA\n   CS138-lecture-20210511    network security\nRSA\nauthentication\nemail\n   CS138-lecture-20210513    network security\nTLS\nIPSec\nfirewall\nIDS\n   "}),a.add({id:10,href:'/notes/CS139/',title:"CS139",section:"Lecture Notes",content:"CS139 – Operating System Principles #    CS139-lecture-20210831    syllabus\n   CS139-lecture-20210902    operating system types\n   CS139-lecture-20210907    operating system types\ninterrupts\n   CS139-lecture-20210909    interrupts\noperating system structure\nkernel\n   CS139-lecture-20210914    kernel\nprocesses\nprocess control block\nscheduling\n   CS139-lecture-20210916    processes\nscheduling\n   CS139-lecture-20210921    processes\nprocess termination\ninter-process communication\n   CS139-lecture-20210923    processes\nthreads\n   CS139-lecture-20210928    threads\n   CS139-lecture-20210930    scheduling\n   CS139-lecture-20211005    scheduling\nCFS\n   CS139-lecture-20211007    scheduling\nCFS\n   CS139-lecture-20211021    synchronization\nsemaphores\n   CS139-lecture-20211026    synchronization\nsemaphores\n   CS139-lecture-20211028    semaphores\ndeadlock\n   CS139-lecture-20211102    deadlock\nbanker\u0026#39;s algorithm\n   CS139-lecture-20211104    deadlock\nbanker\u0026#39;s algorithm\n   CS139-lecture-20211109    memory\n   CS139-lecture-20211116    memory\npaging\n   CS139-lecture-20211118    memory\npaging\nvirtual memory\n   CS139-lecture-20211123    virtual memory\n   CS139-lecture-20211202    mass storage\n   CS139-lecture-20211207    file systems\n   CS139-lecture-20211209    file systems\n   "}),a.add({id:11,href:'/notes/CS140/',title:"CS140",section:"Lecture Notes",content:"CS140 – Advanced Algorithm Design and Analysis #    CS140-lecture-20210830    syllabus\nproof\n   CS140-lecture-20210901    proof\nasymptotic analysis\n   CS140-lecture-20210907    asymptotic analysis\n   CS140-lecture-20210913    backtracking\n   CS140-lecture-20210915    recursion\n   CS140-lecture-20210927    divide and conquer\nmergesort\n   CS140-lecture-20210929    divide and conquer\nquicksort\n   CS140-lecture-20211006    divide and conquer\nrecurrences\n   CS140-lecture-20211014    recurrences\nquicksort\n   CS140-lecture-20211025    graph\ngreedy algorithms\n   CS140-lecture-20211027    variable length encoding\nhuffman codes\nminimum spanning tree\nkruskal\u0026#39;s algorithm\nprim\u0026#39;s algorithm\n   CS140-lecture-20211101    dynamic programming\n   CS140-lecture-20211108    dynamic programming\n   CS140-lecture-20211110    memoization\n   CS140-lecture-20211117    dynamic programming\nmemoization\nflow network\nford-fulkerson method\n   CS140-lecture-20211129    NP-completeness\nreductions\n   CS140-lecture-20211207    reductions\n   "}),a.add({id:12,href:'/notes/CS152/',title:"CS152",section:"Lecture Notes",content:"CS152 Cryptography #    CS152-lecture-20210601    syllabus\nfunctions\npermutations\nprobability\nmemory\n   CS152-lecture-20210603    C\nmemory\nendianness\nrotation\ndata flow\n   CS152-lecture-20210604    bitwise\nmemory allocation\nAXR\nfeistel\nciphers\n   CS152-lecture-20210607    distinguishing games\nadvantage\nbirthday bound\n   CS152-lecture-20210608    confusion\ndiffusion\nperm384\n   CS152-lecture-20210610    symmetric encryption\nblock cipher\nencryption modes\nAES\nsecurity\ngalois fields\n   CS152-lecture-20210611    fields\ngalois fields\npadding\n   CS152-lecture-20210613    encryption modes\nAES\nSSE\nSSL\n   CS152-lecture-20210615    stream ciphers\nCHACHA20\nSSE\n   CS152-lecture-20210617    hashing\n   CS152-lecture-20210621    hashing\nsponge construction\nreductions\n   CS152-lecture-20210622    authentication\ntag generators\n   CS152-lecture-20210624    asymmetric encryption\nRSA\nprimes\nBIGNUM\n   CS152-lecture-20210626    asymmetric encryption\nexponentiation\nGCD\nmultiplicative inverse\n   CS152-lecture-20210627    RSA\nOAEP\nauthentication\nDiffie-Hellman\n   CS152-lecture-20210629    asymmetric encryption\nElGamal\ngroups\n   CS152-lecture-20210701    groups\nelliptic curve groups\nDiffie-Hellman\nfortuna\n   CS152-lecture-20210706    block ciphers\nOCB\ncertificates\n   "}),a.add({id:13,href:'/notes/CS177/',title:"CS177",section:"Lecture Notes",content:"CS177 – Data Analytics and Mining #    CS177-lecture-20220125    syllabus\n   CS177-lecture-20220127    data exploration\n   CS177-lecture-20220202    data exploration\nclassification\n   CS177-lecture-20220203    data exploration\nclassificiation\n   CS177-lecture-20220210    numpy\npandas\n   CS177-lecture-20220215    data preprocessing\n   CS177-lecture-20220217    data preprocessing\n   CS177-lecture-20220222    data preprocessing\nsimilarity\nsampling\n   CS177-lecture-20220224    classification\nhunt\u0026#39;s algorithm\n   CS177-lecture-20220301    classification\n   CS177-lecture-20220303       CS177-lecture-20220308    linear regression\n   "}),a.add({id:14,href:'/notes/CS190/',title:"CS190",section:"Lecture Notes",content:"CS190 – Senior Project, part 1 #    CS190-lecture-20210830       CS190-lecture-20210913       CS190-lecture-20210920       CS190-lecture-20210927       CS190-lecture-20211004       CS190-lecture-20211011       CS190-lecture-20211025       CS190-lecture-20211101       CS190-lecture-20211108       CS190-lecture-20211115       "}),a.add({id:15,href:'/notes/CS191/',title:"CS191",section:"Lecture Notes",content:"CS191 – Senior Project, part 2 #    CS191-lecture-20220126    syllabus\n   CS191-lecture-20220202       CS191-lecture-20220216       CS191-lecture-20220223       CS191-lecture-20220302       "}),a.add({id:16,href:'/notes/CS192/',title:"CS192",section:"Lecture Notes",content:"CS192 – Career Planning #    CS192-lecture-20210903       CS192-seminar-20210910    leadership\n   CS192-seminar-20210924    leadership\n   CS192-seminar-20211001       CS192-seminar-20211008    leadership\n   CS192-seminar-20211022    leadership\n   CS192-seminar-20211029    leadership\n   CS192-seminar-20211105       CS192-seminar-20211112    cyber security\n   CS192-seminar-20211119    leadership\n   CS192-seminar-20211203       "}),a.add({id:17,href:'/notes/CS26/',title:"CS26",section:"Lecture Notes",content:"CS26 – Discrete Structures #    CS26-lecture-notes    discrete structures\npython\n   CS26-reading-notes       "}),a.add({id:18,href:'/notes/CS39/',title:"CS39",section:"Lecture Notes",content:"CS39 – Intro to Computer Architecture #    CS39-lecture-notes    assembly\n   "}),a.add({id:19,href:'/notes/CS46/',title:"CS46",section:"Lecture Notes",content:"CS46 – System Programming with C #    CS46-lecture-notes    C\n   Luhn\u0026#39;s Algorithm    C\n   "}),a.add({id:20,href:'/notes/MATH100/',title:"MATH100",section:"Lecture Notes",content:"MATH100 – Applied Linear Algebra #    MATH100-lecture-notes    linear algebra\n   "}),a.add({id:21,href:'/notes/MATH102/',title:"MATH102",section:"Lecture Notes",content:"MATH102 – Number Theory #    MATH102-lecture-20220125    syllabus\n   MATH102-lecture-20220127    divisibility\n   MATH102-lecture-20220201    divisibility\n   MATH102-lecture-20220203    divisibility\n   MATH102-lecture-20220208    divisibility\n   MATH102-lecture-20220210    divisbility\nleast common multiple\n   MATH102-lecture-20220215    least common multiple\n   MATH102-lecture-20220301    functions\n   MATH102-lecture-20220303       MATH102-lecture-20220308       "}),a.add({id:22,href:'/notes/MATH170/',title:"MATH170",section:"Lecture Notes",content:"MATH170 – Linear Programming #    MATH170-latex-notes       MATH170-lecture-20210831    syllabus\n   MATH170-lecture-20211012    MATLAB\n   MATH170-lecture-20211020    two phase procedure\n   MATH170-lecture-20211021    two phase procedure\nsensitivity analysis\n   MATH170-lecture-20211026    sensitivity analysis\n   MATH170-lecture-20211028    sensitivity analysis\n   MATH170-lecture-20211102    sensitivity analysis\n   MATH170-lecture-20211104       MATH170-lecture-20211109    duality\n   MATH170-lecture-20211116    duality\n   MATH170-lecture-20211130    duality\nnetwork models\n   MATH170-lecture-20211202    network models\n   MATH170-lecture-20211207    network models\n   MATH170-lecture-20211209    network models\n   "}),a.add({id:23,href:'/notes/MATH31/',title:"MATH31",section:"Lecture Notes",content:"MATH31 – Calculus II #    MATH31-comparison-tests    series\n   MATH31-integral-test    integration\n   MATH31-series    series\n   MATH31-unit-1       MATH31-unit-2       MATH31-unit-3       "}),a.add({id:24,href:'/notes/PHIL103/',title:"PHIL103",section:"Lecture Notes",content:"PHIL103 – Business and Computer Ethics #    PHIL103-ec-lecture       PHIL103-lecture-20200831    applied ethics\n   PHIL103-lecture-20200907    division of labor\n   PHIL103-lecture-20200916    capitalism/socialism\n   PHIL103-lecture-20200924    property rights\n   PHIL103-lecture-20200927    property rights\n   PHIL103-lecture-20201008    privacy\n   PHIL103-lecture-20201014    blockchain\n   PHIL103-lecture-20201024    net neutrality\n   PHIL103-lecture-20201028    corporate social responsibility\n   PHIL103-lecture-20201104    market failures\n   PHIL103-lecture-20201110    behavior\n   PHIL103-lecture-20201122    morality\n   "}),a.add({id:25,href:'/notes/PHYS105/',title:"PHYS105",section:"Lecture Notes",content:"  PHYS105-resources       PHYS105-lab-20200326    centripetal force\n   PHYS105-lab-20200402    ballistic pendulum\n   PHYS105-lab-20200423    ideal gas law\n   PHYS105-lecture-20200319       PHYS105-lecture-20200326    circular motion\n   PHYS105-lecture-20200331    circular motion\n   PHYS105-lecture-20200402    gravitational forces\n   PHYS105-lecture-20200414    torque\nequilibrium\n   PHYS105-lecture-20200416    equilibrium\nrotational motion\n   PHYS105-lecture-20200421    rotational motion\n   PHYS105-lecture-20200428    thermodynamics\n   PHYS105-lecture-20200430    kinetic theory of gases\ncalorimetry\n   PHYS105-lecture-20200505       PHYS105-lecture-20200507    convection/radiation\n   PHYS105-lecture-20200512    heat engines\nthermodynamics\n   PHYS105-lecture-20200514    heat engines\nthermodynamics\nentropy\n   PHYS105-recitation-20200331    angular motion\n   PHYS105-recitation-20200414       PHYS105-recitation-20200416    equilibrium\nkinematics\nrotational motion\n   PHYS105-recitation-20200421       PHYS105-recitation-20200428    ideal gas law\n   PHYS105-recitation-20200430       PHYS105-recitation-20200505    convection/radiation\n   PHYS105-recitation-20200507    ideal gas law\n   PHYS105-recitation-20200512       PHYS105-recitation-20200514       "}),a.add({id:26,href:'/notes/RPTA125/',title:"RPTA125",section:"Lecture Notes",content:"RPTA125 – Leisure and Society #    RPTA125-lecture-20220125       RPTA125-lecture-20220201    leisure\n   RPTA125-lecture-20220208    recreation\n   RPTA125-lecture-20220215    leisure\n   RPTA125-lecture-20220301    leisure theories\n   RPTA125-lecture-20220308       "}),a.add({id:27,href:'/notes/STATS50/',title:"STATS50",section:"Lecture Notes",content:"STATS50 – Intro to Probability and Statistics #    STATS50-lecture-notes    stats\n   "}),a.add({id:28,href:'/notes/sample/',title:"Sample",section:"Lecture Notes",content:'Format testing #  Voluptatem sunt ut asperiores. #  Quis iusto non et aut omnis officiis tempora. Odit aut ullam nisi voluptas a. Est animi et ut natus molestias sit. Quis iusto non et aut omnis officiis tempora. Quis iusto non et aut omnis officiis tempora. Odit aut ullam nisi voluptas a. Est animi et ut natus molestias sit. Odit aut ullam nisi voluptas a. Est animi et ut natus molestias sit.\nDanger!!!\nVoluptatem sunt ut asperiores. Quis iusto non et aut omnis officiis tempora. Odit aut ullam nisi voluptas a. Est animi et ut natus molestias sit.\n\\[f(x) = \\sqrt{n}\\]\none Voluptatem sunt ut asperiores. Quis iusto non et aut omnis officiis tempora. Odit aut ullam nisi voluptas a. Est animi et ut natus molestias sit.  Another Voluptatem sunt ut asperiores. Quis iusto non et aut omnis officiis tempora. Odit aut ullam nisi voluptas a. Est animi et ut natus molestias sit.    Here is the first column. Et fuga quae sed. Tempore facilis maiores quis ut qui quis a cumque. Accusamus quia error est. Veritatis vero dolor et molestiae exercitationem.\nSystem.out.println(\u0026#34;Yo, world!\u0026#34;); Nostrum et eveniet dolorum. Soluta sint voluptas eligendi. Qui molestiae enim laborum necessitatibus sed cumque velit. Laborum aut repellendus et qui possimus architecto cum. Quis laboriosam nostrum quia.\n Here is some more stuff in the second column.\n// code   \\[\\begin{aligned} f(x) = \\sqrt{n} \\end{aligned}\\]   mermaid.initialize({ "flowchart": { "useMaxWidth":true }, "theme": "default" } ) classDiagram class Test { + int x + int y + getLocation() } Here we go with some more. Voluptate quo corporis explicabo nobis. In excepturi ea enim pariatur qui inventore quibusdam.\n  gitGraph: options { "nodeSpacing": 150, "nodeRadius": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit merge newbranch Example 2 Is this, here we go.\ncode in here \\[f(x) = \\sqrt{n}\\]\nId non fuga molestias doloribus. Temporibus iure quam sequi rerum accusantium libero. Dolores odio eaque reprehenderit veniam temporibus voluptatem. Possimus non expedita blanditiis sit sed voluptatibus iste. Et inventore odit possimus itaque maxime dolorum debitis. Eos explicabo possimus repellat. Earum qui fuga laudantium.\n  Here is some info.\nI think I can keep putting stuff below.\n \\[\\begin{aligned} f(x) = 200000 \\end{aligned}\\]   Look out for this warning.\nNostrum et eveniet dolorum. Soluta sint voluptas eligendi. Qui molestiae enim laborum necessitatibus sed cumque velit. Laborum aut repellendus et qui possimus architecto cum. Quis laboriosam nostrum quia. Voluptatem sunt ut asperiores. Quis iusto non et aut omnis officiis tempora. Odit aut ullam nisi voluptas a. Est animi et ut natus molestias sit.\n More down here #   \\[\\begin{aligned} f(x) = \\int_a^b \\mathrm{d}x \\end{aligned}\\]  Gist inside    Here\npublic static void main(String[] args) { // cool  System.out.println(\u0026#34;Here is some text!\u0026#34;); } Mermaid diagrams #  classDiagram Man graph TD 1 -- 2 2 -- 3 HEAD -- 3 graph TD s1([s1]) s2([s2]) s1 --|a| s1 s1 --|b| s2   pie title NETFLIX "Time spent looking for movie" : 90 "Time spent watching it" : 10 sequenceDiagram Alice - Bob: Hello Bob, how are you? Bob--John: How about you John? Bob--x Alice: I am good thanks! Bob-x John: I am good thanks! Note right of John: Bob thinks a longlong time, so longthat the text doesnot fit on a row. Bob--Alice: Checking with John... Alice-John: Yes... John, how are you? sequenceDiagram Client - Server: GET /index Note right of Server: The server receives the request, and responds Server - Client: OK 200 classDiagram class Shape{  noOfVertices draw() } class Color{  RED BLUE GREEN WHITE BLACK } classDiagram GameObject '}),a.add({id:29,href:'/notes/PHYS105/PHYS105-resources/',title:"PHYS105-resources",section:"PHYS105",content:"   Resources      Text book UniversityPhysicsVolume2-OP.pdf   Lab coversheet p105L Lab Coversheet sp17.pdf   Text 3 notes p105 Test 3 notes.pdf       My stuff      Quiz 6 Quiz-6.pdf   Test 2 PHYS105-test2.pdf    "}),a.add({id:30,href:'/notes/CS10/CS10-Processing-labs/',title:"CS10-labs",section:"CS10",content:"CS10 Labs #  Lab 1 - My \u0026ldquo;creature\u0026rdquo; #  /* Zed Chance Lab 1 CS 10 Summer 18 My \u0026#34;creature\u0026#34; */ //Setup size(800,600); background(0); //MENS BATHROOM SIGN  //Signpost rectMode(CENTER); noStroke(); fill(113,86,86); rect(200,475,30,250); //Background circle fill(70,89,255); ellipseMode(CENTER); stroke(255); strokeWeight(5); ellipse(200,200,350,350); //Head noStroke(); fill(220); ellipse(200,100,70,70); //Torso rectMode(CENTER); rect(200,190,60,100); //Arms rect(200,150,100,20,10); rectMode(CORNER); rect(145,140,20,100,10); rect(235,140,20,100,10); //Legs rect(170,230,27,100,10); rect(203,230,27,100,10); //WOMENS BATHROOM SIGN  //Signpost rectMode(CENTER); noStroke(); fill(113,86,86); rect(600,475,30,250); //Background circle fill(70,89,255); ellipseMode(CENTER); stroke(255); strokeWeight(5); ellipse(600,200,350,350); //Head noStroke(); fill(220); ellipse(600,100,70,70); //Torso rectMode(CENTER); rect(600,190,60,100); //Arms rect(600,150,100,20,10); rectMode(CORNER); stroke(220); strokeWeight(25); line(560,155,535,235); line(640,155,665,235); //Dress quad(585,190,565,255,635,255,615,190); //Legs noStroke(); rect(570,230,27,100,10); rect(603,230,27,100,10); //ARROW SIGNS //left background rectMode(CENTER); fill(220); rect(200,450,150,75,10); fill(150); rect(200,450,145,70,10); //left arrow fill(255); rect(210,450,60,25); triangle(190,425,190,475,150,450); //right background rectMode(CENTER); fill(220); rect(600,450,150,75,10); fill(150); rect(600,450,145,70,10); //right arrow fill(255); rect(590,450,60,25); triangle(610,425,610,475,650,450); Lab 2 - Making my creature redraw with the mouse\u0026rsquo;s movement #  /* Zed Chance Lab 2 CS 10 Summer 18 Making my creature redraw with the mouse\u0026#39;s movement */ //Setup void setup() { size(400, 600); background(0); //Signpost  rectMode(CENTER); noStroke(); fill(113, 86, 86); rect(200, 475, 30, 250); //Background circle  fill(70, 89, 255); ellipseMode(CENTER); stroke(255); strokeWeight(5); ellipse(200, 200, 350, 350); } //Continuously redraw the human void draw() { //Declare mouse  int x = mouseX; int y = mouseY; //Head  stroke(0); strokeWeight(1); //Had to add weight, otherwise it was hard to tell if it was moving  fill(220,x,y); ellipse(x,y,70,70); //was 200,100  //Arms  rect(x,y+50,100,20,10); //was 200,150  rectMode(CORNER); rect(x-55,y+40,20,100,10); //was 145/140  rect(x+35,y+40,20,100,10); //was 235/140  //Legs  rect(x-30,y+130,27,100,10); //was 170,230  rect(x+3,y+130,27,100,10); //was 203,230  //Torso  rectMode(CENTER); rect(x,y+90,60,100); //was 200,190 } //Click mouse to reset void mousePressed() { background(0); //Signpost  rectMode(CENTER); noStroke(); fill(113, 86, 86); rect(200, 475, 30, 250); //Background circle  fill(70, 89, 255); ellipseMode(CENTER); stroke(255); strokeWeight(5); ellipse(200, 200, 350, 350); println(hour(),\u0026#34;:\u0026#34;,minute(),\u0026#34;:\u0026#34;,second(),\u0026#34;-\u0026#34;,\u0026#34;Mouse input detected: Background reset\u0026#34;); } Lab 4 - Launching my \u0026ldquo;creature\u0026rdquo; like a rocket #  /* Zed Chance Lab 4 CS 10 Summer 18 Launching my \u0026#34;creature\u0026#34; like a rocket */ //Initialize variables float r = 0; float g = 0; float b = 0; float x = 0; float y = 0; void setup() { size(400,600); x = width/2; //x is centered  y = height + 50; //starts 50 pixels below  background(0); } void draw() { background(0); //Head  noStroke(); fill(255,255,255); ellipse(x,y,70,70); //Arms  rect(x,y+50,100,20,10); rectMode(CORNER); rect(x-55,y+40,20,100,10); rect(x+35,y+40,20,100,10); //Legs  rect(x-30,y+130,27,100,10); rect(x+3,y+130,27,100,10); //Torso  rectMode(CENTER); rect(x,y+90,60,100); //Rockets  r); b = 5; g); fill(r,g,b); //Jets random color between yellow and red  triangle(x-55,y+135,x-35,y+135,x-45,y+160); //Hand jets  triangle(x+55,y+135,x+35,y+135,x+45,y+160); triangle(x-30,y+225,x-5,y+225,x-18,y+255); //Feet jets  triangle(x+30,y+225,x+5,y+225,x+18,y+255); //Blast off!  x); y = y - 2.5; } Lab 5 - Creature screensaver #  /* Zed Chance Lab 5 CS 10 Summer 18 Creature screensaver */ //Initialize variables float r = 0; float g = 0; float b = 0; float x = 0; float y = 0; float xSpeed = 3; float ySpeed = 1; void setup() { size(600,600); x = width/2; y = height/4; background(0); } void draw() { background(0); //Horizontal movement  x = x + xSpeed; if (x \u0026gt; width-55 || x \u0026lt; 55) { xSpeed = xSpeed*-1; } //Vertical movement  y = y + ySpeed; if (y \u0026gt; height-230 || y \u0026lt; 35) { ySpeed = ySpeed*-1; } //Color changes with quadrant  if (x \u0026lt; width/2 \u0026amp;\u0026amp; y \u0026lt; height/2) { r = 0; g = 0; b = 255; } if (x \u0026gt; width/2 \u0026amp;\u0026amp; y \u0026lt; height/2) { r = 255; g = 0; b = 0; } if (x \u0026lt; width/2 \u0026amp;\u0026amp; y \u0026gt; height/3) { r = 0; g = 255; b = 0; } if (x \u0026gt; width/2 \u0026amp;\u0026amp; y \u0026gt; height/3) { r = 0; g = 255; b = 255; } //Fill body with color determined by above  fill(r,g,b); noStroke(); //Head  ellipse(x,y,70,70); //Arms  rect(x,y+50,100,20,10); rectMode(CORNER); rect(x-55,y+40,20,100,10); rect(x+35,y+40,20,100,10); //Legs  rect(x-30,y+130,27,100,10); rect(x+3,y+130,27,100,10); //Torso  rectMode(CENTER); rect(x,y+90,60,100); } Lab 6 - Multiplying creature with loops #  /* Zed Chance Lab 6 CS 10 Summer 18 Multiplying creature with loops */ //Setup size(800,300); background(0); //Initialize variables float x = -20; float y = 50; float r = 0; float g = 0; float b = 0; while (x \u0026lt; width) { //Color  noStroke(); fill(r,g,b); //Head  ellipse(x,y,70,70); //Arms  rect(x,y+50,100,20,10); rectMode(CORNER); rect(x-55,y+40,20,100,10); rect(x+35,y+40,20,100,10); //Legs  rect(x-30,y+130,27,100,10); rect(x+3,y+130,27,100,10); //Torso  rectMode(CENTER); rect(x,y+90,60,100); //Randomly change color pallette  r); g); b); //Move creature over  x = x + 120; } Lab 7 - Using a function to create multiple creatures #  /* Zed Chance Lab 6 CS 10 Summer 18 Using a function to create multiple creatures */ //Define my creature function void myCreature(float x,float y,color c) { //Color  noStroke(); fill(c); //Head  ellipse(x,y,70,70); //Arms  rect(x,y+50,100,20,10); rectMode(CORNER); rect(x-55,y+40,20,100,10); rect(x+35,y+40,20,100,10); //Legs  rect(x-30,y+130,27,100,10); rect(x+3,y+130,27,100,10); //Torso  rectMode(CENTER); rect(x,y+90,60,100); } void setup() { size(800,800); background(0); } void draw() { //Call my creature function in draw function  myCreature(random(width),random(height),color(random(255),random(255),random(255))); } "}),a.add({id:31,href:'/notes/CS12/CS12-lecture-notes/',title:"CS12-lecture-notes",section:"CS12",content:"CS 12 Lecture notes #  Aug 20, 2018 #  [X] Download Java JDK and jGRASP [2018-08-20]\nA class is a “blueprint\u0026quot; for objects in object-oriented coding\n Aug 22, 2018 #  class #  All Java programs are structured in a class. It is a the fundamental part of a Java program. The simplest programs have a main method, which contains all of the code. The actual java library only has around 40 commands, but it has an extensive library of classes that you can use. ​main​ is the entry point to the code.\nA more serious java program also includes a class​, but it will generally start with fields, then constructors, then accessors, then mutators, then general methods.\npublic class FirstJava { public static void main(String[] args) { System.out.println(\u0026#34;Hello from Java\\n\u0026#34;); } } The public class determines how exposed the class is to the world. class means were going to create a structure these sort of things. FirstJava is the identifier of the class. It is simply a name for the class, created by the programmer, must start with a alphabetic character. The java way is to capiatlize the first character of a class, although it doesn’t need to be. A string is a contiguously allocated sequence of bites. \\n is an escape character to make a new line.\nimport java.util.Scanner; public class MilesPerGallon { public static void main(String[] args) { double miles; double gallons; double mpg; Scanner kb); System.out.print( \u0026#34;Enter miles driven: \u0026#34; ); miles); System.out.print( \u0026#34;Enter gallons used: \u0026#34; ); gallons); mpg = miles / gallons; System.out.println(\u0026#34;Your car drove \u0026#34; + mpg + \u0026#34; miles per gallon\u0026#34;); }// end main }// end class public static void main(String[] args)​\npublic means that it is exposed, a visibility specifier. static means that main exists, its ready to be used. void means that it doesn’t return anything. main is the name of the method, a method is a block of code that does something. All java applets must have a main method. (String[] args) is the parameter list.\n Aug 27, 2018 #   Programming is a craft, with a lot of trial and error.\n Developing software:\n Understand the problem Develop our key algorithm in pseudocode (plain english) Test the algorithm with pencil and paper Code the algorithm in the target language Test the code (arguably the hardest part of the development)  Usually have to go back to step 4, sometimes back to step 2, and if still not working then step 1. If steps 1-3 go well then 4-5 are easy.    Algorithms characteristics:\n Unambiguous Executable Terminates Zero or more inpurts One or more outputs  To develop an algorithm:\n Determine the inputs and the outputs (if you know this step its extremely helpful)  Evaluate solutions (survey the landscape)   Break our solution into smaller pieces (divide and conquer) Describe each subtask in pseudocode Test pseudocode with a desk-check (pencil and paper test)  Pseudocode for making breakfast:\n Fill kettle with water Set kettle on burner Turn burner on high Grind coffee Put pan on burner Turn burner on med Put butter in pan Crack eggs in pan Put english muffin in toaster scramble eggs Pour boiling water into coffee maker Pull english muffins out of toaster place eggs on muffins pour coffee into mug  Pseudocode for Babylonian square root a:\n Start with a / 2 this is g then find average of g and a / g  this is your newg newg) / 2` repeat until 2 consequtive guesses are “close enough”   display newg  The rules of quality software #   Quality software works  It correctly incorporates its specification   Quality software can be read and understood  good variable names commented code clear code not clever code indentation   Quality software is easy to modify   Aug 29, 2018 #  Program to calculate the area of a rectangle area = length * width\npseudocode:\n get length from user get width from user area = length * width print area  import javax.swing.JOptionPane; public class RectangleArea { public static void main(String[] args) { double length; double width; double area; length); width); area = length * width; System.out.println(\u0026#34;Area is \u0026#34; + area); }//end main }//end class JOptionPane makes the user input much more user-friendly by using pop-up dialog boxes. The showInputDialog is expecting a string, but the length variable is expecting a double. So the Double.parseDouble takes the string of numbers and turn it into a double.\nClasses contain:\n Fields Constructor General Methods (behaviors)   Sep 5, 2018 #  Data Types in Java #  Integers:\n   Integers Bits Range     byte 8 -128 \u0026gt; 127   short 16 -32,768 \u0026gt; 32,767   int 32 ~± 2 billion   long 64 ~± 9.2e18 (really big)    //Example byte myByte; myByte = 23; //This is legal myByte) short myShort = 0; //Legal myShort = -100000; //Illegal, out of range  int myInt = 100; long myLong; Twos complement:\n $2 ^ {(bits - 1)} - 1 = max$\n$-2 ^ {(bits - 1)} = min$\n For example in 8 bits:\n $2^{(8 - 1)} - 1)$\n$-2^{(8 - 1)})$\n (The reason you minus one from the max is to compensate for zero)\nTo go from positive to negative (for example in a byte) invert the bits and add 1\nFor example with the decimal number 5:\n $0101 = 5_{10}$\n$1010 + 1 = 1011 = -5_{10}$\n Floating point types:\n   Floats Bits Range Accuracy     float 32 ~± 2 billion ~7 decimal digit accuracy   double 64 ~± 9.2e18 (really big) ~15 decimal digit accuracy    //Examples byte myByte = 97; int myInt = 5; myInt = myByte; //This is legal, they are both integers and it will fit in the int type myBye) float myFloat = 3004.215; int myInt = 315; double myDouble = 297.8; myDouble) myFloat = myInt; //Legal myInt) myFloat = myDouble; //Illegal, 64 bits cannot fit in 32 bits Other types:\n   Other data types Bits Info     char 16 Unicode character set   boolean 1 true or false    Example:\n ‘A’ = 65 = 0x0041\n‘B’ = 66 = 0x0042\n‘C’ = 67 = 0x0043\n‘0’ = 48 = 0x0030\n‘1’ = 49 = 0x0031\n //Example char myChar = \u0026#39;A\u0026#39;; //Use single quotes to assign a char System.out.println(myChar); //Example boolean myBool = true; //Can only be true or false Strings:\nString is a class, not an intrinsic data types. This makes them less limited than the built-in data types.\n//Example public class StringFun { public static void main(String[] args) { String name = \u0026#34;Dave\u0026#34;; String notHere = \u0026#34;\u0026#39;s not here man\u0026#34;; String both = name + notHere; //Concatenation of both strings  System.out.println(both); } } Prints ​Dave’s not here man​\nStrings are just concatenated chars from an array.\n Sep 10, 2018 #  Cat class #     Fields Type     name String   weight double   color String   age int       Methods Return     meow() void   sleep() void   scratch() void   eat() void   birthday() void    public class Cat { //Fields  private String name; private double weight; private String color; private int age; //Constructors  public Cat() { name = \u0026#34;Cat\u0026#34;; weight = 8; color = \u0026#34;Black\u0026#34;; age = 5; }//end default constructor, used to make it easy for testing  public Cat (String n, double w, String c, int a) { name = n; weight = w; color = c; age = a; }//end constructor  //Accessors, let us access a field  public String getName() {return name;} public double getWeight() {return weight;} //Mutators, let us change a field  public void setName(String nn) {name = nn;} public void setWeight(double nw) {weight = nw;} //General methods  public void meow() { System.out.println(name + \u0026#34; is meowing\u0026#34;); } public void hairball() { System.out.println(name + \u0026#34; is making a hairball\u0026#34;); } }//end Cat class In another file to test this:\npublic class CatTest { public static void main(String[] args) { //Reference variable  Cat cat1); //Calling methods  cat1.meow(); cat1.hairball(); //Using an accessor  System.out.println( cat1.getName() ); //Using a mutator  System.out.println(\u0026#34;Current weight: \u0026#34; + cat1.getWeight() ); //seeing current weight  cat1.setWeight(13.2); //new weight  System.out.println(\u0026#34;New weight: \u0026#34; + cat1.getWeight() ); //seeing new weight  } }  Sep 12, 2018 #  Lab 1: Aircraft Class #  Create a Java class the encapsulates the concept of a small aircraft.\nYour class should have the following fields:\n   Type Field Name Description     String manufacturer Name of aircraft manufacturer, e.g., Cessna   String model Model number of the aircraft, e.g., 172   double mtow Maximum takeoff weight in pounds   double emptyWeight Empty weight in pounds.   double fuelBurnRate Fuel burn rate in gallons/hour    Accessors and mutators for each field, except fuelBurnRate.\nYour class should override the toString() method and return a string with manufacturer and model number.\nYour class should have general methods as follows:    Visibility Return Method name Comment     public double usefulLoad() // returns the maximum takeoff weight minus the empty weight.   public double fuelWeight(double gallons) // returns the weight of gallons of fuel. Aviation fuel (100LL) weighs 6 lbs. per gallon.   public double fueledWeightMargin (double hours) // remaining weight margin    Write a main method that instantiates an airplane and tests the various methods.\nEmployee Class #     Variables Type     name String   salary double       Methods Return     raiseSalary(double) void    public class Employee { private String name; private double salary; public Employee (String n, double s) { name = n; salary = s; } public void raiseSalary(double p) { salary *= p + 1; } }  Sep 17, 2018 #  Making use of the graphics frame:\nGraphicsFrame.java and Drawable.java are available on canvas. Use these files but do not modify them.\nChicken class #     Variables Type     name String   weight double       Methods Return     crow() void   peck() void   draw() void    This will use the Chicken class, GraphicsFrame class, Drawable class, and a MakeChicken class (which will contain our main). These must all be in the same folder.\nUsing the GraphicsFrame\n Create the base class ( the class you want to draw ) Put the GraphicsFrame.java and Drawable.java into the same folder  drawString() prints to the graphics window. println() only prints to the console. implements keyword after a class refers to an interface class. This is basically a promise to put the method that the class is implementing in your code. This is referring to the draw() method. This is needed in the Chicken class. The chicken class with the draw() method cannot draw itself, but can be used to draw. Use setColor() and getColor() to change the color back to the default after its drawn so the default color isn\u0026rsquo;t changed for future draws.\n Sep 19, 2018 #  Everything inherits from Object.java. The class Object.java has a method called toString() which returns the address of where the object lives in memory. This method is called on default if you were to call an object on its own, i.e. System.out.println(a1); is the same as calling System.out.println(a1.toString);. To override toString() you could put in your own aircraft class public String toString() {return manufacturer + \u0026quot; \u0026quot; + model;} for example. The toString() method should return something descriptive about the object, in the case of our Aircraft class, it returns the manufacturer and model of the aircraft object.\nDonut class #     Variables Type     type String   shape char   x coordinate int   y coordinate int   color Color    import java.awt.Color; import java.awt.Graphics; public class Donut implements Drawable { private String type; private char shape; //C for circular, R for rectangle  private Color color; private int x,y; public Donut() { type = \u0026#34;Glazed\u0026#34;; shape = \u0026#39;C\u0026#39;; color = Color.YELLOW; x = y = 400; } public Donut(String t, char s, Color c, int px, int py) { type = t; shape = s; color = c; x = px; y = py; } public void draw(Graphics g) { //Draw code goes here  } }  Sep 24, 2018 #  Lab 2: BAC Calculation #     Fields Data type     name String   weight, in kg double   gender, M or F char   standard drinks (SD) double   drinking period (DP) double       Local constants Data type     body water (BW, 0.58 for male, 0.49 for female, constants) double   metabolism rate (MR, 0.015 for male, 0.017 for female, constants) double    public class EstimatedBloodAlcoholContent { private String name; private double weight; //kg  private char gender; //M or F  private double SD; //Standard drinks: 10 grams of ethanol per drink  private double DP; //Drinking hours  public EstimatedBloodAlcoholContent() { name = \u0026#34;Jane Doe\u0026#34;; weight = 70; gender = \u0026#39;F\u0026#39;; SD = 2.5; DP = 2; } //Full constructor goes here  //Accessors  public String getName() {return name;} public double ebac() { double BW = 0; double MR = 0; if (gender) { BW = 0.49; MR = 0.017; } else //gender == \u0026#39;M\u0026#39;  { BW = 0.58; MR = 0.015; } return (0.806 * SD * 1.2) / (BW * weight) - (MR * DP); }//end ebac  public String toString() { return name + \u0026#34;, \u0026#34; + gender; } public static void main (String[] args) { EstimatedBloodAlcoholContent pf); System.out.println(pf.getName() + \u0026#34;: \u0026#34; + pf.ebac()); } }//end class toString() should return something that is \u0026ldquo;representative of the object\u0026rdquo;, and should always be overriden.\n Oct 1, 2018 #   Ch. 4 Quiz [2018-10-08] Midterm is on 17th of Oct, covers Ch. 1 - 5.2 (only if and if..else from Ch. 5) [2018-10-17] Make midterm notes (Allowed one 8.5 x 11 sheet of paper) [2018-10-17]  Decision statements #  Control Statement review:\n Simple Sequence  Blocks are executed sequentially   Decision statements  if, if..else, switch   Iterate (repeat/loop)  if (and if..else):\nif (boolean_expression) { //Code block goes here } If the boolean_expression is true, then the code block gets executed, if false the block is skipped and the flow of the program continues normally.\nBoolean expressions are formed with relational operators:\n   Symbol Meaning Example Notes     == Is equal to a == 5 Works with fundamental data types, but be careful with floating point types   != Is not equal b != a    \u0026gt; Greater than 5 \u0026gt; 4 true   \u0026lt; Less than 10 \u0026lt; 15 false   \u0026gt;= Greater than or equal a \u0026gt;= value    \u0026lt;= Less than or equal a \u0026lt;= c + 5 Arithmetic is allowed    Example:\nif (value \u0026gt;= 21) { //Code } A simple program to check drinking age:\nif (age \u0026gt;= 21) { System.out.println(\u0026#34;Come on in and kill some brain cells\u0026#34;); } else { System.out.println(\u0026#34;Go home punk); } More complicated (waterfall type if):\nif (age \u0026lt; 21) { System.out.println(\u0026#34;No beer for you\u0026#34;); } else if (age \u0026lt;= 29) { System.out.println(\u0026#34;Come on in and spend your limited money killing braincells\u0026#34;); } else if (age \u0026lt;) { System.out.println(\u0026#34;Come in and spends lots and lots of money\u0026#34;); } else if (age \u0026lt;= 49) { System.out.println(\u0026#34;You\u0026#39;re a bit old but we want your money\u0026#34;); } else //over 49 { System.out.println(\u0026#34;Get back in your Impala and listen to your 8-track\u0026#34;); }  Oct 3, 2018 #  Side read: Physics for Game Programmers by Grant Palmer\nLift and drag calculation #  Lift and drag for a rectangle wing:\n $lift = \\frac{1}{2}ρv^2clA$\n$drag = \\frac{1}{2}ρv^2cdA$\n    Type Name Variable Description     final double rho ρ (rho) Density of air at STP (standard temp and pressure). Looking at sea level air density ($1.225 kg/m^3$)   double v velocity Velocity in meters per second (will need to be converted to knots)   double cl lift coeffecient Dimensionless   double cd drag coeffecient Dimensionless   double b wing span In meters   double c wing chord In meters    public class Wing { private final double rho = 1.225; //kg/m^3  private double v; //meters per second  private double cl; //dimensionless coeffecient of lift  private double cd; //dimensionless drag  private double b; //span in meters  private double c; //chord in meters  public Wing() { v) cl = 0.4; //coeffecient of lift  cd = 0.08;//drag  b = 9.25; //meters  c = 1.25; //chord  } public Wing(double pv, double pcl, double pcd, double pb, double pc) { v = pv; cl = pcl; cd = pcd; b = pb; c = pc; } //Accessors for all fields  //Mutators for b and c  public double lift() { return 1.0/2 * rho * v * v * cl * area(); } public double liftkg() { return lift() / 9.81; } public double area() { return b * c; } public static void main(String[] args) { Wing cruiseWing); System.out.println(\u0026#34;Area: \u0026#34; + cruiseWing.area() + \u0026#34; square meters\u0026#34;); System.out.println(\u0026#34;Lift: \u0026#34; + cruiseWing.lift() + \u0026#34; N\u0026#34;); System.out.println(\u0026#34;Lift: \u0026#34; + cruiseWing.lift() + \u0026#34; kg\u0026#34;); Wing stallWing); System.out.println(\u0026#34;Area: \u0026#34; + stallWing.area() + \u0026#34; square meters\u0026#34;); System.out.println(\u0026#34;Lift: \u0026#34; + stallWing.lift() + \u0026#34; N\u0026#34;); System.out.println(\u0026#34;Lift: \u0026#34; + stallWing.lift() + \u0026#34; kg\u0026#34;); } }//end Wing The lift() method must use a floating point number in the calculation of 1/2 otherwise with integer math it equals 0. By putting at least one decimal in the calculation (1.0/2) it forces Java to use floating point math. Also handling the $v^2$ is as easy as multiplying it by itself, however for higher powers Math.pow(v, 2) would be a better option. For example $v^5$: Math.pow(v, 5)\n Oct 8, 2018 #  Variables are declared inside a method, and fields are global to a class. Fields ultimately become a variable when an instance of an object is created.\nif..else worksheet #  public class ifElse1 { public static void main(String[] args) { int a = 100; int b = 50; System.out.println(\u0026#34;a); System.out.println(\u0026#34;a != b: \u0026#34; + (a != b)); System.out.println(\u0026#34;a \u0026gt; b: \u0026#34; + (a \u0026gt; b)); System.out.println(\u0026#34;a \u0026lt; b: \u0026#34; + (a \u0026lt; b)); System.out.println(\u0026#34;a \u0026gt;= b: \u0026#34; + (a \u0026gt;= b)); System.out.println(\u0026#34;a \u0026lt;= b: \u0026#34; + (a \u0026lt;= b)); } } Tip worksheet #  pseudo:\n get check amount get satisfaction level from customer based on satisfaction level  calculate tip   display amount, tip, satisfaction level  import javax.swing.JOptionPane; public class ifElse2 { public static void main(String[] args) { double amount; double tip = 0; int satisfactionLevel; String sasLevel; amount); satisfactionLevel); if (satisfactionLevel) { tip = amount * 0.20; sasLevel = \u0026#34;Very satisfied\u0026#34;; } else if (satisfactionLevel) { tip = amount * 0.15; sasLevel = \u0026#34;Satisfied\u0026#34;; } else if (satisfactionLevel) { tip = amount * 0.10; sasLevel = \u0026#34;Somewhat satisfied\u0026#34;; } else { tip = 0; sasLevel = \u0026#34;Not satisfied\u0026#34;; } System.out.println(\u0026#34;Check amount: \u0026#34; + check); System.out.println(\u0026#34;Tip: \u0026#34; + tip); System.out.println(sasLevel); } } JOptionPane doesn\u0026rsquo;t need to be instantiated as an object, because all the methods are static inside the class.\nswitch statement #  switch(exp) { case 1: //Code for case 1  break; case 2: //Code for case 2  break; case 3: //Code for case 3  break; default: //Default case code (runs if no other case is met)  break; } exp must be a integer or a String expression. switch statements only work for exact matches, not greater or less expressions. The code in each case must end with a break otherwise the other cases will execute also. The code in each statement can have curly braces around it but it doesn\u0026rsquo;t need them.\nswitch (satisfactionLevel) { case 2: tip = amount * 0.15; sasLevel = \u0026#34;Satisfied\u0026#34;; break; case 1: tip = amount * 0.20; sasLevel = \u0026#34;Very satisfied\u0026#34;; break; case 3: tip = amount * 0.10; sasLevel = \u0026#34;Somewhat satisfied\u0026#34;; break; default: tip = 0; sasLevel = \u0026#34;You suck!\u0026#34;; break; }  Oct 10, 2018 #  More if..else: #  pseudo\n get float from user check  is zero is pos is neg   print corresponding messages also check  if number is less than 1 if number is more then 1000000    import java.util.Scanner; public class ifelse0 { public static void main(String[] args) { Scanner kb); double input; System.out.print(\u0026#34;Enter a number: \u0026#34;); input); if (input \u0026gt; 0) { System.out.println(\u0026#34;The number is positive\u0026#34;); } else if (input) { System.out.printlnt(\u0026#34;The number is zero\u0026#34;); } else //input \u0026lt; 0  { System.out.printlnt(\u0026#34;The number is negative\u0026#34;); } if (Math.abs(input) \u0026lt; 1) { System.out.println(\u0026#34;The number is small\u0026#34;); } else if (input \u0026gt; 1000000) { System.out.println(\u0026#34;The number is large\u0026#34;); } } } Escape velocity #  The average person can jump off the ground with a velocity of 3.13 m/s (about 7mph) without fear of leaving the planet. However, if an astronomer jumps with this velocity while standing on Halley\u0026rsquo;s Comet, will the astronaut ever come back down? Create a Java test program that allows the user to input a launch velocity (m/s) from the surface of a small body and determine whether the jumper will return to the surface.\n $v_{escape} = \\sqrt{ 2 \\frac{GM}{R} }$\n$G)\n$M)\n$R)\n public class Escape { public static void main(String[] args) { final double G = 6.67E-11; double M = 2.2E14; //mass in kg  double R = 5500; //radius in m  double vEscape; vEscape); System.out.printlnt(\u0026#34;Escape Velocity: \u0026#34; + vEscape); if (vEscape \u0026lt; 3.13) { System.out.printlnt(\u0026#34;You are leaving Halley\u0026#39;s comet\u0026#34;); } else { System.out.printlnt(\u0026#34;You are staying on Halley\u0026#39;s comet\u0026#34;); } } } Scientific notation can be entered in using the E for exponent. (6.67E-11 is the same as writing $6.67 * 10^{-11}$)\nLab 3: Robot #  See Labs/L3Robot/RobotClass.pdf\n Oct 15, 2018 #  String class #  Strings are objects, that hold values about the string. Some of the fields include the length of the string. Strings also have methods because they are objects. length() returns the length of the string. Strings are immutable, if a method returns a string it is technically a new string.\nimport javax.swing.JOptionPane; public class StringTest { public static void main(String[] args) { String s1 = \u0026#34;Hello, world!\u0026#34;; String s2; int i = 4; s2); System.out.println(s1); System.out.println(s1.length()); //prints length  System.out.println(s1.toUpperCase()); //prints string in upper case  System.out.println(s1.charAt(i)); //prints the char at the speicified index (declared above)  System.out.println(s1.charAt(s1.length() - 1)); //prints the last char  System.out.println(s1.endsWith(\u0026#34;world!\u0026#34;)); //prints boolean if the suffix is found  System.out.println(s2); System.out.println(s1.equals(s2)); System.out.println(s1.equalsIgnoreCase(s2)); } } When calling the toUpperCase() method, the string is changed to a different string, but the original s1 is unaffected. charAt(int i) is a method that returns the char at the specified index (starting at 0). Strings are immutable (not mutatable). endsWith(String suffix) returns a boolean if the suffix is at the end of the string checked. equals() returns a boolean if the strings are equal, equalsIgnoreCase() returns a boolean without looking at the case sensitivity.\nString s1 = \u0026#34;Hello\u0026#34;; String s2 = \u0026#34;Hello\u0026#34;; System.out.println(s1); This prints true, because the way Java allocates memory, technically speaking, since the 2 strings are of identical contents, Java points s1 and s2 at the same object in memory. If the object is then changed later it creates another object to store the changed string.\n Oct 22, 2018 #  while loops #   Review:\nThree control structores\n Sequence Branching Iteration (loops)   while loops are used to make iteration that is event-based, meaning it usually means the loop must run an unknown amount of times. (Contrasted with the for loop, where you know the amount of times the loop must run)\nwhile(boolean_expression) { /* Code to be executed while boolean_expression is true When the body of the loop is finished, the boolean_expression is checked again If boolean_expression is false the body is skipped */ } (You can break out of the loop at any point, however this is considered to be poor programming.)\npublic class WhileThing { public static void main(String[] args) { int count = 1; while(count \u0026lt;= 10) { System.out.print(count + \u0026#34; \u0026#34;); count++; } } } Prints:\n 1 2 3 4 5 6 7 8 9 10\n More examples:\npublic class StringSlicer { public static void main(String[] args) { int i = 0; String myString = \u0026#34;Stuff in the String.\u0026#34;; while (i \u0026lt; myString.length()) { System.out.println(myString.charAt(i)); i++; } } } StringSlicer prints a string vertically\npublic class OnesAndZeros { public static void main(String[] args) { int i = 0; int onesCount = 0; int zerosCount = 0; int otherCount = 0; String myString = \u0026#34;1110101xx00\u0026#34;; while (i \u0026lt; myString.length()) { switch (myString.charAt(i)) { case \u0026#39;1\u0026#39;: onesCount++; break; case \u0026#39;0\u0026#39;: zerosCount++; break; default: otherCount++; break; } i++; } System.out.println(\u0026#34;onesCount); System.out.println(\u0026#34;zerosCount); System.out.println(\u0026#34;otherCount); } } Prints:\n onesCount = 5\nzerosCount = 4\notherCount = 2\n OnesAndZeros counts the amount of 1s and 0s in a string. It also counts any other char under the otherCount variable.\n Oct 24, 2018 #  for loop #  for (initialize counter; boolean_expression; increment counter) { //code to be executed in loop } All looping can be done with a while loop, however, the for loop makes it conveinent to see all the pieces of the loop. for loops are used for counted loops, not necessarily event-based loops. The initialization of the counter doesn\u0026rsquo;t need to be inside the parameters of the for loop, however you want to try to limit the scope of variables as much as possible, so unless you need that variable after the loop, keep the initialization inside the parameters.\nExample:\npublic class Loopy { public static void main(String[] args) { for (int i) { System.out.print(i + \u0026#34; \u0026#34;); } } } Prints:\n 1 2 3 4 5 6 7 8 9 10\n The initialization of the counter only happens as you enter the loop for the first pass. The boolean_expression happens everytime you get to the top of the loop. The increment happens at the bottom of the loop. In this example, the scope of i is only inside the loop.\nMore examples:\npublic class ValidEmail { public static void main(String[] args) { String email = \u0026#34;myEmail@somePlace.com\u0026#34;; int atCount = 0; //for this excercise valid emails have only one @ symbol  int dotCount = 0; //and only one . symbol  for (int i) { if (email.charAt(i)) { atCount++; } if (email.charAt(i)) { dotCount++; } } if (atCount) { System.out.println(\u0026#34;This is a valid email\u0026#34;); } else { System.out.println(\u0026#34;This is not a valid email\u0026#34;); System.out.println(email); } } } public class FirstAt { public static void main(String[] args) { String email = \u0026#34;myEmail@somePlace.com\u0026#34;; int i = 0; while (i \u0026lt; email.length() \u0026amp;\u0026amp; email.charAt(i) != \u0026#39;@\u0026#39;) { i++; } if (i \u0026lt; email.length()) { System.out.println(\u0026#34;@ symbol is at index: \u0026#34; + i); } else { System.out.println(\u0026#34;No @ symbol\u0026#34;); } } } Order the boolean_expression properly, so you must put the increment before the check of the array because otherwise it will check an out of bounds index before checking the increment.\n Oct 29, 2018 #  Arrays #  An array is nothing more then a list. Arrays are homogenous, meaning all the elements of an array is of the same data type. Indecies in arrays start at 0.\nint[] grades = new int[8]; //must specify the size of the array  grades[0] = 92; //to set an individual element grades[1] = 85; grades is the name of the integer array list with 8 cells. This also loads each cell with 0s. The size of the array must be a positive integer. 92 will be at the first cell (index 0) of the array. grades[0] reads as \u0026ldquo;grades sub zero\u0026rdquo;.\nfor (int i) { System.out.println(grades[i]); } length doesn\u0026rsquo;t need parenthesis after it because it is a value in the array object, not a method.\nint total = 0; for (int i) { total = total + grades[i]; } int average = total / grades.length; total is being used as an accumlator for the sum of the array\u0026rsquo;s elements. You can then divide total by grades.length to get the average.\npublic class ArrayTest { public static void main(String[] args) { int[] myArray = new int[8]; for (int i) { System.out.println(\u0026#34;Index: \u0026#34; + i + \u0026#34; is \u0026#34; + myArray[i]); } } } An array can be automatically initialized using this syntax:\nint[] myArray = {92, 85, 64, 23, 32, 28, 34, 85}; Java will automatically make the array size based on how many elements are in the first list.\nTo fill an array with random data:\nimport java.util.Random; public class RandomArray { public static void main(String[] args) { Random rangen); int[] randomArray = new int[100]; for (int i) { randomArray[i]); } } } nextInt() will return a random integer inside the limits of an integer. The parameter inside nextInt is the upper limit exclusive of the number you want to generate. nextInt(100) would make random numbers between 0 and 99.\n Oct 31, 2018 #  Sorting and searching arrays #  Bubble swap compares 2 elements and swaps them if the first element is bigger. The loop continues until each element has been swapped.\nArray declaration review:\nString[] myArray = new String[5]; //makes an array of strings with 5 cells  myArray[0]) Code to write a bubble sort:\npublic class BubbleSort { public static void printArray(int[] a) { for (int i) { System.out.print(a[i] + \u0026#34;, \u0026#34;); } System.out.println(\u0026#34;-----\u0026#34;); } public static void main(String[] args) { int[] n = {94, 28, 67, 125, 8}; for (int outer) { for (int i) { if (n[i] \u0026gt; n[i + 1]) { int temp = n[i]; n[i] = n[i + 1]; n[i + 1] = temp; } } } printArray(n); } } import java.util.Random; public class AnotherSort { public static void main(String[] args) { Random rangen); int[] n = new int[1000]; for (int i) { n[i]); } } } A better way to sort is to use java.util.Arrays, in this class there is a sort() method that is the fastest sort available to us. Using a bubble sort is slow, but it works. Sorting an array of 1 million cells with a bubble sort takes around 30 min, whereas sort() in the arrays class can do 100 million in a second or so, maxing out the heap at 1 billion.\n Nov 14, 2018 #  Stacks #  Infix expression: $20 + 4 * 2$\nPostfix expression (RPN): 20 4 2 * +\nThe computer doesn\u0026rsquo;t know the order of operations, so while the computer is chugging along reading things it doesn\u0026rsquo;t know what to do first. By putting the operands at the end, the computer can correctly do the evaluation.\nPost fix rules:\n If the token is a number  push to the stack   If the token is an operator  Pop the stack twice Then apply the operator. Drop on top    Infix: (3 + 2) * 4\nRPN: 3 2 + 4 *\nPseudo:\npush(int e)\n If stack is not full  increment stack pointer stack[sp] = e    int pop()\n temp = stk[sp] decrement stack return temp  boolean isEmpty()\n return sp == -1  boolean isFull()\n return stack.length - 1 == sp   Nov 26, 2018 #  ANYCUBIC Photon\nThe New New Thing (Book about netscape)\nJava Swing (GUI) #  GUI\u0026rsquo;s are built from 2 different ideas, the view (GUI) and the model (code). A third piece called the controller ties these 2 pieces together. This entire idea is called a software pattern. (Model-view-controller paradigm, MVC).\nimport javax.swing.*; import java.awt.*; //abstract window toolkit import java.awt.event.*; //action listener  public class FirstWindow extends JFrame implements ActionListener { private JLabel myLabel; private JButton myButton; public FirstWindow() { setLayout(new FlowLayout()); //sets layout  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //  setSize(400, 200); //width and heigth in pixels  //Controls  myLabel); add(myLabel); myButton); add(myButton); myButton.addActionListener(this); //tells constructor that action listener is in this code  setVisible(true); //boolean that renders window  } public void actionPerformed(ActionEvent ae) { myLabel.setText(\u0026#34;You pressed the button\u0026#34;); } public static void main(String[] args) { FirstWindow fw); } } Inheret from JFrame. extends keyword inherts from the class after. setLayout() determines what layout manager you want to use to make the window. The next thing needed is the close operation, in this case we want to exit on close so there isn\u0026rsquo;t memory leak. JLabel makes text in the window.\n Nov 28, 2018 #  Feet to meters GUI #  Model:\npublic class Conversions { private final double FEET_TO_METERS_CONVERSION = 0.3048; private double n; //number  public Conversions(double valueToConvert) { n = valueToConvert; } public double feetToMeters() { return n * FEET_TO_METERS_CONVERSION; } public static void main(String[] args) { Conversions c); System.out.println(c.feetToMeters()); } } View:\nimport javax.swing.*; import java.awt.*; import java.awt.event.*; public class FeetToMetersView extends JFrame implements ActionListener { private JTextField tfFeet; private JLabel lblMeters; private JButton bConvert; public FeetToMetersView() { //Setup  setLayout(new GridLayout(3, 2, 5, 5)); //rows, columns, 5 pixels padding inbetween boxes  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setSize(250,125); //Controls  add(new JLabel(\u0026#34;Feet:\u0026#34;, JLabel.RIGHT)); tfFeet); add(tfFeet); add(new JLabel(\u0026#34;Meters:\u0026#34;, JLabel.RIGHT)); lblMeters); lblMeters.setBorder(BorderFactory.createLineBorder(Color.BLACK)); add(lblMeters); bConvert); add(bConvert); bConvert.addActionListener(this); setVisible(true); } public void actionPerformed(ActionEvent ae) { double feet); Conversions conv); double meters); lblMeters.setText(Double.toString(meters)); } public static void main(String[] args) { FeetToMetersView ftmv); } }  Dec 3, 2018 #  Review #  Declaring an array field:\nprivate double[] nums; nums = new double[20]; Most missed questions on exam:\n 41/2 (ints)  = 20   the last character index position in a String variable naemd address is address.length()  false    "}),a.add({id:32,href:'/notes/CS13/CS13-lecture-notes/',title:"CS13-lecture-notes",section:"CS13",content:"CS 13 Lecture Notes #  Jan 28, 2019 #   Download BlueJ [2019-01-29]  Weather class #  public class Weather { private double highTemp; private double lowTemp; private String condition; private int rainChain; public Weather (double h, double l, String c, int r) { highTemp = h; lowTemp = l; condition = c; rainChain = r; } public double delta() { return highTemp - lowTemp; } public String toString() { return \u0026#34;High: \u0026#34; + highTemp + \u0026#34;, Low: \u0026#34; + lowTemp + \u0026#34;, Condition: \u0026#34; + condition + \u0026#34;, Chance of rain: \u0026#34; + rainChance; } } Using this class we can make another to populate a forecast\npublic class Forecast { private Weather days[]; private int nextDay; public Forecast() { days = new Weather[4]; nextDay = 0; } public void addDay(double h, double l, String c, int r) { Weather w); days[nextDay] = w; nextDay++; } public void display() { for (int i) { System.out.println(days[i]); } } }  Jan 30, 2019 #  Constructors #  Purpose of the constructor: Initialize variables, and do any other work necessary to get the object usable. The new keyboard actually makes the object, not the constructor.\nWeather w); The new keyboard happens first, which allocates memory for the object. Then the constructor is called and the object is filled with the parameters. Then finally the address set aside by new is set to the w variable.\nWeather x = w; x will contain the same address that w contains.\nForecast f = new Forecast(); f points at the address of a new Forecast object, which has another pointer to an array filled with nulls.\nf.addDay(60, 40, \u0026#34;Cloudy\u0026#34;, 10); This creates a weather object that then gets filled with the parameters from the constructor. The address that is inside the w object is then copied to the first slot in the array. The w object then dies when it leaves the scope of the method.\nAbout this class #  First half:\n Builds upon CS12 (variables, loops, conditionals, objects, classes) Starts to look at more complicated data structures  Second half:\n Larger projects Team work, collaboration Version control Communication tools  Arrays #  int[] a = new int[10]; is valid\nint b[10]; is not valid in Java\na[5] = 6; is valid because they are both array.\na[6] = \u0026quot;Hello\u0026quot;; is not valid because it is a type mismatch.\na[a[5]] = 8; is valid, a[5] evaluates to an integer, so it puts 8 into a[6]. Whatever is inside the square brackets must evaluate to an integer.\nLimitations:\n Can\u0026rsquo;t change the size of an array once declared. Can\u0026rsquo;t access out of bounds Can\u0026rsquo;t delete an element Can\u0026rsquo;t search for an element Can\u0026rsquo;t sort them   Feb 4, 2019 #  Why do classes/objects exist?\n A class lets us group related data together Attach code (methods) to the data Structurally encapsulate things to organize larger projects  The purpose of a class is to package data together and provide methods to manipulate the data.\nFor example in a class called Player for the super mario bros game: Data\n size color speed x y isSolid score lives  Actions (methods)\n run jump fall duck die slideDown goToNextLevel shoot spawn pause  Expanding arrays #  String[] arr)];\npublic class ElastArray { private String arr[]; int size; public ElastArray() { arr = new String[5]; size = 0; } public void add(String s) { if (size) //array full  { String[] arr2)]; //create expanded array  for (int i) //copy old values  { arr2[i] = arr[i]; } arr = arr2; //point old array to new  arr[size] = s; //add string  size++; } else { arr[size] = s; //add string  size++; } } }  Feb 6, 2019 #  More methods for our MetaArray class #  /** * Clear out entire array */ public void clear() { } /** * Delete an element from the array, reducing its size */ public void remove(int index) { } /** * Replace the element at index with new string */ public void set(int index, String s) { } /** * Return the element at a given index */ public String get(int index) { } /** * Insert a new element into array */ public void insert(int index, String s) { } /** * Return how many items in the array */ public int size() { } /** * Search the array for the target. Return the index * of the first occurrence. */ public int indexOf(String target) { } /** * Returns true if the array contains the string */ public boolean contains(String target) { } Insert method\n Should insert object into the index, and shift everything else down. How to:  Must start at the right and shift things down while greater then the index.    Exception: A catastrophic error occurred. Causes program to terminate. Goes \u0026ldquo;around' the normal return channel. When exceptions are generated, they are thrown. The caller will catch it.\n Feb 11, 2019 #  Generic data types #  To specify a data type that can be a variable, you can use angle brackets after the class name.\npublic class Box\u0026lt;T\u0026gt; { T x; public Box() { x = null; } public Box(T o) { x = o; } public void set(T value) {x = value;} public T get() {return x;} } The \u0026lt;T\u0026gt; after the class name makes the actual data type that a Box object is made of a variable. That way you can make a Box that holds any data type, but only that data type.\nWhen creating the object, you must specify the data type in angle brackets:\nBox\u0026lt;String\u0026gt; b);  Feb 13, 2019 #  \u0026ldquo;Evens\u0026rdquo; game #  public class Evens { private int pile, p1, p2; private String p1name, p2name; private int turn; public Evens(String p1n, String p2n) { p1name = p1n; p2name = p2n; pile = 15; p1 = p2 = 0; turn = 0; } public void take(int a) { if (a \u0026gt; pile || a \u0026gt; 3 || a \u0026lt; 0 || isGameOver()) { throw new IllegalMoveException(); } if (turn % 2) //player 1s turn  { p1 = p1 + a; } else { p2 = p2 + a; } pile = pile - a; turn++; } public boolean isGameOver() { return (pile); } public String whoWon() { if (p1 % 2) { return p1name; } else { return p2name; } } public String toString() { return \u0026#34;Pile: \u0026#34; + pile + \u0026#34;, \u0026#34;+ p1name + \u0026#34;:\u0026#34; + p1 + \u0026#34;, \u0026#34; + p2name + \u0026#34;:\u0026#34; + p2; } } The point of the game is to have an even number of chips left. This can be tested using a test code file and JUnit\nimport static org.junit.Assert.*; import org.junit.After; import org.junit.Before; import org.junit.Test; /** * Test class EvensTest. */ public class EvensTest { @Test public void testGame() { Evens e); assertEquals(\u0026#34;Pile: 15, A:0, B:0\u0026#34;, e.toString()); e.take(3); assertEquals(\u0026#34;Pile: 12, A:3, B:0\u0026#34;, e.toString()); e.take(2); assertEquals(\u0026#34;Pile: 10, A:3, B:2\u0026#34;, e.toString()); e.take(1); assertEquals(\u0026#34;Pile: 9, A:4, B:2\u0026#34;, e.toString()); assertEquals(false, e.isGameOver()); e.take(3); e.take(3); e.take(3); assertEquals(true, e.isGameOver()); assertEquals(\u0026#34;B\u0026#34;, e.whoWon()); } @Test (expected) public void testEvil() { Evens e); e.take(4); } @Test (expected) public void testEvil2() { Evens e); e.take(-1); } @Test (expected) public void testEvil3() { Evens e); e.take(3); e.take(3); e.take(3); e.take(3); e.take(3); e.take(3); } } The @Test annotation right before the method header is called an annotation. This is how you \u0026ldquo;tag\u0026rdquo; methods to be tested. (expected) to make sure its playing properly.\nModel-View-Controller\n Model is the math underlying the program View is how it appears on the screen Controller is how you interact with the two  Test-Driven-Development\n Writing code to pass the tests and writing tests to break the code.  Refactoring\n Making changes to the code without changing its behavior.   Feb 20, 2019 #  Linked lists #  Analogy: A train. Each car can only hold one thing and each car is hooked up to the one following it. Each train car is called a node.\npublic class Node { Object item; Node next; } This is a self-referential class. Each node will hold both the item you want it to contain and the address of the next node. Also note that everything in this class is public.\nNode a); a.item = \u0026#34;Alpha\u0026#34;; Node b); b.item = \u0026#34;Beta\u0026#34;; //Hook together a.next = b; Node c); c.item = \u0026#34;Gamma\u0026#34;; b.next = c; a.next.next.item //shows item in c Attaching things to the end of the \u0026lsquo;train\u0026rsquo; gets longer and longer. If you hook things to the front of the linked list it will be faster.\nNode n); n.item = \u0026#34;Alpha\u0026#34;; Node m); m.item \u0026#34;Beta\u0026#34;; m.next = n; Node t); t.item = \u0026#34;Gamma\u0026#34;; t.next = m; You can reuse the variables. This means you\u0026rsquo;re essentially adding a car to the front of the train and calling that the new first car.\nNode n); n.item = \u0026#34;Alpha\u0026#34;; Node p); p.item = \u0026#34;Beta\u0026#34;; p.next = n; n = p; In a new class:\npublic class LList { Node first; public LList() { first = null; } public void addFirst(Object o) { Node p); //new node with object  p.item = o; p.next = first; //make new node point at first  first = p; //make p new first  } public int size() { if (first) { return 0; } Node temp = first; //not creating a new object, just pointing  int count = 1; while (temp.next != null) { count++; temp = temp.next; } return count; } }  Feb 25, 2019 #  LList continued #  Get To get contents of a Node, you must use a loop and \u0026ldquo;hop\u0026rdquo; along each car until you get to where you want to be.\nThe \u0026ldquo;locomotive\u0026rdquo; in the train can keep track of both first and last which can make adding things to the end of the train a lot faster as it becomes bigger.\npublic void addLast(object o) { Node n); n.item = o; last.next = n; n.next = null; last = n; }  Feb 27, 2019 #  Speed of our MetaArray and LList #  Adding to LList is called an O(1) operation. Means order of 1 operation to add something onto the LList.\nAdding to the MetaArray is grows by an percentage, however, if you average the times of this operation out it is still an O(1) operation. Adding to the MetaArray using a constant amount ( not a percentage ) then adding a successive element to the array becomes longer and longer, this is called an O(n) operation.\n   Type addFirst addLast insert (middle) remove (end) size toString clear indexOf get     ArrayList O(1) amortized O(1) O(n) O(1) O(1) O(n) O(1) O(n) O(1)   LinkedList O(1) O(1) O(n) O(1) O(n) O(n) o(1) O(n) O(n)     Mar 4, 2019 #  Stacks #  A data structure (like a stack of paper)\n   Method Description     push(o) adds item o to stack   pop() returns the item on top of the stack, then removes it   peek() shows item on top of stack   clear() clears stack   isEmpty() returns true if stack is empty    import java.util.LinkedList; public class Stack\u0026lt;X\u0026gt; { private LinkedList\u0026lt;X\u0026gt; s; public Stack() { s); } public void push(X o) { s.addLast(o); } public X pop() { X temp); s.remove(s.size() - 1); return temp; } public void clear() { s.clear(); } public X peek() { return s.get(s.size() - 1); } public boolean isEmpty() { return s.size() == 0; } } When using extends\n This sets up a is-a relationship, for example, Stack is-a LinkedList This makes Stack have all the methods that LinkedList has  When encapsulating inside the class\n This sets up a has-a relationship Stack has-a LinkedList inside of it   Sidenote: When you can\u0026rsquo;t think of a placeholder name, use: foo, bar, baz, qux, quux \u0026hellip;\n  Mar 6, 2019 #  Dog class #  public class Corgi { private String name; private int age; public Corgi(String n, int a) { name = n; age = a; } public String sleep() { return \u0026#34;Zzzzzz\u0026#34;; } public String eat() { return \u0026#34;Chomp chomp!\u0026#34;; } public String bark() { return \u0026#34;Woof!\u0026#34;; } public String toString() { return name + \u0026#34; \u0026#34; + age; } public void birthday() { age++; } }  2 more classes (Shiba and Dachshund)\n import java.util.ArrayList; public class Kennel { ArrayList\u0026lt;Corgi\u0026gt; corgis; ArrayList\u0026lt;Shiba\u0026gt; shibas; ArrayList\u0026lt;Dachshund\u0026gt; dachshund; public Kennel() { corgis); shibas); dachshunds); } public void addCorgi(Corgi c) { corgis.add(c); } public void addShiba(Shiba s) { shibas.add(s); } public void addDachshund(Dachshund d) { dachshunds.add(d); } } Scaling this up becomes problematic because everytime you want to add another breed of dog you need to add methods and arraylists for it. To generalize this, we will make a Dog interface.\npublic interface Dog { public String eat(); public String bark(); public String sleep(); public String toString(); public void birthday(); } Interfaces list all the methods that you want all Dogs to do.\nNow in Corgi class add the word implements after the class\npublic class Corgi implements Dog { } You can then make new dogs like this: Dog d); This makes the only the methods available to Dog available in variable d, it can be cast as a Corgi to gain access all the methods that Dog doesn\u0026rsquo;t have but Corgi does.\n Mar 11, 2019 #   Midterm is wednesday (4/20) [2019-05-06]  LList unit tests #  Concerning Rigorous test 2: Problem is usually with remove() method, make 4 cases:\n List with 1 item Remove last item Remove first item Remove from middle  Postfix notation #  Infix notation puts the operations in between the numbers. Postfix puts the operator after the operands (numbers).\nIf its a number: Push onto stack If its a operator Pop 2 and perform the operation then push\n 20 3 4 + + = 27\n6 8 2 + - = -4\n 4 + 2 * 3 - 8 / 6 + 7 + 9\n4 + 2 3 * - 8 / 6 + 7 + 9\n4 + 2 3 * - 8 6 / + 7 + 9\n4 2 3 * + - 8 6 / + 7 + 9\n4 2 3 * + 8 6 / - + 7 + 9\n4 2 3 * + 8 6 / - 7 + + 9\n4 2 3 * + 8 6 / - 7 + 9 +\n Mar 13, 2019 #  Postfix stack #  When splitting a string into pieces (using split), the split pieces are called \u0026ldquo;tokens\u0026rdquo;.\nimport java.util.Stack; public class Postfix { String expr; Stack\u0026lt;Double\u0026gt; stack; public Postfix(String e) { expr = e; stack); } public double eval() { String[] tokens); for (String token : tokens) { if (token.equals(\u0026#34;+\u0026#34;)) { double a); double b); stack.push(a + b); } else if (token.equals(\u0026#34;-\u0026#34;)) { double a); double b); stack.push(b - a); } else // Must be a number  { try { double n); stack.push(n); } catch (java.lang.NumberFormatException n) { throw new UnknownToken(); } } } return stack.peek(); } } New java shortcut, the for each loop:\nfor (String token : tokens) { } tokens is the array you are walking thru, and token is a variable that refers to each element of the array. This is a for each loop. (This is like for i in list: in python)\n Apr 18, 2019 #  JavaFX #  Terminology\n Stage  A window   Scene  A container to put things in Can have more then one scene per window    import javafx.application.Application; import javafx.stage.Stage; import javafx.scene.layout.Pane; import javafx.scene.Scene; import javafx.scene.shape.Circle; public class First extends Application { public void start(Stage window) { window.show(); window.setTitle(\u0026#34;First!\u0026#34;); window.setSize(600, 400); Pane canvas); window.setScene(new Scene(canvas, 600, 400)); Circle c); canvas.getChildren().add(c); } }  Smoot calc #  public class Distance { double feet; public Distance(double f) { feet = f; } /** 1 smooth equals 5 foot 7 inches */ public double toSmoots() { return feet / (5 + 7.0/12.0); } } import javafx.application.Application; import javafx.stage.Stage; import javafx.scene.Scene; import javafx.scene.layout.Pane; import javafx.scene.control.Label; import javafx.scene.control.TextField; import javafx.scene.control.Button; import javafx.event.ActionEvent; public class UI extends Application { TextField feetField; TextField smootField; public void start(Stage window) { window.show(); window.setTitle(\u0026#34;Smoot Calc\u0026#34;); Pane canvas); Scene myScene); window.setScene(myScene); Label feetLabel); Label smootLabel); canvas.getChildren().add(feetLabel); canvas.getChildren().add(smootLabel); feetLabel.relocate(20, 50); smootLabel.relocate(20, 100); feetField); smootField); canvas.getChildren().add(feetField); canvas.getChildren().add(smootField); feetField.relocate(80, 48); smootField.relocate(80, 98); Button goButton); Button clearButton); canvas.getChildren().add(goButton); canvas.getChildren().add(clearButton); goButton.relocate(80, 150); clearButton.relocate(150, 150); goButton.setOnAction(this::handleGoButton); clearButton.setOnAction(this::handleClearButton); } public void handleGoButton(ActionEvent ae) { //Get feet from feetField  String feet); //Create distance object  double dfeet); Distance d); //Convert  double smoots); //Output to smootField  smootField.setText(\u0026#34;\u0026#34; + smoots); } public void handleClearButton(ActionEvent ae) { feetField.setText(\u0026#34;\u0026#34;); smootField.setText(\u0026#34;\u0026#34;); } } The :: in the setOnAction() method refers to which class the method to call is in. (class::method)\n Mar 27, 2019 #  Git #  Terminology:\n Working directory  Where you edit, compile, run program   Repository  Where the backups are kept Local  On your local machine   Remote  On a server     Commit  Make a backup   Push  Upload local repo to remote repo   Pull  Download remote repo to local repo     Apr 22, 2019 #  JSON data from Java class #  URL consists of 4 parts\nhttps://www.sierracollege.edu/student-services/financial-aid.php ^ protocol ^ host ^ path newsapi.org\nTo call the newsapi:\nhttps://newsapi.org/v2/everything/?q=whattosearchfor\u0026apiKey=\npublic class News { public static void main(String[] args) { // Prompt  Scanner in); System.out.print(\u0026#34;Enter query: \u0026#34;); String keyword); // URL with keyword  String urlString = \u0026#34;https://newsapi.org/v2/everything?q=\u0026#34; + keyword + \u0026#34;\u0026amp;apiKey=\u0026#34;; //TODO add apiKey  try { // Make URL object  URL url); // Open stream readers for incoming data  InputStream is); InputStreamReader isr); BufferedReader br); //  JsonParser parser); JsonElement results); // Show title of article 0  String title) .getAsJsonArray().get(0) .getAsJsonObject().get(\u0026#34;title\u0026#34;) .getAsString(); System.out.println(title); // Print out all titles  JsonArray titles) .getAsJsonArray(); for (int i) { String title) .get(\u0026#34;title\u0026#34;).getAsString(); System.out.println(\u0026#34;\u0026#34; + i + \u0026#34; \u0026#34; + title); } } catch (MalformedURLException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } } } Make a new directory called libs inside idea project. Put gson-2.8.5.jar inside, then choose \u0026ldquo;Add As Library\u0026rdquo; from right click menu\n Apr 24, 2019 #  Sanitizing data #  Clean up data before submitting\n May 15, 2019 #  "}),a.add({id:33,href:'/notes/CS130/CS130-exercise-solutions-1/',title:"CS130-exercise-solutions-1",section:"CS130",content:"For example if   \\( n = 6 \\)  :\n \\[\\begin{aligned} t(n) \u0026amp;= t(n) \\cdot t(n-1) \\cdot t(n-2) \\cdot t(n-3) \\cdot t(n-4) \\cdot t(n-5) \\\\ \u0026amp;= \\underbrace{6 \\cdot 5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1}_{\\text{this happens } n \\text{ times}} \\end{aligned}\\]  So we have a time complexity of  \\( O(n) \\)  .\n   "}),a.add({id:34,href:'/notes/CS130/CS130-lecture-20200831/',title:"CS130-lecture-20200831",section:"CS130",content:"Syllabus #  The required text is available for free in the school library\nBoth sections will take the exam together\nModule 1 #  Test cases will usually be provided.\n"}),a.add({id:35,href:'/notes/CS130/CS130-lecture-20200902/',title:"CS130-lecture-20200902",section:"CS130",content:"Concerning the survey from last class #  The differences between an array and a linked list:\n Access: arrays can access an spot instantly, linked lists need to iterate from the head until they reach the target. Size: arrays are fixed in size, linked lists can become bigger or smaller  Stacks can be implemented using a linked list or an array. FILO\nQueues can be implemented using a linked list or a circular array. FIFO\nRecursion #  Recursive functions must have a base case, otherwise you will get an infinite loop!\n f1 has no base case f2 doesn\u0026rsquo;t reduce the problem to the base case (no n - 1) f3 needs to check the base case first f4 recursive call is infinite when n \u0026gt; 0  Algorithm analysis #  "}),a.add({id:36,href:'/notes/CS130/CS130-lecture-20200909/',title:"CS130-lecture-20200909",section:"CS130",content:"Runtime analysis cont. #  Big Oh notation is pretty much the only asymptotic notation used.\nInitializing arrays of ints in Java initializes everything to 0, so it is a linear process. The if statement has an else with a loop, so at a worse case it is O(n).\nOn line 73, you have to count the other functions runtime analysis also.\n"}),a.add({id:37,href:'/notes/CS130/CS130-lecture-20200914/',title:"CS130-lecture-20200914",section:"CS130",content:"Annoucements #  New webcam usage survey\nExercise solutions:\n Runtime analysis cont. #  Space complexity analysis #  1MB) kB\nStrings have the fields: start address, length, offset, hash\nFor example:\nstr = \u0026quot;Java\u0026quot;; str1); The space is constant because the sub string isn\u0026rsquo;t copied, just more references are made.\n c + 4n, so O(n)  32 + 64n)  Normally you don\u0026rsquo;t count the space of the parameters or the return.\nTime complexity is O(n) Space complexity is O(1)\n"}),a.add({id:38,href:'/notes/CS130/CS130-lecture-20200916/',title:"CS130-lecture-20200916",section:"CS130",content:"Exercise solutions #  For example if   \\( n = 6 \\)  :\n \\[\\begin{aligned} t(n) \u0026amp;= t(n) \\cdot t(n-1) \\cdot t(n-2) \\cdot t(n-3) \\cdot t(n-4) \\cdot t(n-5) \\\\ \u0026amp;= \\underbrace{6 \\cdot 5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1}_{\\text{this happens} \\,n\\, \\text{times}} \\end{aligned}\\]  So we have a time complexity of  \\( O(n) \\)  Space complexity cont. #  Time complexity of this is  \\( O(n) \\)  . Space complexity is  \\( O(1) \\)  .\nSorting #  Requires 2 smaller arrays already sorted.\nCompares the two elements under the cursors, sorted into a new array in non-decreasing order. Copy the smallest one to the destinatino array, and move the cursor forward on respective array.\nWhen one cursor goes past the end of an array you just copy the other cursor over.\ni is the cursor for the left array, j is the cursor for the right array. The first array is the first half of a and the second is the second half of a.\nLets assume hi - lo + 1.\nWe split each array until each array only has 1 element. The reason for this is because an array with 1 element is sorted!\nLets analyze the space complexity. The recursive method is  \\( O(log(n)) \\)  . The first sort method is  \\( n \u0026#43; log(n) \\)  so it is  \\( O(n) \\)  .\nLets analyze runtime complexity.\n "}),a.add({id:39,href:'/notes/CS130/CS130-lecture-20200921/',title:"CS130-lecture-20200921",section:"CS130",content:"Annoucements #  First assignment open\nMergesort cont. #  Solution to last exercise:\n The first sort method:\n space complexity is O(n) running time is  The second method\n space complexity is O(1) running time is O(nlog(n))  An example of a stable sorting algorithm:\nUnsorted: [3(1), 2, 1, 5, 3(2)] (where the (1) indicates that it is the first 3 in the array)\nSorted: [1, 2, 3(1), 3(2), 5] this is stable [1, 2, 3(2), 3(1), 5] this is unstable\nFor example if you have two arrays: [1, 3, 5] and [7, 9, 11] you can check the last element of the first array against the first element of the second, you can skip the merge.\nQuick sort #  "}),a.add({id:40,href:'/notes/CS130/CS130-lecture-20200923/',title:"CS130-lecture-20200923",section:"CS130",content:"Annoucements #  Assignment 1 has unlimited attempts, the last attempt counts.\nSubstrings #  Quicksort cont. #  Space complexity is O(1). Running time is O(n).\nExercise posted:\nSpace complexity best case is O(log(n)), and worst case is O(n). Running time best case is O(log(n)), and worst case is O(n).\n"}),a.add({id:41,href:'/notes/CS130/CS130-lecture-20200928/',title:"CS130-lecture-20200928",section:"CS130",content:"Dev environment #  JDK 11 JUnit 5 Module with all docs for setup\nFilenames: assignment1_ZedChance.zip\nQuicksort exercise solutions #  Quicksort cont. #  Runningtime is O(n)\nPriority queues #  a is complete b is complete c is incomplete d is not a binary tree e is incomplete f is complete\na is a height of 0 b-d is a height of 1 e-f is a height of 2\nfirst tree is neither second tree is max heap third tree is min heap\n"}),a.add({id:42,href:'/notes/CS130/CS130-lecture-20200930/',title:"CS130-lecture-20200930",section:"CS130",content:"Regarding quicksort 3-way #  Used for when there is a lot of duplicate keys, for example sorting by US state.\nHeap and priority queues #  Index starts at 1 so the math to find the child or parent works.\nSize starts at 0, but is incremented BEFORE it is used for the pq position.\nSpace complexity of swim method is O(1).\nSwap root and highest index and decrement index to break it off\nChoose the bigger child when sink starts\nSwap item if bigger, choosing bigger child to compare to\nSink space complexity is O(1).\nBest case running time is O(1) (if there are only 2 children). Worst case is O(lg(n)).\nIt sinks tree by tree\n"}),a.add({id:43,href:'/notes/CS130/CS130-lecture-20201005/',title:"CS130-lecture-20201005",section:"CS130",content:"Assignment 1 solutions #  Heapsort #  With the goal of non-decreasing order.\nSink each parent starting with the last, and working down.\nNow to sort, swap last element, reduce heap size, and sink item down\nThe element at the end will be put into place.\nRunning time for sink is O(lg(n)) Running time for entire sort is O(nlg(n)) worst case, best case)\nSpace complexity for sink is O(1) Space complexity for sort is O(1)\n"}),a.add({id:44,href:'/notes/CS130/CS130-lecture-20201007/',title:"CS130-lecture-20201007",section:"CS130",content:"Running time complexity: 3n + k) Space time complexity: O(n + k) Stable algorithm\nSort from least significant position to most significant position\n Runtime of findLargestStrings is O((n+m)log(m)) Space complexity is O(m)\n"}),a.add({id:45,href:'/notes/CS130/CS130-lecture-20201012/',title:"CS130-lecture-20201012",section:"CS130",content:"Annoucements #  Midterm exam on 21, unless pushed back to 26th.\nThe format is open book, open notes, no webcam. During class time so it will be timed. One question at a time, randomly shuffled, and you can\u0026rsquo;t go back to work on previous questions.\nRadix sort #  In this example: D = 3, K = 10. Sort from the least significant digit to the most significant digit.\nIf we use count sort to sort, our runtime is O(D * (N + K)).\nBest case is O(n) Worst case O(n^2) Average O(n)\nBest/worst case space complexity os O(1)\nSymbol table #  When a duplicate is added the value is overwritten. Ordered symbol tables are sorted by key.\nkey, value \u0026ldquo;\u0026rdquo;, 0 \u0026ldquo;S\u0026rdquo;, 1 \u0026ldquo;E\u0026rdquo;, 3 \u0026ldquo;A\u0026rdquo;, 2 \u0026ldquo;R\u0026rdquo;, 1 \u0026ldquo;C\u0026rdquo;, 1 \u0026ldquo;H\u0026rdquo;, 1 \u0026ldquo;X\u0026rdquo;, 1 \u0026ldquo;M\u0026rdquo;, 1 \u0026ldquo;P\u0026rdquo;, 1\nWhen it reaches the \u0026ldquo;E\u0026rdquo;, it adds 1 to the value. maxFreqKey would be \u0026ldquo;E\u0026rdquo;.\n"}),a.add({id:46,href:'/notes/CS130/CS130-lecture-20201014/',title:"CS130-lecture-20201014",section:"CS130",content:"RE: Midterm exam #  Oct 26, 7p-8:15p\nMake sure to join using SSO.\nOne question at a time, can\u0026rsquo;t go back. Open notes, open book.\nBinary search tree cont. #  Solutions for last exercises\nThis is invalid\nThis is valid\nThis is valid\nBest case runtime is O(1). Worst case runtime is O(n).\nBest case space complexity is O(1). Worst case space complexity is O(n).\nBest case runtime for put method is O(1). Worst case runtime for put method is O(n).\nBest case spacetime for put is O(1). Worst case spacetime for put is O(n).\nThe minimum key is as far left as possible.\npublic Key max() { if (root) return null; else return max(root).key; } private Node max(Node node) { if (node.right) return node; else return max(node.right); } public int height() { if (root) return 0; else return height(root); } private int height(Node node) { int leftSize); int rightSize); if (leftSize \u0026gt; rightSize) { // hmm  } } "}),a.add({id:47,href:'/notes/CS130/CS130-lecture-20201019/',title:"CS130-lecture-20201019",section:"CS130",content:"BST cont. #  Running time is O(n). Space complexity best case is O(lgn). Space complexity worst case is O(n).\n"}),a.add({id:48,href:'/notes/CS130/CS130-lecture-20201021/',title:"CS130-lecture-20201021",section:"CS130",content:"Midterm review #  MidTermReview.txt\nContents Everything covered from Module 1 to Module 6\nAnalysis of algorithm\n Asymptotic notations Best-case, average-case, worst-case Be able to provide time and space analysis for an given algorithm  Memory of a process\n What are the four sections? (code, data, heap, stack) What does each section contain? Understand function call and stack-based memory allocation  Recursion\n Base case Recursive vs. iterative approach, every recursive method can be implemented iteratively Consider stack-based memory allocation in space analysis  Sorting Algorithms\n merge sort, quick sort, heap sort, count sort, radix sort Sorting algorithm implementation \u0026amp; application, performance analysis and comparison  Data structures\n Binary tree Complete binary tree, priority queue, binary max/min heap Binary search tree Common operations for each data structure and their implementation Usages of data structures  Question types\n Single or Multiple choices Short answer Algorithm analysis (time and space)  Note\n The best way to prepare for the exam is to review class notes and related sections in the text book, and redo in-class exercises as well as homework questions. The mid-term exam will be open-book and open-notes.   Assignment 2 solutions #  Assignment 3 solutions #  "}),a.add({id:49,href:'/notes/CS130/CS130-lecture-20201028/',title:"CS130-lecture-20201028",section:"CS130",content:"2-3 Tree #   An empty tree is a 2-3 A BST is a 2-3 search tree no is yes  Search miss\nWorst case running time for 2-3 tree search is O(lgn). Remember the height of a 2-3 tree is between (floor(\\log_3 N)) and (floor(log_2 N)). So in the worst case it searches the entire height of the tree + 1.\nIt inserts it into the 3 node to preserve the balance of the 2-3 tree.\nCreates a temporary 4 node, then it splits.\nThe worst-case running time for 2-3 tree insertion is O(lgn)\nInvalid red-black BSTs\nThis is perfectly \u0026ldquo;black balanced\u0026rdquo; because each null leaf is 2 black links to the root. The height is 4 because you consider both black and red links.\n (i) is not black balanced, so not red-black BST (ii) is not black balanced, also key order is wrong, so not red-black BST (iii) is black balanced, special case where there is no red links (but they\u0026rsquo;re not required), so yes it is a red-black BST (iv) is black balanced, and red links are valid, key order is good, so red-black BST   "}),a.add({id:50,href:'/notes/CS130/CS130-lecture-20201102/',title:"CS130-lecture-20201102",section:"CS130",content:"One line is black, 2 lines is red\nis false  Runtime of rotateLeft is O(1). Space complexity is O(1).\nOur definition is left leaning so it needs to be rotated left.\nThe runtime of put is O(lgn). Space complexity is O(lgn).\n"}),a.add({id:51,href:'/notes/CS130/CS130-lecture-20201104/',title:"CS130-lecture-20201104",section:"CS130",content:"Midterm solutions #  Red-black BST exercise solution #  M is the number of children per node.\nEach non-leaf node has between 3 and 5 children for above example. Each leaf node has between 3 and 5 data items.\nUnordered symbol tables #  "}),a.add({id:52,href:'/notes/CS130/CS130-lecture-20201109/',title:"CS130-lecture-20201109",section:"CS130",content:"Hash codes should use all of the fields.\nAny perms of strings with the same letters will have the same hashcode, therefore this is a bad hash function.\nThe worst case runtime for put is O(n). The best case runtime for put is O(1). Space complexity for put is O(1).\nBest case runtime for get is O(1) and worst case is O(n). Space complexity for get is O(1).\nThe load factor is the number of key value pairs (N) divided by the table size (M), so (\\frac{10}{5}).\n"}),a.add({id:53,href:'/notes/CS130/CS130-lecture-20201116/',title:"CS130-lecture-20201116",section:"CS130",content:"C goes to the next open value because they collide\nresize is called if the table is \u0026gt;= being half full.\nThe first 8 insertions before the resize:\nPut the existing keys (they rehash), then continue putting the rest of the list\nA is true B is false C is true (another case of A basically) D is false (another case of B)\nFor get: best case runtime is O(1), worst case is O(n). For resize: avg runtime is O(m). For put: amortized O(1) runtime.\nLoad factor must be \u0026lt; 1 otherwise it will infinitely loop thru the table on a search miss.\nWe can\u0026rsquo;t simply set a key to null to delete, becauses if there are keys that hash to that index we won\u0026rsquo;t be able to find it. We start by setting the first key to null, then we have to rehash and reput the keys in the same cluster.\n"}),a.add({id:54,href:'/notes/CS130/CS130-lecture-20201118/',title:"CS130-lecture-20201118",section:"CS130",content:"Suppose: n = inputs.length m)`\nAverage runtime is O(n + m). Space complexity is O(m).\nModule 9, Ch 1.5 #  CORRECTION: Count should be decremented each time thru\n"}),a.add({id:55,href:'/notes/CS130/CS130-lecture-20201123/',title:"CS130-lecture-20201123",section:"CS130",content:"Quick union example\n   index 0 1 2 3 4 5 6 7 8 9     id 1 1 1 8 3 0 5 1 8 8       id 0 1 2 3 4     id 1 2 3 4 4    O(n^2) runtime if unioning linear items.\nWeighted union example\n   id 0 1 2 3 4 5 6 7 8 9     id 6 2 6 4 4 6 6 2 4 4    CORRECTION: 0 should be the root.\nCORRECTION: "}),a.add({id:56,href:'/notes/CS130/CS130-lecture-20201125/',title:"CS130-lecture-20201125",section:"CS130",content:"Answer: ( \\frac{2E}{V}) avg number of degree.\nIf you have V, no self loop, no parallel edges, what is maximum edges?\nAnswer: ( \\frac{V(V-1)}{2} )\nSo if you have (V), considered sparse.\nAdjacency lists represent each edge twice, so the number of spaces taken (number of nodes) is (2E). So the full space used by this is (V + 2E), so our space complexity is O(E + V).\n(V - 1)  Depth-first search trace on whiteboard:\nCount) worst case runtime.\nBack to the analysis of the algorithm:\nWorst case space is from a linear graph: "}),a.add({id:57,href:'/notes/CS130/CS130-lecture-20201130/',title:"CS130-lecture-20201130",section:"CS130",content:"Exercise solns #  Graph cont. #  Gets shortest path because it starts by searching all edges that are 1 away, then 2 away, and so forth.\nTracing the BFS implementation\nEnter the loop\nPath tree on right ^\nPerformance:\n Worst case runtime is O(E) or O(V+E) Worst case space complexity O(V), when every vertice is added to the queue   There is a maximum of (V(V-1)) vertices in a digraph with no parallel or self-loops. \u0026ldquo;Each edge can connect to every other edge.\u0026rdquo; The minimum number of edges is (V-1).   The indegree for 6 is 2 The outdegree for 6 is 1  Space complexity of reverse is O(V+E). Runtime complexity is O(V+E).\nWhat vertices are reachable from\n Source 1: 1 Source 2: 0, 1, 2, 3, 4, 5 Source 1,2,6: All except 7 and 8  Directing cycle\nThis would be impossible to take any courses. There cannot be any directed cycles in the digraph, it would be impossible to find the topological order. (This is a DAG).\nTopological sort with DFS trace\nVertexes in different color have been visited\n0, 3, 7, 6, 5 are reachable from 0. Now go by vertex order and check 1\nNow check 2\nEverything has been visited now. Our reversePost is finished. All edges flow from left to right.\nThe runtime for the constructor is O(V+E). Space complexity for the constructor is O(V).\n0: 6 1: 11 2: 0, 3 3: 6, 10 4: 1 5: 2, 10 6: 2 7: 8, 11 8: 1, 4 9: 10: 3 11: 8 "}),a.add({id:58,href:'/notes/CS130/CS130-lecture-20201202/',title:"CS130-lecture-20201202",section:"CS130",content:"Exercise solutions #  On the whiteboard:\nStart on vertex 0\nMove onto vertex 2, need to exhaust all vertices\nMove onto vertex 7\nThe reverse post order is : 8, 7, 2, 3, 0, 6, 9, 10, 11, 12, 1, 5, 4\nGraph cont. #  These are considered strongly connected. Also considered a strongly connected digraph.\n5 strongly connected components.\nReversed graphs are still strongly connected in the same components. A reversed graph\u0026rsquo;s reverse post order will show each component. Visit each vertex in the reverse post order and keep track of which ones have been visited, each vertex will be able to reach all the other vertex in the same component.\nA strongly connected digraph has 1 strong component.\nA DAG has (V) strong components.\nWeighted graphs #  If a graph is not connected, it doesn\u0026rsquo;t have a spanning tree.\nFor an edge-weighted graph with (V) vertices, a MST has (V - 1) edges.\nAnother look at the implementation:\nWorst case time comes from the pq operation.\nThis type of graph gives the maximum size of the pq.\nSkipping the eager prim implementation\nThe for loop on 13 is O(ElgE). The union find is O(ElgV). and since E is greater than or equal to the vertices minus 1, the overall runtime is O(ElgE).\nIt won\u0026rsquo;t connect v and w because it will create a cycle.\nEdge weighted digraphs #  "}),a.add({id:59,href:'/notes/CS130/CS130-lecture-20201207/',title:"CS130-lecture-20201207",section:"CS130",content:"Exercise solutions #  Single source shortest paths #  TYPO fixed in column 5 relax 4:\nThe max space taken by the IndexMinPQ is O(V - 1).\nDecimal to binary, and back\nIs a BST seach a P problem? Yes It is also a NP problem. It is not a NP-Complete problem.\n"}),a.add({id:60,href:'/notes/CS130/CS130-lecture-20201209/',title:"CS130-lecture-20201209",section:"CS130",content:"Review #  Assignment 5 solutions #  8:\n9:\nCORRECTION: 8 is a weight of 78, the picture is correct but the table shows 82.\n11:\nAssignment 4 solutions #  Rest of code in solutions on canvas\nFinal review #  "}),a.add({id:61,href:'/notes/CS130/CS130-priority-queues/',title:"CS130-priority-queues",section:"CS130",content:"Maxpq #  MaxPQ.java\n/** * MaxPQ (maximum priority queue) implemented from Algorithms (Sedgewick, Wayne) * pg. 318 */ public class MaxPQ\u0026lt;Key extends Comparable\u0026lt;Key\u0026gt;\u0026gt; { private Key[] pq; // heap-ordered complete binary tree  private int n = 0; // pq[0] is unused, heap uses pq[1..n]  /** * Create new empty max priority queue. * Useful if inserting one by one, where each element * is inserting at the end and \u0026#34;swims\u0026#34; up into place. * @param max maximum size of queue */ public MaxPQ(int max) { pq) new Comparable[max + 1]; } /** * Creates new max priority queue from existing array. * Takes an existing array and \u0026#34;sinks\u0026#34; each parent into * place decrementing from the last parent. * @param a array to create maxpq from */ public MaxPQ(Key[] a) { n = a.length; pq) new Comparable[n * 2]; for (int i) { pq[i] = a[i - 1]; } heapify(pq); } /** * Inserts a new item into the maxpq. * First adds the item to the end of the queue * then swims the item up into position. * @param v item to insert */ public void insert(Key v) { pq[++n] = v; swim(n); } /** * Deletes the root of the maxpq. * First swaps last item with root * then sinks the item down into position. * @return item at root */ public Key delMax() { Key max = pq[1]; exchange(1, n--); pq[n + 1] = null; sink(1); return max; } /** * Swims item up into position. * @param k index to swim up */ private void swim(int k) { while (k \u0026gt; 1 \u0026amp;\u0026amp; less(k / 2, k)) { exchange(k / 2, k); k = k / 2; } } /** * Sinks item down into position. * @param k index of item to sink down */ private void sink(int k) { while (2 * k \u0026lt;= n) { int j = 2 * k; if (j \u0026lt; n \u0026amp;\u0026amp; less(j, j + 1)) j++; if (!less(k, j)) break; exchange(k, j); k = j; } } /** * Sinks parents in a decrementing order. * Orders an array into a max heap. * @param a array to heapify */ private void heapify(Key[] a) { for (int i) { sink(i); } } /** * Checks to see if the maxpq is empty. * @return true if empty */ public boolean isEmpty() { return n == 0; } /** * Returns size of maxpq. * @return size as int */ public int size() { return n; } private boolean less(int i, int j) { return pq[i].compareTo(pq[j]) \u0026lt; 0; } private void exchange(int i, int j) { Key t = pq[i]; pq[i] = pq[j]; pq[j] = t; } public String toString() { String ret = \u0026#34;\u0026#34;; for (int i) { ret += pq[i] + \u0026#34; \u0026#34;; } return ret; } public static void main(String[] args) { Comparable[] a = {\u0026#34;S\u0026#34;, \u0026#34;O\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;T\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;M\u0026#34;, \u0026#34;P\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;E\u0026#34;}; MaxPQ\u0026lt;String\u0026gt; test); // this constructor heapifies  System.out.println(test); System.out.println(\u0026#34;Size: \u0026#34; + test.size()); System.out.println(\u0026#34;Inserting W\u0026#34;); test.insert(\u0026#34;W\u0026#34;); System.out.println(test); System.out.println(\u0026#34;Inserting J\u0026#34;); test.insert(\u0026#34;J\u0026#34;); System.out.println(test); System.out.println(\u0026#34;Deleting: \u0026#34; + test.delMax()); System.out.println(test); System.out.println(\u0026#34;Deleting: \u0026#34; + test.delMax()); System.out.println(test); System.out.println(\u0026#34;Inserting S\u0026#34;); test.insert(\u0026#34;S\u0026#34;); System.out.println(test); } } "}),a.add({id:62,href:'/notes/CS130/CS130-sorting-algorithms/',title:"CS130-sorting-algorithms",section:"CS130",content:"Merge #  Merge.java\n/** * Mergesort algorithm implemented from Algorithms (Sedgewick, Wayne) * Section 2.2, pg. 270 */ public class Merge { private static Comparable[] aux; public static void sort(Comparable[] a) { aux = new Comparable[a.length]; sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { // sort a[lo..hi]  if (hi \u0026lt;= lo) return; // base case  int mid) / 2; // find mid point  sort(a, lo, mid); // sort left half (recursive call)  sort(a, mid + 1, hi); // sort right half (recursive call)  merge(a, lo, mid, hi); // merge 2 sorted arrays  } private static void merge(Comparable[] a, int lo, int mid, int hi) { // merge a[lo..mid] with a[mid + 1..hi]  int i = lo, j = mid + 1; for (int k) { aux[k] = a[k]; } for (int k) { if (i \u0026gt; mid) // left side exhausted  { a[k] = aux[j++]; } else if (j \u0026gt; hi) // right side exhausted  { a[k] = aux[i++]; } else if (less(aux[j], aux[i])) // right side is \u0026lt; left side  { a[k] = aux[j++]; } else // left side is \u0026lt; right side  { a[k] = aux[i++]; } } } private static boolean less(Comparable v, Comparable e) { return v.compareTo(e) \u0026lt; 0; } public static void main(String[] args) { Comparable[] test = {55, 61, 22, 97, 56, 96, 96, 88, 57, 49, 31, 48}; // Comparable[] test = {\u0026#34;M\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;G\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;O\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;T\u0026#34;}; // Comparable[] test = {\u0026#34;Cool\u0026#34;, \u0026#34;12345\u0026#34;, \u0026#34;Hello\u0026#34;, \u0026#34;Aardvark\u0026#34;, \u0026#34;Archive\u0026#34;};  for (int i) { System.out.print(test[i] + \u0026#34; \u0026#34;); } System.out.println(); Merge.sort(test); for (int i) { System.out.print(test[i] + \u0026#34; \u0026#34;); } } } Quick #  Quick.java\n/** * Quicksort algorithm implemented from Algorithms (Sedgewick, Wayne) * Section 2.3, pg. 288 */ public class Quick { public static void sort(Comparable[] a) { sort(a, 0, a.length - 1); } private static void sort(Comparable[] a, int lo, int hi) { if (hi \u0026lt;= lo) return; // base case  int j); // partition and return index of pivot point // System.out.print(\u0026#34;lo: \u0026#34; + lo + \u0026#34;\\tj: \u0026#34; + j + \u0026#34;\\thi: \u0026#34; + hi + \u0026#34;\\t\u0026#34;);  print(a); sort(a, lo, j - 1); // sort left half (recursive call)  sort(a, j + 1, hi); // sort right half (recursive call)  } private static int partition(Comparable[] a, int lo, int hi) { // Partition into a[lo..i - 1], a[i], a[i + 1..hi]  int i = lo, j = hi + 1; // left and right cursors  Comparable v = a[lo]; // pivot item  while (true) { while (less(a[++i], v)) if (i) break; // scan from left until item is greater than pivot  while (less(v, a[--j])) if (j) break; // scan from right until it em is less than pivot  if (i \u0026gt;= j) break; // if cursors pass each other break  exchange(a, i, j); // exchange items at cursors  } exchange(a, lo, j); // put pivot item in place  return j; // return pivot item index  } private static boolean less(Comparable v, Comparable e) { return v.compareTo(e) \u0026lt; 0; } private static void exchange(Comparable[] a, int i, int j) { Comparable t = a[i]; a[i] = a[j]; a[j] = t; } public static void print(Comparable[] a) { for (int i) { System.out.print(a[i] + \u0026#34; \u0026#34;); } System.out.println(); } public static void main(String[] args) { // Comparable[] test = {\u0026#34;Q\u0026#34;, \u0026#34;U\u0026#34;, \u0026#34;I\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;K\u0026#34;, \u0026#34;S\u0026#34;, \u0026#34;O\u0026#34;, \u0026#34;R\u0026#34;, \u0026#34;T\u0026#34;};  Comparable[] test = {10, 12, 14, 9, 5, 10, 50, 52, 58, 3, 0, 15, 64}; print(test); Quick.sort(test); print(test); } } Analysis #     Algorithm Running time complexity Space complexity     Merge    \\( O(nlog(n)) \\)    \\( O(n) \\)     Quick Best:  \\( O(nlog(n)) \\)  Worst:  \\( O(n^2) \\)   Best:  \\( O(log(n)) \\)  Worst:  \\( O(n) \\)      "}),a.add({id:63,href:'/notes/CS131/CS131-lecture-20200901/',title:"CS131-lecture-20200901",section:"CS131",content:"Syllabus #  CSC131Syllabus_Penn.pdf\nSend email prior to office hours, makes it easier.\nA team project will happen.\nNotes are allowed during quizes! Don\u0026rsquo;t miss a quiz!\nhttps://padlet.com/azizipenn/cuj51f9q36w079ko\nWhat is computer engineering? #  "}),a.add({id:64,href:'/notes/CS131/CS131-lecture-20200903/',title:"CS131-lecture-20200903",section:"CS131",content:"HW 1 #  Article on Boeing 737 MAX disaster. Due next week.\nHow do we create software? #  This is the \u0026ldquo;original approach\u0026rdquo; to software engineering:\nDeployments can be done by the developers, or a separate team. Maintenance is typically done by developers, original or not.\nSLDC Models #  Waterfall Model #  The completed output from one phase is the necessary input to the next level.\nPrototype model #  Spiral model #  Adhoc model #  Agile process models #  https://padlet.com/azizipenn/dwj4dd61srbeitgp\n"}),a.add({id:65,href:'/notes/CS131/CS131-lecture-20200908/',title:"CS131-lecture-20200908",section:"CS131",content:"Agile cont. #  The generic model for \u0026ldquo;doing\u0026rdquo; agile\nWe will be using Scrum for this class.\nA daily standup is a timed event where the whole team gathers and stands together and checks in with each other.\nRetrospectives: at the end of a piece of work you will look back and try to improve.\n"}),a.add({id:66,href:'/notes/CS131/CS131-lecture-20200910/',title:"CS131-lecture-20200910",section:"CS131",content:"Breakout room exercise #  Our group is thinking waterfall.\nAgile\nSpiral\n Agile frameworks #  An example of a Trello board\n"}),a.add({id:67,href:'/notes/CS131/CS131-lecture-20200915/',title:"CS131-lecture-20200915",section:"CS131",content:"Annoucements #  First quiz at the end of next week, covers the first 4 weeks. It\u0026rsquo;ll be open over the weekend. Use case homework has been published. Going to hold off on discussion on the 737 MAX HW until case study is finished. Team survey is open!\nSoftware requirements #  How do you translate all of the elicited data into requirements?\n In-Class_and_HW_Activity 3_Use Case Description.pdf\nBusiness Use Case Name: International flight check-in\nTrigger: Customer approaches check in\nPreconditions: Ticket, e-ticket, name and flight number, at least destination\nPost conditions: Boarding pass, some helpful instructions\nActors: Check-in agent, client, computer system, airline company\nBasic flow:\n Get the passengers ticket, or record locator. Check that this is the right passenger, flight, and destination. Ask for passport, check picture and expiry Check for FF number, if none ask if passenger wishes to join and add temp number Check if computer assigned seat is okay, if automatically assigned. Otherwise ask seat preference and assign seat manually. Ask passenger wants to check bags, and verify carry-on is acceptable. Print bag tags and attach to bags, place checked bags on conveyor belt. Print boarding pass, make sure passenger knows where they are headed and what time the flight boards.  "}),a.add({id:68,href:'/notes/CS131/CS131-lecture-20200917/',title:"CS131-lecture-20200917",section:"CS131",content:"Use case template recap #  Traditional requirements #  Agile requirements #  "}),a.add({id:69,href:'/notes/CS131/CS131-lecture-20200922/',title:"CS131-lecture-20200922",section:"CS131",content:"3Cs #  https://docs.google.com/presentation/d/1zvpwRAHGJwOE9QqhNkLQHHftV6guk7rNxwDQ6RuYhZA/edit#slide=id.g998494e7fd_0_119\nhttps://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-activity-diagram/;WWWSESSIONID=C67B13698C795B1642BC5FB95C52D8F8.www1\n"}),a.add({id:70,href:'/notes/CS131/CS131-lecture-20200924/',title:"CS131-lecture-20200924",section:"CS131",content:"Annoucements #  Quiz opens up tonight at midnight\nUser stories cont #  Scrum #  "}),a.add({id:71,href:'/notes/CS131/CS131-lecture-20200929/',title:"CS131-lecture-20200929",section:"CS131",content:"Annoucements #  HW4 is due Oct 5 Team assignment 1 agreement is posted\n3C examples #  A good example:\nA \u0026ldquo;cloudy\u0026rdquo; example:\nAnother good example:\n\u0026ldquo;Kinda cloudy\u0026rdquo; example:\nHuman computer interation concepts #  "}),a.add({id:72,href:'/notes/CS131/CS131-lecture-20201001/',title:"CS131-lecture-20201001",section:"CS131",content:"HCI cont. #  ProjectDesc-OscarsProject.pdf\nSome questions we might want to ask:\n  How do the users usually watch movies\n tv with streaming service pc with streaming service x3    how often do you watch movies\n  How far through the movies do you usually watch\n  What language do they speak\n  "}),a.add({id:73,href:'/notes/CS131/CS131-lecture-20201006/',title:"CS131-lecture-20201006",section:"CS131",content:"737 Boeing disaster #  Unexpected by the pilots, the engineers knew.\n"}),a.add({id:74,href:'/notes/CS131/CS131-lecture-20201008/',title:"CS131-lecture-20201008",section:"CS131",content:"HCI finished #  Accessability slide\n "}),a.add({id:75,href:'/notes/CS131/CS131-lecture-20201013/',title:"CS131-lecture-20201013",section:"CS131",content:"Project, sprint 0 #  "}),a.add({id:76,href:'/notes/CS131/CS131-lecture-20201015/',title:"CS131-lecture-20201015",section:"CS131",content:"Git #  "}),a.add({id:77,href:'/notes/CS131/CS131-lecture-20201020/',title:"CS131-lecture-20201020",section:"CS131",content:"Annoucements #  Our next quiz is next fri 30\nREST #  "}),a.add({id:78,href:'/notes/CS131/CS131-lecture-20201022/',title:"CS131-lecture-20201022",section:"CS131",content:"Software architecture #  Architecture has styles, and this can be translated to software terms also\nCRC (Class responsibility collaboration) #  CRC Cards are a brainstorming technique to help you think about the design of your application.\nLike the 3C\u0026rsquo;s card, its meant to be done on a 3x5 card. The assumption is its not permanent, you\u0026rsquo;re not locked in.\nClasses should only be responsible for its own information. It shouldn\u0026rsquo;t be responsible for keeping track of or holding another class\u0026rsquo;s data.\nhttps://padlet.com/azizipenn/tkzowdu0pkocinpz\n"}),a.add({id:79,href:'/notes/CS131/CS131-lecture-20201027/',title:"CS131-lecture-20201027",section:"CS131",content:"Sprint 0 Review and Retrospective #  The review is about the product.\nThe retrospective is about the process. Make some concrete goals for the next sprint. Instead of \u0026ldquo;improve communication\u0026rdquo;, make it something concrete like \u0026ldquo;We agree to communicate via X and respond within Y time.\u0026rdquo;\n1. What went well in the sprint? #  Our team was able to create a persona from the contextual inquiry of multiple people. Our team was able to get an idea of some future user stories that will need to be completed in the next sprint. Our team was able to setup the project shell and familiarize ourselves with the general workflow. Our team was able to come up with ideas for a mockup UI.\n  What motivated us to do it?\n We did contextual inquiry to be able to make a persona. We set up our project shell in a remote repository and familiarized everyone with the general workflow of the project contribution.    What did we do differently to make it a success?\n We took a lot of different input, from other perspectives, to make a convincing persona. We had several meetings to discuss the details of the persona.    Which training, skill, or knowledge contributed to the difference? Which strong point in you makes it happen?\n Past IDE and Git experience let us set up our project shell.    Which strong points of your team that made it happen?\n Set up a step by step how-to tutorial on how to make sure the project is running correctly. Set up a step by step how-to tutorial on the general workflow for contributing to the project.    2. What went wrong in the Sprint? #  Familiarizing ourselves with Flying Donut took longer than expected.\n  How did it go wrong?\n Navigating the tool wasn\u0026rsquo;t as intuitive as we thought. The sprint was never actually started and as labelled as \u0026ldquo;postponed\u0026rdquo;.    What did you do that went wrong?\n We never \u0026ldquo;started\u0026rdquo; the sprint because all team members weren\u0026rsquo;t all joined. We didn\u0026rsquo;t assign every team member to the skill debt story.    Were you aware of what you were doing that went wrong?\n We were aware that learning Flying Donut was taking longer than expected.    Did you understand it wrong and hence implemented wrong? Did you understand right but still it went wrong?\n We understood the idea and what Flying Donut is for, however it took a little time to learn how to use it effectively.    What did we do well?\n In the end, we figured out Flying Donut enough for it to work for our team.    3. What we had learned in the sprint? #  We learned how to create a persona and do contextual inquiry. We learned how to set up our remote repository for our team. We learned how to set up sprints using Flying Donut. We learned what our project needs to accomplish at a high level. We are learning how to effectively use our meeting time.\n  Which techniques were useful?\n Coming together as a team and meeting on the weekends helped jump start the sprint 0 tasks. Our Discord channel and project-setup guide was useful in making sure that everyone had their IDE setup correctly.    Which techniques were not useful?\n Creating the persona wasn\u0026rsquo;t as useful as we thought.    What went in a smooth fashion during this sprint?\n The contextual inquiry went in a smooth fashion. Our remote repository and IDE setup went in a smooth fashion.    What did not go smooth during this sprint?\n Backlog setup and user stories. Making sure that our user stories were well refined. Assigning ourselves to user stories/tasks.    What learning during this Sprint can educate us for the upcoming Sprint?\n We need to correctly assign ourselves to tasks in the sprint, and make sure we are meeting regularly as an entire team.    4. What should we do differently in the next sprint? #  We need to refine our user stories, and make sure that they are from the perspective of the user, and that they show what the story should accomplish. We need to create more user stories that give shape to the bigger picture of the project.\n  How can the strength of the individual be utilized to resolve the issue?\n As Scrum Master, I\u0026rsquo;ll make it a point to read our user stories in the backlog every once in a while during a meeting.    What should be done often to prevent the issue from arising again?\n Once project development begins, it will be easier to identify user stories that aren\u0026rsquo;t specific enough.    Which actions must be implemented immediately for which you have the bandwidth and capability? Identify the 1 thing to be changed and explain how you could change it?\n During our meetings, we need to identify and create user stories. During our meetings, we will groom the backlog to make sure our user stories fit the bigger picture.    What strategies will work to complete the job?\n More backlog grooming, and more team communication.    Corrective actions #    What will you do in the upcoming Sprint to complete this action? How will you do it to make it a success?\n During meetings, we will make a point to read and refine our user stories and make sure we have enough tasks for the team.    When will you do it during the Sprint?\n The user story refinement needs to be done towards the beginning of the sprint.    Do you require help to complete this?\n Our team feels confident in our ability to better refine our backlog.    What additional support do you require?\n If our team needs additional support, online tutorials would help.    How will you let me know that you completed it?\n Our sprint backlog will be better refined, and documented on Flying Donut.    What will you do next after accomplishing this during the Sprint?\n We will have a good idea on how to setup the next sprint from what we learned during this one.    "}),a.add({id:80,href:'/notes/CS131/CS131-lecture-20201029/',title:"CS131-lecture-20201029",section:"CS131",content:"Reminder #  Quiz opens at fri and closes mon at midnight. 35 min to complete 17 questions.\nArchitecture cont. #  SOA: Service oriented architecture\n"}),a.add({id:81,href:'/notes/CS131/CS131-lecture-20201103/',title:"CS131-lecture-20201103",section:"CS131",content:"https://www.youtube.com/watch?v=UI6lqHOVHic\n"}),a.add({id:82,href:'/notes/CS131/CS131-lecture-20201105/',title:"CS131-lecture-20201105",section:"CS131",content:"A solution\n\u0026ldquo;Design specs\u0026rdquo; aren\u0026rsquo;t a part of the agile process, but this basic idea holds in sprint plannings.\n"}),a.add({id:83,href:'/notes/CS131/CS131-lecture-20201110/',title:"CS131-lecture-20201110",section:"CS131",content:"Correction from UML lectures #  Correction: there is no distinction between a filled in triangle between inheritance when inheriting from abstract or concrete.\nSOLID cont. #  Code Design #  Singleton pattern #  Factory pattern #  "}),a.add({id:84,href:'/notes/CS131/CS131-lecture-20201112/',title:"CS131-lecture-20201112",section:"CS131",content:"Architecture\n Application – layers – what do the layers do Where do the different components live Whats the interface between layers  Design principles\n Symptoms of bad design – rigid, fragile, easier to modify with hacks (viscosity) SOLID – employed by frameworks  Design patterns\n Used in frameworks – a lot employ the factory pattern May be used ourselves, iterator pattern? Singleton?  On tuesday we need a diagram of the application structure.\n"}),a.add({id:85,href:'/notes/CS131/CS131-lecture-20201119/',title:"CS131-lecture-20201119",section:"CS131",content:""}),a.add({id:86,href:'/notes/CS131/CS131-lecture-20201124/',title:"CS131-lecture-20201124",section:"CS131",content:"Final will be essay and same format as other exams. May be cumulative.\nProject management #  Verification and validation #  "}),a.add({id:87,href:'/notes/CS131/CS131-lecture-20201201/',title:"CS131-lecture-20201201",section:"CS131",content:""}),a.add({id:88,href:'/notes/CS131/CS131-lecture-20201203/',title:"CS131-lecture-20201203",section:"CS131",content:""}),a.add({id:89,href:'/notes/CS131/CS131-lecture-20201208/',title:"CS131-lecture-20201208",section:"CS131",content:"DevOps #  "}),a.add({id:90,href:'/notes/CS131/CS131-study-guide-1/',title:"CS131-study-guide-1",section:"CS131",content:"Study guide 1 #  Fall2020-Quiz 01 Study Guide_Revised.pdf\n1. Know one of the definitions of software engineering presented in class. #  2. Be able to identify an SDLC model given a diagram and/or it’s unique characteristics #  Waterfall #  The completed output from one phase is the necessary input to the next level.\nPrototype model #  Spiral model #  Adhoc model #  Agile #  3. Know the common SDLC phases and what’s is done in each #  4. Know a few pros and cons of each model #  5. Know some of the top agile techniques #  A daily standup is a timed event where the whole team gathers and stands together and checks in with each other.\nRetrospectives: at the end of a piece of work you will look back and try to improve.\n6. Know some characteristics of the Agile frameworks discussed in class #  Scrum #  Kanban #  XP #  7. Know the roles and responsibilities in Scrum. #  ##8. Know properties of a good requirement\n9. Know what each IEEE quality attribute means #   Note: omitted 10, 11, 12 from study guide\n 13. Know what a Use Case is (but we won’t have Use case description or diagrams until next quiz.) #  14. Know 3C’s #  15. Know user stories and how to break them up. #  "}),a.add({id:91,href:'/notes/CS131/CS131-study-guide-2/',title:"CS131-study-guide-2",section:"CS131",content:"Study guide 2 #  1. Know the main purpose and general process of conducting a Contextual Inquiry. #  2. Know what is a persona. #  3. Be able to describe the flow of an Activity Diagram. #  4. Know Scrum roles, artifacts and events. #    Understand their definition/purpose/responsibilities.\n  Know the Scrum lifecycle and order of events.\n  5. Know the 3C’s(Card, Conversation, Confirmation). #  6. Know what a Wireframe, Mockup and Storyboard are. #  7. Be able to enumerate three elements from the design, SAC, CAP and/or FeVERprinciples discussed in class (e.g. Simplicity, Contrast, Error Prevention \u0026amp; Recovery). #  8. Know what XML and JSON look like. #  9. Know what the 200, 404 and 500 HTTP status codes mean. #  10. Know the basic Git commands. #  "}),a.add({id:92,href:'/notes/CS131/CS131-study-guide-3/',title:"CS131-study-guide-3",section:"CS131",content:"Software Architecture #  1. Given an architecture diagram or description, identify the architecture style. #  2. Know 1 advantage and disadvantage of: #    Client-Server\n  Layered \u0026amp; Mutli-tiered\n  Model-View-Controller\n  Pipe and filter\n  3. Given a class diagram, answer some questions about relationships/properties. #  4. Name and explain(brief) some symptoms of poor design. #  5. Name and explain(brief) three general design principles. #  6. Given a design that breaks a SOLID principle, identify a solution. #  7. Define Coupling and Cohesion. Know the ideal levels of each (low coupling, high cohesion.) #  8. What and why of design patterns, in general. #  9. Design pattern types (Creational, Structural, Behavioral) #  10. A problem solved by a design pattern and how the design pattern provides a solution. For example, given a problem what design pattern(s) would be most appropriate. Only select from set of patterns covered in class. #  Singleton\nFactory\nComposite\nIterator\nObserver\nStrategy\n11. The difference between Static \u0026amp; Dynamic analysis #  e.g. SonarQube\n12. Strengths \u0026amp; Weaknesses of manual and automated static analyses. #  13. Identify/define measurements done by Static Analysis tool #  14. Define Refactoring \u0026amp; its purpose #  15. The refactoring process #  "}),a.add({id:93,href:'/notes/CS131/CS131-study-guide-4/',title:"CS131-study-guide-4",section:"CS131",content:"CS131-study-guide-1 #   Software engineering definitions SDLC lifecycles SDLC phases Pros and cons of each SDLC model Top agile techniques Agile frameworks, characteristics Scrum roles/responsibilities Requirements, properties of good requirements IEEE quality attributes Use case 3C\u0026rsquo;s User stories, how to break them up  CS131-study-guide-2 #   Contextual inquiry Persona Scrum roles, artifacts, events 3C\u0026rsquo;s Mockups, wireframe, story board Design elements, SAC, CAP FeVER XML, JSON 200, 404, 500 HTTP codes Git commands, basic  CS131-study-guide-3 #   Architecture style, monolith, client-server, layered, pipe/filter, event driven, model-view-controller, service based, microservice Advantages and disadvantages of architectures Class diagrams Symptoms of poor design Design principles, SOLID, KISS, YAGNI etc SOLID principles in detail Coupling and cohesion Why use design patterns? Design pattern types, creational/structural/behavioral What pattern provides the best solution? Static and dynamic analysis Refactoring  Final study guide #  Project Management #    Constraints   Triple Constraint Theory / Brooks Law   Quality/Testing #    Validation vs. verification   Terminology (defect, trigger, etc)   White Box vs. Black Box Testing   Given flow graph, define all possible paths 5. Types of tests (unit, system, etc.)\n  Partition input values   DevOps #  Covered in CS131-lecture-20201208\n DevOps Terminology (SLA, Operations, CI/CD etc.) How DevOps differs from traditional Operations/Maintenance phase DevOps components  "}),a.add({id:94,href:'/notes/CS133/CS133-lecture-20210125/',title:"CS133-lecture-20210125",section:"CS133",content:"Abstraction #   A generalization of something too complext to be dealt with in its entirety For humans not computers  It is a techinque we use to compensate for the relatively puny capacity of our brains There aren\u0026rsquo;t enough neurons (or connections) in our brain to process the rich detail around us during a single moment in time   Successful designers developer abstractions and hierarchies of abstractions for complex entities and move up and down this hierarchy with splendid ease.  Examples\n Anytime we see a simple interface covering a more complex system, you should think \u0026ldquo;abstraction\u0026rdquo;  A car is a very complex machine but the interface is simple A video game controller only has a few buttons, but underneath the controller is a complex mechanism A programming language can be fairly simple, but it translates the instructions you write into machine code, which is complex   Data types are abstractions  A linked list abstracts a collection of connected nodes A node abstracts the detail of a structure holding an instance of a primitive data type and a pointer   Functions are abstractions  A function abstracts the details of an algorithm, with a simple name e.g. fahrenheitToCentrigrade()    Form consistent abstractions\n Abstraction is the ability to engage with a concept while safely ignoring some of its details Base classes and interfaces are abstractions  i.e. UIComponent (or any GUI toolkit) Mammal (classic superclass when discussing OO) The interface defined by a class is an abstraction of what the class represents   You shouldn\u0026rsquo;t have to look at the method body code to understand what this method does  someObject.toString()    What is OO?\n Procedural paradigm:  Software is organized around the notion of procedures Procedural abstraction  Works as long as the data is simple   Adding data abstractions  Groups together the pieces of data that describe some entity Helps reduce the system\u0026rsquo;s complexity, such as Records and structures     Object oriented paradigm:  Organizing procedural abstractions in the context of data abstractions    OO paradigm\nAn approach to the solution of problems in which all computations are performed in the context of objects.\n The objects are instances of classes, which:  are data abstractions container procedural abstractions that operate on the objects   A running program can be seen as the collectino of objects collaborating to perform a given task  What is a class?\n A unit of abstraction in an OO program Represents similar objects  its instances   A kind of software module  Describes its instances' structure (properties) contains methods to implement their behavior   A blueprint  we can use this blueprint to create new objects   Are a container in which we define the properties and behaviors of the objects that will become our system faciliate the organization of concepts within the domain of the system We think of them as having responsibilities, but vlasses are an organization tool, its really the objects that have the responsibilitiy Classes are for the developer, they are the organizational bridge between our understanding of the software system and its runtime behavior.  Whats an object?\n A chunk of structured data in a running software system Has properties  represents its state   Has behavior  how it acts and reacts May simulate the behavior of an object in the real world     An object is a bundle of capabilities It is defined by what it can do  not how it does it   Practically, this means an object is defined by the messages that it can send and receieve The methods that handle these messages comprise the sole interface to the outside world Yes, objects have data, but the makeup of that data should be irrelevant Focus on what objects can do!  The prime directive\n Never ask an object for information that you need to do something; rather, ask the object that has the information to do the work for you!\n Modularity #   The goal of design is to partition the system into modules and assign responsibility among the components\n Many languages embrace the concept of a module\n Packages are named using the concatenation of the enclosing packagee names Types (classes) must declare what package they belong to  Otherwise they are placed in the \u0026ldquo;default\u0026rdquo; (unnamed) package   Packages name become part of the class name, for following class has the full name solarSystem.planets.earth.Human  package solarSystem.planets.earth; // a class defining species originating on Earth public class Human { // class declarations and methods }  The goal of design is to partition the system into modules and assign responsibility among the components in a way that  High cohesion within modules, and Loose coupling between modules   Modularity reduces the total complexity a programmer has to deal with at anyone time assuming:  Functions are assigned to modules in a way that groups similar functions together (separation of concerns), and There are small, simple, well-defined interfaces between modules (information hiding)   The principles of cohesion and coupling are probably the most important design principles for evaluating the effectiveness of a design  Encapsulation #  Access modifiers\n public  any class has acesss   protected  Only code in the package, or subclasses can access   (blank) default is called package protected private  Only code written in the class can access Inheritance still occurs    So do we need getters and setters in example 1? No. The class is really just a structure. If the class were imbued with some more behavior, then we should revisit this question.\nSo back to the point example, we are not hiding information at all. With the balance example, we agree there should be something hidden (the balance).\n"}),a.add({id:95,href:'/notes/CS133/CS133-lecture-20210208/',title:"CS133-lecture-20210208",section:"CS133",content:"UML #  Since there isn\u0026rsquo;t a way to pass a new DisplayPanel object into the constructor, it is a composition.\nExample CRC card building\nClean code #  Design principles #  \u0026ldquo;The Art of Clean Code\u0026rdquo; video #  Summary:\nVictor Rentea\u0026rsquo;s clean code video had a lot of amazing information for making sure that the code you write is considered \u0026ldquo;clean.\u0026rdquo; I think that clean code is a very important part of being a good programmer because it conveys the sense that you care about your team\u0026rsquo;s ability to read your code.\nMy biggest surprise after watching the video was that writing clean code has little to do with the actual formatting of your file. Instead, it has to do with the way you organize your file. Simple things like making sure that each function is only doing one thing, and not adding ambiguous words to your class/function names. Another big aspect of writing clean code has to do with the continual refactoring and maintenance of your code. To sum up Victor\u0026rsquo;s ideas: once your code works don\u0026rsquo;t consider yourself done. It takes an ongoing effort to maintain clean code because of the ever evolving nature of software engineering.\nAnother very interesting aspect of Victor\u0026rsquo;s talk had to do with comments. Comments can easily become redundant if the code you are writing follows good naming conventions and isn\u0026rsquo;t obfuscated in any way. Victor explains that you should always be able to express what your code is doing with code, and comments will fall out of sync with code when it is inevitably changed in the future.\nA good point Victor had was on the topic of OOP. It is a common misunderstanding that just because your class has private fields and public accessors that you are practicing OOP. He explained that most business logic will lend itself nicely to procedural code, and that you can successfully utilize OOP by putting short and simple procedural code inside what he called \u0026ldquo;logic containers.\u0026rdquo;\nOverall, all of his explanations were very good and should make a lot of sense to someone who strives to write clean code, myself included.\n"}),a.add({id:96,href:'/notes/CS133/CS133-lecture-20210210/',title:"CS133-lecture-20210210",section:"CS133",content:"Inheritance #  Replace inheritance with delegation #  Polymorphism #  Interfaces #  Extending multiple interfaces only applies to other interfaces\n"}),a.add({id:97,href:'/notes/CS133/CS133-lecture-20210215/',title:"CS133-lecture-20210215",section:"CS133",content:"CN1 #  Components #  Layout managers #  Building the GUI #  "}),a.add({id:98,href:'/notes/CS133/CS133-lecture-20210217/',title:"CS133-lecture-20210217",section:"CS133",content:"Event driven #  laidOut() is called once the component is fully \u0026ldquo;laid out\u0026rdquo; (once it\u0026rsquo;s drawn after the show() method is called).\nCommand design pattern #  Observer design pattern #  The old way of doing it: #  "}),a.add({id:99,href:'/notes/CS133/CS133-lecture-20210227/',title:"CS133-lecture-20210227",section:"CS133",content:"Design Patterns #  Strategy pattern #  An example in codename one\nComposite pattern #  An example of the \u0026ldquo;wrong way to do things\u0026rdquo;\nA refactored way:\nDecorator pattern #  As a reminder, this is not the same as the composite pattern:\nState pattern #  Pree\u0026rsquo;s metapatterns #  Concerning the state pattern vs the strategy pattern\nSingleton pattern #  Note the synchronize keyword in the method header, this makes the method thread safe.\nFactory pattern #  Abstract factory pattern #  "}),a.add({id:100,href:'/notes/CS133/CS133-lecture-20210301/',title:"CS133-lecture-20210301",section:"CS133",content:"Visitor pattern #  This becomes hard to maintain, and violates the open closed principle.\nThe concrete visitors are the extensible operations we can perform to add more features to the concrete elements.\nWhy the visitor pattern? #  Single vs double dispatch (polymorphism). Java supports single dispatch out of the box, but double isn\u0026rsquo;t supported out of the box.\nAnimal dog = new Dog(); Animal cat = new Cat(); Double dispatch is not openly supported, in other words you can\u0026rsquo;t have unique interactions between 2 different classes dynamically.\nSomething like\ndog.makeSound(cat); Gives a compilation because they are of Animal type.\nFunctional programming languages like scheme can support double (and multi) dispatch.  An example with credit cards #  This table displays the interaction between 2 objects, the credit card and the offer type.\npublic interface CreditCard { String getName(); accept(OfferVisitor v); } public class BronzeCreditCard implements CreditCard { getName() {return \u0026#34;Bronze\u0026#34;;} void accept(OfferVisitor v) { v.visitBronzeCreditCard(this); } } public interface OfferVisitor { void visitBronzeCreditCard(BronzeCreditCard bronze); } public class GasOfferVisitor implements OfferVisitor { void visitBronzeCreditCard(BronzeCreditCard bronze) { // code to compute cashback for a bronze card buying gas  } } public class HotelOfferVisitor implements OfferVisitor { void visitBronzeCreditCard(BronzeCreditCard bronze) { // code to compute cashback for a bronze card paying for a hotel  } } We can continue to add more offers without having to rewrite anything in our card classes.\nSo this is how its used:\nBronzeCreditCard bronze = new BronzeCreditCard(); HotelOfferVisitor hotelVisitor = new HotelOfferVisitor(); GasOfferVisitor gasVisitor = new GasOfferVisitor(); // the interaction between a bronze card and a hotel offer bronze.accept(hotelVisitor); // the interaction between a bronze card and a gas offer bronze.accept(gasVisitor); The visitor pattern is usually going to be used if your class structure isn\u0026rsquo;t changed often, but the operations performed on the structure change quite a bit. Can be used when traversing a structure of items and needing to perform different operations on each node (compilers).\n"}),a.add({id:101,href:'/notes/CS133/CS133-lecture-20210307/',title:"CS133-lecture-20210307",section:"CS133",content:"Make your code suck less #  12. Schedule time to lower technical debt #  11. Favor high cohesion #  10. Favor loosing coupling #  9. Program with intention #  8. Avoid primitive obsession #  7. Prefer clear code over clever code #  6. Apply Zinsser\u0026rsquo;s principle on writing #  5. Comment why, not what #  4. Avoid long methods – Apply SLAP #  3. Give good meaningful names #  2. Do tactical code reviews #  Never say whats wrong, always say what can be better.\n1. Reduce state and state mutation #  Start with methods and the fields (and getters/setters) will fall into place.\nRecap #  "}),a.add({id:102,href:'/notes/CS133/CS133-lecture-20210310/',title:"CS133-lecture-20210310",section:"CS133",content:"Basic color theory #  RGB is an additive color model.\nCMYK is a subtractive color model.\nRefresh rates, frame buffers, v-sync #  Video game aesthetics #  "}),a.add({id:103,href:'/notes/CS133/CS133-lecture-20210314/',title:"CS133-lecture-20210314",section:"CS133",content:"GUI Basics #  CN1 Component example #  In DigitalClockComponent:\nThen in AppMain:\n"}),a.add({id:104,href:'/notes/CS133/CS133-lecture-20210407/',title:"CS133-lecture-20210407",section:"CS133",content:"Graphics #  Transformations #  Transformations using matrices #  Applying transformation with matrices #  Active matrix areas #  Concatenation of transformations #  Images within 2D games #  Image characteristics #  Image repository #  Alpha blending #  Alpha compositing #  Additive blending #  "}),a.add({id:105,href:'/notes/CS133/CS133-lecture-20210423/',title:"CS133-lecture-20210423",section:"CS133",content:"Animation #  Frame based #  Collision detection #  ICollider interface #  Handling collision #  Sound #  Playing sounds in CN1 #  Looping sounds #  Multiple dispatch #  "}),a.add({id:106,href:'/notes/CS133/CS133-lecture-20210504/',title:"CS133-lecture-20210504",section:"CS133",content:"Applications of transforms #  Transform class #  Local coordinate systems #  Example Triangle class #  Mapping to display location #  Using the Graphics context #  Making transformable objects #  Composing transforms #  Hierarchical objects #  Dynamic transformations #  Audio #  Lessons learned in audio programming #  "}),a.add({id:107,href:'/notes/CS133/CS133-lecture-20210513/',title:"CS133-lecture-20210513",section:"CS133",content:"Multitasking #  Threads vs processes #  Java threads #  Counter thread example #  Concurrent output example #  Multiple user threads example #  Priorities and synchronization #  Overview of Thread methods #  Common uses #  "}),a.add({id:108,href:'/notes/CS133/CS133-lecture-20210519/',title:"CS133-lecture-20210519",section:"CS133",content:"Mobile development – App distribution #  Certificates, UDID, signing authorities #  Signing and distribution #  Building native apps using CN1 #  Downloading/installing native apps #  "}),a.add({id:109,href:'/notes/CS134/CS134-lecture-20210601/',title:"CS134-lecture-20210601",section:"CS134",content:"Course orientation #  Syllabus #  134Sy_Summer2021.pdf  Notes during orientation #   5 assignments, 5 weekly homeworks Effort may be taken into account during assignment grading Assignments build upon the previous assignment Midterm on June 22, and final on last day  Introduction to database management systems #  Files\n persistent on disk easy to work with   DBMS\n needs knowledge of software needs to design database structure can handle more complex situations    Imagine we have 2 different files: student_info and grade_record\nNotice the duplication among the 2 files. This will waste storage if using a normal file system. There may also be inconsistencies between the 2 files if only 1 is changed. DBMS can control all of these things for you.\n"}),a.add({id:110,href:'/notes/CS134/CS134-lecture-20210602/',title:"CS134-lecture-20210602",section:"CS134",content:"DBMS cont. #  Database users #  If we\u0026rsquo;re storing student information in a database, we\u0026rsquo;ll have fields such as\n age birthdate  If we want to store one in the database, which should we pick? Why only one?\nWe should choose the birthdate because\n we can derive the age birthdate is also more accurate of a measure of age we won\u0026rsquo;t need to increment the age in the database every year  What is the disadvantage of saving both?\n we don\u0026rsquo;t want to waste space when we can derive the age from the birthdate. if we save both we have to make sure they are consistent. In other words: we would have to increment the age on the birthdate.  For end users:\n casual end users: need to use a sophisticated database query language, like SQL naive users: use a menu-driven interface sophisticated end users: familiar with DBMS to implement their applications  Data models #  High level models\n ER, entity-relationship model, best for relational database UML  Representational / implementation model\n relational data model, uses relational database object data model, O-O, O-R network and hierarchical model, uses graph model  DBMS architecture and data independency #  At the conceptual schema level, the user doesn\u0026rsquo;t necessarily know the exact implementation of the internal schema level.\nDatabase languages #  SQL is a comprehensive integrated language of DDL and DML for relational databases.\nEntity-relationship model #  Note: ER diagram notation can change based on different textbooks. We will use the original notation that is used in our text book.  Entity and attributes #  Properties can be used to describe the entity. For example for a student:\nOn notation:\n entities are in rectangles attributes are circled and connected to the entity  The divisibility of an attribute depends on application. We can divide address into subparts:\nHere, address is the composite attribute. Name can also be composite.\nStudents can only have 1 birthdate, but they can have multiple phone numbers. We can indicate that by a double circle.\nSince age can be calculated from the birthdate, we can put the age attribute in the ER diagram, but we indicate it can be derived with a dashed line.\nER diagram notation #  Keys #   must be a unique identifier  We underline the attribute name to indicate that it is the key\nIf we have an entity called classroom:\nWe can use a composite key of the attributes building and roomNo.\nKeys must be minimal. In other words: adding capacity to the composite key for the classroom model wouldn\u0026rsquo;t add anything beneficial.\nValue sets #  ER diagram example #  Relationship #  Relationships are drawn using a diamond.\nStructure constraint #  "}),a.add({id:111,href:'/notes/CS134/CS134-lecture-20210603/',title:"CS134-lecture-20210603",section:"CS134",content:"ER model cont. #  Structure constraint cont. #  The reason we have both   \\( M \\)  and  \\( N \\)  is because they are are both in the same association. It is okay to reuse  \\( M \\)  in other places in the diagram.\nNote: The double line from employee to works_for indicates the total participation.  Weak entity #  Entity has\n key instance  In this diagram, we don\u0026rsquo;t necessarily know what key we should use for the dependent entity. We need to treat dependent as a weak entity, indicated by a double box, also note the total participation association.\nWe can use a partial key of the employee\u0026rsquo;s key plus the dependent\u0026rsquo;s name, indicated by a dashed line.\nAttributes of relationship types #  Note: We could optionally have mgr_start_date belong to either entity, because it is a 1:1 relationship.  If one entity, say department, has total participation, it is better to have mgm_start_date belong to that entity. (If we had mgr_start_date belong to employee, then all except 1 employees would have a null attribute, thus it is better to have the department hold the attribute.)\nWe have 2 choices for the emp_start_date attribute, it can either belong to the employee or the works_for association.\nRecursive relationships #  Non-binary relationship #  Non-binary relationships will not be on exams/assignments.  A bigger ER diagram example #  In class exercise #  Note: This exercise is not included in the week 1 assignment.   The university keeps track of each student\u0026rsquo;s name (first name, middle name, last name), student number, social security number, permanent address and phone, birthdate, sex, class (e.g. freshman, sophomore, \u0026hellip;, graduate), and degree program (e.g. B.A., B.S., \u0026hellip;, Ph.D.). Some user applications need to refer to the street, city, state, and zip of the student\u0026rsquo;s permanent address, and to the student\u0026rsquo;s last name. Both social security number and student number have unique values for each student.  "}),a.add({id:112,href:'/notes/CS134/CS134-lecture-20210607/',title:"CS134-lecture-20210607",section:"CS134",content:"ER model exercise cont. #  Add this assignment into the weekly hw upload.    The university keeps track of each student\u0026rsquo;s name (first name, middle name, last name), student number, social security number, permanent address and phone, birthdate, sex, class (e.g. freshman, sophomore, \u0026hellip;, graduate), and degree program (e.g. B.A., B.S., \u0026hellip;, Ph.D.). Some user applications need to refer to the street, city, state, and zip of the student\u0026rsquo;s permanent address, and to the student\u0026rsquo;s last name. Both social security number and student number have unique values for each student.\n  Each department is described by a name, department code, office number, office phone, and college. Both name and code have unique values for each department.\n  The university keeps track of each student’s minor department (if any) and major department. A student majors in exactly one department. One department can have many major students (at least one) and many minor students (at least one). A student can be a minor of at most one department.\n  Each course has a course name, description, course number, number of semester hours, level, and offering department. The value of course number is unique for each course.\nSome departments may not offer courses. Some department may offer many courses. A course must be offered by one and only one department.\n  Each section of a course has an instructor, semester, year, and section number. The section number distinguishes different sections of the same course that are taught during the same semester/year.\nA course has at least one section and can have many sections.\n  Relational data model and relational database constraints #  File: Ch 3 slides  For example,\n for an attribute like degree_program belonging to student, the domain may be {BA, BS, BE, PhD, MD}. for an attribute like department_number belonging to department, the domain may be {1, 2, 3, \u0026hellip;, 20}.  Schema #  These schemas don\u0026rsquo;t show anything about the actual instances, it is just the abstract structure.\nState #  All relations have\n schema state  An example state may look like:\nt1 = \u0026lt;'Benjamin Bayer', '305-61-2435', ..., 3.21\u0026gt; Values may be null if value is unknown or not applicable.\nTuples themselves are unordered, so changing their order is still considered the same state. Updating the values are considered a new state.\n"}),a.add({id:113,href:'/notes/CS134/CS134-lecture-20210608/',title:"CS134-lecture-20210608",section:"CS134",content:"RE assignment 1 #  account_number is a unique value.\nRelational model cont. #  State cont. #  R(color, bit) dom(color) = {blue, green, red} dom(bit) = {0, 1}    color bit     blue 0   blue 1   green 0   green 1   red 0   red 1    This is all the possible combinations, but lets say we have a state like\n   color bit     blue 1   green 0    Which visualizes that the state is a subset of all possible combinations.\nSpecifying an attribute\u0026rsquo;s value #  Constraints #  As a programmer we don\u0026rsquo;t have much of selection when it comes to model-based constraints.\nDDL = data definition language\nNote: We are not currently covering data dependencies.  Key constraints #  Versus a key, superkeys do not have to be minimal.\n {ssn, name} is a superkey {building, room_no} is a key, and a superkey  True or false\n Any superkey is a key  false   Any key is a superkey  true    Primary key #  We have two candidate keys license_number and engine_serial_number. We will need to pick 1 to be the primary key.\nNote on notation in relational model: we only underline the primary key.  Constraints on null values #  Entity integrity constraint #  Multiple relations – referential integrity constraints #  Foreign keys #  Foreign keys can be\n 1 attributes or,   \\( n \\)  attributes  The foreign key must\n have the same domain as the primary keys on the other schema. obey t1[foreign] = t2[primary]  DNO  \\( \\to \\)  DNUMBER is a foreign key with 1 attribute\nRemember, to be a foreign key, we need to verify that DNO and DNUMBER have the same domain. They do not have to have the same name.\nIf we change the requirement so that employees don\u0026rsquo;t have to work for a department, the keys must reference to existing attributes:\nBut if we have an employee that doesn\u0026rsquo;t have a department, we must put a null value:\nAnother example of a foreign key:\nNotice that foreign keys create duplication among tuples.\nApplication based constraints #  Triggers and assertions are part of SQL.\n"}),a.add({id:114,href:'/notes/CS134/CS134-lecture-20210609/',title:"CS134-lecture-20210609",section:"CS134",content:"Relational database schemas #  IC = integrity constraints\nRecall, a state is a collection of all the instances.\nExample of schema and state #  Valid/invalid state #  Update operations on relations #  Whenever we do any of these update operations, there is a chance that the constraints may be violated. These violations may propagate to other tables.\nREJECT is the most common action taken. CASCADE is also common, but requires setup in DBMS.\nRespective examples of these are\n Domain constraints are common from type mismatches Key constraints happen if you try to insert another tuple with an already used key Null values where they aren\u0026rsquo;t allowed Null values in a primary key slot References to things that don\u0026rsquo;t exist  Note: We will study these last 2 slides more later.  ER-to-relational model mapping #  File: Ch 3 Slides  This chapter is about going from our ER models to the relational model.\nEntities #  For example, consider this ER-diagram\nThis would be\nemployee(_ssn, salary, fname, minit, lname) as a relational model. We only use the composite attribute name in the conceptual level for semantics.\nNote: There is only one candidate key: ssn. I indicate the key with a leading underscore.  At this point, it is not case sensitive because we are still at the design level.\nConsider this ER-diagram\nThis would be\nclassroom(_building, _roomNo, capacity) as a relational model.\nNote on notation: I prepend an underscore on both building and roomNo to indicate they are a composite key. Normally they would both be underlined.  Recall only 1 primary key is allowed per relation.\nRelationships #  Consider this employee ER-diagram,\nWe will choose the entity with total participation to hold the foreign key,\nemployee( _ssn) ^ department(dname, _dnumber, mgrssn) Note on notation: The foreign key mgrssn should have an arrow drawn to ssn on employee. I indicate the arrow using the carrot ^.  If the relationship itself has a simple attribute, ie\nthen the attribute mgrstartdate should go in department (the entity with the foreign key).\nemployee( _ssn) ^ department(dname, _dnumber, mgrssn, mgrstartdate) The entity at the many side must include the foreign key to the other.\nConsider\nemployee(_ssn, salary, dno) v department(dname, _dnumber) The foreign key dno references to the primary key dnumber.\nIf the relationship works_for has an attribute, ie\nThen that attribute should also be where the foreign key is, ie\nemployee(_ssn, salary, dno, empstartdate) v department(dname, _dnumber) The reason we don\u0026rsquo;t have the department reference to the employee is because we will have many employees, and the department only has 1 foreign key.\nThe reason we don\u0026rsquo;t have employee have the foreign key for a project is because then it wouldn\u0026rsquo;t reflect the many-to-many relationship (an employee could only work on 1 project).\nWeak entities #  "}),a.add({id:115,href:'/notes/CS134/CS134-lecture-20210610/',title:"CS134-lecture-20210610",section:"CS134",content:"Relational model cont. #  Weak entity #  Notice that the employee will be the owner of the depending weak entity. The primary key will be part of the foreign key and the weak attribute.\nRemember,\n primary keys are underlined foreign keys have arrows pointing to the other reference  Multivalues attributes #  Consider this ER-diagram,\nWe can handle this in our relational model by creating another table called dept_locations,\nNote that the primary key of dept_locations is the combination of both dnumber and dlocation.\nA bigger example #  Consider\nIts good to start at a strong entity, so we\u0026rsquo;ll start with employee\nThen we\u0026rsquo;ll tackle the recursive supervision relationship, by creating a foreign key superssn that references to the ssn,\nNext we\u0026rsquo;ll do department\n we need to make dept_location to handle the multivalued attribute to handle the derived attribute we can either  use a trigger to handle the derived attribute (like number_of_employees), (taught in more depth in CS174) Ignore the derived attributes for now, which is what we\u0026rsquo;ll do    Now that we have both of those entities setup, we\u0026rsquo;re ready to do the 2 relationships works_for and manages,\nNote: The colors don\u0026rsquo;t have any meanings in relational models, just a preference from the Professor.  Next we need to do the entity project before we can do the relationship controls\nNote: The order of your attributes don\u0026rsquo;t have any meaning, you can list pnumber first if preferable.  We need a foreign key in project to note which department controls it\nNext we can add the many-to-many relationship works_on with a new table\n we added the primary key of works_on to be both essn and pno  We can now tackle the weak entity dependent\n we added a foreign key essn to reference to the employee primary key is essn and d_name  Overall,\nUniversity ER exercise #  Consider this ER-diagram\nNote: This is part of the weekly homework.  Relational algebra #  File: Relational algebra slides  Studying relational algebra will make our SQL skills better. It also gives a deeper understanding on how queries are processed. It is low level algebra presentation of a high level query.\nRecall that relational model is set based and bag based, so we don\u0026rsquo;t allow duplicates. It enables users to specify basic retrieval requests.\nSELECT #  For example if we\u0026rsquo;re looking for the employees from department number 5,\n  \\[\\begin{aligned} \\text{result } \\leftarrow \\sigma_{\\text{dno} = 5}(\\text{ employee }) \\end{aligned}\\]  and the result it stored.\nConsider that result for this table\nThe result emp_5 will be a new table (though not physically saved on the disk, just as a return result). For select, the structure of the new relation is the same as the input (this is not true for all operators).\nSo for each given tuple in the input, we are looking to see if it satisfies the condition dno = 5,\nThe result is a subset of the tuples.\nThere can be many conditions in each select operation. Multiple conditions can be put together with boolean operations.\nFor example if we want the department of the employee to be number 5, with salary \u0026gt; 30000\n \\[\\begin{aligned} \\text{result } \\leftarrow \\sigma_{\\text{dno} = 5 \\text{ and salary } \u0026gt; 30000}(\\text{ employee }) \\end{aligned}\\]  2 of the employees are returned (in blue).\nWe can do more complex selections, ie\n \\[\\begin{aligned} \\text{result } \\leftarrow \\sigma_{(\\text{dno} = 5 \\text{ and salary } \u0026gt; 30000) \\text{ or } (\\text{ dno} = 4 \\text{ and salary } \u0026gt; 25000)}(\\text{ employee }) \\end{aligned}\\]  "}),a.add({id:116,href:'/notes/CS134/CS134-lecture-20210614/',title:"CS134-lecture-20210614",section:"CS134",content:"Announcements\n Assignment 2 is posted   Relational algebra cont. #  SELECT cont. #  When cascaded: the conditions can be in different order but they will produce the same output. The conditions can be connected by logical and.\nIf we compose 2 select operations\n  \\[\\begin{aligned} \\sigma_{\\text{salary } \u0026gt; 7300} ( \\sigma_{\\text{dno = } 5 } (\\text{ employee })) \\end{aligned}\\]  We can combine the 2 conditions with a logical and\n \\[\\begin{aligned} \\sigma_{\\text{salary \u0026gt; 7300} \\text{ and } \\text{ dno } = 5 } (\\text{ employee }) \\end{aligned}\\]  Selection is a filter, so the input schema is the same as the output schema, however the number of tuples is equal to or less than the input.\nExercise #  This is part of the weekly exercise homework.    Retrieve each female employee  \\[\\begin{aligned} \\text{result} \\leftarrow \\sigma_{\\text{ sex = \u0026#39;F\u0026#39; }} ( \\text{ employee }) \\end{aligned}\\]    Retrieve each female employee whose salary is greater than 30000  \\[\\begin{aligned} \\text{result} \\leftarrow \\sigma_{\\text{ sex = \u0026#39;F\u0026#39; and salary \u0026gt; 30000}} ( \\text{ employee }) \\end{aligned}\\]    Projection operation #  In the projection operation, the input schema can be different than the output schema. It allows you to select certain columns and discard the other ones.\nProjection is notated using  \\( \\pi \\)  , for example\n \\[\\begin{aligned} \\pi_{\\text{\u0026lt;list\u0026gt;}}(R) \\end{aligned}\\]  Where\n  \\( \\text{list} \\)  is a list of attributes, and  \\( R \\)  is the entity  For example,\n \\[\\begin{aligned} \\text{result} \\leftarrow \\pi_\\text{\u0026lt;fname, lname, ssn\u0026gt;} (\\text{ employee }) \\end{aligned}\\]  Note that the output schema only has 3 columns.\nConsider\n \\[\\begin{aligned} \\text{result} \\leftarrow \\pi_\\text{\u0026lt;salary\u0026gt;} (\\text{ employee }) \\end{aligned}\\]  Our result will only have 1 columns.\nWe have 8 tuples, but 3 of them are 25000 (duplicates). By definition, relational model is set based (and so relational algebra is too), so we do not allow duplicate tuples. Any duplicate tuples will be removed in the returned table.\nThe attributes in the list must be a subset of the attributes of the entity.\nThe last projection is what really matters,\n \\[\\begin{aligned} \\text{result} \u0026amp;\\leftarrow \\pi_\\text{\u0026lt;fname\u0026gt;}(\\pi_\\text{\u0026lt;ssn, fname\u0026gt;} (\\text{ employee })) \\\\ \u0026amp;= \\pi_\\text{\u0026lt;fname\u0026gt;} (\\text{ employee }) \\end{aligned}\\]  Sequence of operations #  If we want to compose selection and projection:\n \\[\\begin{aligned} \\text{result} \u0026amp;\\leftarrow \\pi_\\text{\u0026lt;fname, lname, salary\u0026gt;} (\\sigma_\\text{dno = 5} (\\text{ employee })) \\\\ \\text{temp} \u0026amp;\\leftarrow \\sigma_\\text{dno = 5} (\\text{ employee }) \\\\ \\text{result} \u0026amp;\\leftarrow \\pi_\\text{\u0026lt;fname, lname, salary\u0026gt;} (\\text{ temp }) \\end{aligned}\\]  Rename operation #  We can use this operator to rename the output of an expression.\nIf  \\( R \\)  is a relation, we can rename the relation to  \\( S \\)  , and/or rename the attributes name one by one.\n \\[\\begin{aligned} \u0026amp;\\text{R} \\leftarrow \\pi_\\text{\u0026lt;fname, lname, salary\u0026gt;} (\\text{ employee }) \\\\ \u0026amp; \\rho_\\text{S (fn, ln, sal)} (\\text{R}) \u0026amp;\\text{new relation named S}\\\\ \u0026amp; \\rho_\\text{(fn, ln, sal)} (\\text{R}) \u0026amp;\\text{new relation still named R}\\\\ \u0026amp; \\rho_\\text{S}(\\text{R}) \u0026amp;\\text{new relation named S}\\\\ \u0026amp;\u0026amp;\\text{ but no new attribute names} \\end{aligned}\\]  Union operator #  No duplicates allowed, it is a set.\nFor example,\nExample\n \\[\\begin{aligned} \\text{dept5 emps} \u0026amp;\\leftarrow \\sigma_\\text{dno = 5} (\\text{ employee }) \\\\ \\text{result1} \u0026amp;\\leftarrow \\pi_\\text{ssn} (\\text{dept5 emps}) \\\\ \\text{result2}\\underbrace{(\\text{ssn})}_\\text{rename} \u0026amp;\\leftarrow \\pi_\\text{superssn} (\\text{dept5 emps}) \\\\ \\text{result} \u0026amp;\\leftarrow \\text{result1} \\cup \\text{result2} \\end{aligned}\\]  "}),a.add({id:117,href:'/notes/CS134/CS134-lecture-20210615/',title:"CS134-lecture-20210615",section:"CS134",content:"Assignment 1 solution #  Relational algebra cont. #  Intersection #  They must be union compatible.\n  \\[\\begin{aligned} a \\leftarrow \\text{student} \\cap \\text{instructor} \\end{aligned}\\]  Include in weekly homework.  Set difference #  Must be union compatible.\nThe result is a new relation with the same schema.\n \\[\\begin{aligned} a \\leftarrow \\text{student} - \\text{instructor} \\end{aligned}\\]   \\[\\begin{aligned} a \\leftarrow \\text{instructor} - \\text{student} \\end{aligned}\\]  This returns only John Smith.\nCommon properties #  Cartestian product #   \\[\\begin{aligned} R \\times S \\end{aligned}\\]  The results from  \\( R \\)  and  \\( S \\)  are combined.\nFor example\n \\[\\begin{aligned} Q \\leftarrow R \\times S \\end{aligned}\\]  Note: \\(R\\) and \\(S\\) are of different schema.  It is the combination of the first row of  \\( R \\)  with each row of  \\( S \\)  ,\nand it continues\nFor our amount of tuples (exhaustive combination):\n \\[\\begin{aligned} n_R = 3 \\\\ n_S = 2 \\\\ 3 \\times 2 = 6 \\end{aligned}\\]  Another example\nUse our given employee/department/etc schema for this problem.\n \\[\\begin{aligned} \\text{female emp} \\leftarrow \\sigma_\\text{sex = \u0026#39;F\u0026#39;} (\\text{ employee }) \\end{aligned}\\]   \\[\\begin{aligned} \\text{emp names} \\leftarrow \\pi_\\text{fname, lname, ssn}(\\text{ female emp }) \\end{aligned}\\]   \\[\\begin{aligned} \\text{emp dependents} \\leftarrow \\text{emp names} \\times \\text{dependent} \\end{aligned}\\]  Many of these combinations are meaningless right now. The actual employee/dependent combinations are when ssn == essn, so we need to do a selection\n \\[\\begin{aligned} \\text{actual dependents} \\leftarrow \\sigma_\\text{ssn=essn}(\\text{ emp dependents }) \\end{aligned}\\]  Finally, we can project to get the done result\n \\[\\begin{aligned} \\text{result} \\leftarrow \\pi_\\text{fname, lname, dependent name}(\\text{ actual dependents }) \\end{aligned}\\]  JOIN operation #   \\[\\begin{aligned} R \\underset{\\text{condition}}{\\bowtie} S \\end{aligned}\\]  It is the combination of a cartesian product followed by a selection.\nSo, looking back at our previous example\n \\[\\begin{aligned} \\text{actual dependents} \\leftarrow \\text{emp names} \\underset{\\text{ssn=essn}}{\\bowtie} \\text{dependents} \\end{aligned}\\]  It starts on the first employee, and combines with the first dependent. But we do not output to a intermediary table. It then checks if the condition is true, otherwise it ignores the tuple. It follows this same process and builds the result table.\n \\[\\begin{aligned} R \\underset{\\text{condition}}{\\bowtie} S = Q(A_1, A_2, \\ldots, A_n, B_1, B_2, \\ldots, B_m) \\end{aligned}\\]  Conditions\n have comparison can be combined using and/or  When we only have 1 condition with an equal size, it is called an equijoin, for example\n \\[\\begin{aligned} \\text{dept manager} \\leftarrow \\text{department} \\underset{\\text{mgrssn=ssn}}{\\bowtie} \\text{employee} \\end{aligned}\\]  An equijoin is guaranteed to have one or more pairs of attributes that have identical values (despite possibly not being named the same thing). If we throw out the duplicates, it is called a natural join.\n \\[\\begin{aligned} \\text{dept locs} \\leftarrow \\text{department} * \\text{dept locations} \\end{aligned}\\]  When the natural join is performed, any attributes with duplicate names are removed.\nYou could not perform this same join operation with the standard join operation  \\[ \\underset{\\text{dnumber=dnumber}}{\\bowtie} \\]  because there is ambiguity.\nNote on notation: the asterisk \\(*\\) is used to indicate natural join.  "}),a.add({id:118,href:'/notes/CS134/CS134-lecture-20210616/',title:"CS134-lecture-20210616",section:"CS134",content:"Relational algebra cont. #  Natural join cont #    \\[\\begin{aligned} \\text{dept locs} \\leftarrow \\text{department} * \\text{locations} \\end{aligned}\\]  Our natural join results in this table\nCommon mistakes when using join #  Its common to misuse join/natural join. Consider this example, if we have 2 entities,  \\( R \\)  and  \\( S \\)  :\n \\[\\begin{aligned} R(a, b) \u0026amp;\u0026amp; S(b, d, f) \\end{aligned}\\]  If we want to join on  \\( b \\)  , we can do the natural join:\n \\[\\begin{aligned} R * S \\end{aligned}\\]  While the incorrect answer is\n \\[\\begin{aligned} \\text{result} \\leftarrow R \\underset{\\text{b=b}}{\\bowtie} S \\end{aligned}\\]  because of ambiguity. Also, result will be a schema including 2 columns of  \\( b \\)  .\nIf we wanted to get rid of  \\( f \\)  in our joined table, we could start with a project\n \\[\\begin{aligned} \\text{new s} (\\text{newb, d}) \\leftarrow \\pi_\\text{b, d}(S) \\end{aligned}\\]  and then get the result with a join, because the attribute names are different now:\n \\[\\begin{aligned} \\text{result} \\leftarrow R \\underset{\\text{b=newb}}{\\bowtie} \\text{new s} \\end{aligned}\\]  Join selectivity #  Complete set of relational operations #  Example queries #   \\[\\begin{aligned} \\text{research dept} \u0026amp;\\leftarrow \\sigma_\\text{dname=\u0026#39;Research\u0026#39;}(\\text{ department }) \\\\ \\text{research emps} \u0026amp;\\leftarrow \\text{research dept} \\underset{\\text{dnumber=dno}}{\\bowtie} \\text{employee} \\\\ \\text{result} \u0026amp;\\leftarrow \\pi_\\text{fname, lname, address}(\\text{ research emps }) \\end{aligned}\\]  Include following exercise in weekly homework  Question: For every project located in \u0026ldquo;stafford\u0026rdquo;, list the project number, the controlling department number, and the department managers\u0026rsquo;s last name, address, and birthdate.\n \\[\\begin{aligned} \\text{stafford projects} \u0026amp;\\leftarrow \\sigma_\\text{plocation=\u0026#39;stafford\u0026#39;}(\\text{ project }) \\\\ \\text{control dept} \u0026amp;\\leftarrow \\text{stafford projects} \\underset{\\text{dnum=dnumber}}{\\bowtie} \\text{department} \\\\ \\text{project dept mgr} \u0026amp;\\leftarrow \\text{control dept} \\underset{\\text{mgrssn=ssn}}{\\bowtie} \\text{employee} \\\\ \\text{result} \u0026amp;\\leftarrow \\pi_\\text{pnumber, dnum, lname, address, bdate}(\\text{ projec dept mgr }) \\end{aligned}\\]    \\[\\begin{aligned} \\text{emps with deps} \u0026amp;\\leftarrow \\pi_\\text{essn}(\\text{ dependent }) \\\\ \\text{all emps} \u0026amp;\\leftarrow \\pi_\\text{ssn}(\\text{ employee }) \\\\ \\text{emps without deps} \u0026amp;\\leftarrow \\text{all emps} - \\text{emps with deps} \\\\ \\text{result} \u0026amp;\\leftarrow \\pi_\\text{lname,fname} (\\text{emps without deps} * \\text{employee}) \\end{aligned}\\]  Note: employee and emps with deps must be union compatible to take the difference.   Another exercise with the same schema\nInclude following exercise in weekly homework  List the names (first name, last name) of managers who have at least one dependent.\nFirst approach uses set operations:\n \\[\\begin{aligned} \\text{mgr(ssn)} \u0026amp;\\leftarrow \\pi_\\text{mgrssn} (\\text{ department }) \\\\ \\text{emp with dep(ssn)} \u0026amp;\\leftarrow \\pi_\\text{essn} (\\text{ dependent }) \\\\ \\text{mgr with deps} \u0026amp;\\leftarrow \\text{mgr} \\cap \\text{emp with deps} \\\\ \\text{result} \u0026amp;\\leftarrow \\pi_\\text{lname, fname} (\\text{mgr with deps} * \\text{employee}) \\end{aligned}\\]  Another approach using join:\n \\[\\begin{aligned} \\text{mgr dep} \u0026amp;\\leftarrow \\pi_\\text{essn} (\\text{department} \\underset{\\text{mgrssn=essn}}{\\bowtie} \\text{dependent}) \\\\ \\text{emp mgr dep} \u0026amp;\\leftarrow \\text{employee} \\underset{\\text{ssn=essn}}{\\bowtie} \\text{mgr dep} \\\\ \\text{result} \u0026amp;\\leftarrow \\pi_\\text{fname, lname} (\\text{ emp mgr dep }) \\end{aligned}\\]  "}),a.add({id:119,href:'/notes/CS134/CS134-lecture-20210617/',title:"CS134-lecture-20210617",section:"CS134",content:"Notes on upcoming exam #  The join symbol on canvas will be represented as\nSQL #  File: SQL Slides  We can use SQL to implement our relational models in code.\nHistory #  We will be covering the SQL core.\n DDL = data definition language, this corresponds to our relational model. insert, delete, update query  DBMS should implement all of the SQL standards, but they may not in some places.\nCREATE TABLE #  In SQL, we call our relations \u0026ldquo;tables\u0026rdquo;.\nCREATE TABLE DEPARTMENT( DNAME VARCHAR(10) NOT NULL, DNUMBER INTEGER NOT NULL, MGRSSN CHAR(9), MGRSTARTDATE CHAR(9) );  The variable names are followed by their domain, ie VARCHAR(10) or INTEGER. We can also specify the NOT NULL constraint for mandatory attributes.  Type definitions can be different depending on the DBMS.\nCREATE TABLE DEPARTMENT( DNAME VARCHAR(10) NOT NULL, DNUMBER INTEGER NOT NULL CHECK (DNUMBER \u0026gt; 0 AND DNUMBER \u0026lt; 21), MGRSSN CHAR(9), MGRSTARTDATE DATE, PRIMARY KEY (DNUMBER), UNIQUE (DNAME), FOREIGN KEY (MGRSSN) REFERENCES EMPLOYEE (SSN) );  VARCHAR(10) means a variable length string, up to 10 We can specify the size of integers after CHECK We can specify primary key using PRIMARY KEY. We also explicitly specify that the primary key is NOT NULL. We can specify that the department name is unique using UNIQUE, this means that the department name is a candidate key (even though we picked department number as the primary key). Multiple attributes can be specified inside a UNIQUE, delimited by commas. We can specify foreign keys and where they reference using FOREIGN KEY.  The DBMS will enforce these constraints for you when inserting tuples.\nReferential integrity options #  When we delete or update, these options can specify the behavior on a constraint violation.\nFor example\n-- inside CREATE TABLE EMPLOYEE  DNO INT NOT NULL DEFAULT 1, FOREIGN KEY (DNO) REFERENCES DEPARTMENT (DNUMBER) ON DELETE SET DEFAULT ON UPDATE CASCADE, -- ...  We can specify the default values using DEFAULT If we were adding an employee with a department number that doesn\u0026rsquo;t exist, the DBMS would reject the operation by default. But by adding our referential integrity options after the reference, we can specify more operations when that violation happens.  ON DELETE SET DEFAULT  ON DELETE is the event SET DEFAULT is the action.  These actions are performed in the table itself. So if a department is deleted, and we don\u0026rsquo;t do anything we\u0026rsquo;ll have a dangling reference. So any employee will have its department number set to the default value specified.\n ON UPDATE CASCADE  ON UPDATE is the event CASCADE is the action  ON UPDATE is the event that happens when a department\u0026rsquo;s number is changed. The action CASCADE means that we\u0026rsquo;ll follow the original number and cascade the changes. That way the employee\u0026rsquo;s foreign key is updated properly, and isn\u0026rsquo;t dangling.\n  Note: If we did something like ON DELETE CASCADE, it would delete both the department number and the employees with that foreign key will be deleted as well. Everything referenced to it will be deleted.  In MySQL, the syntax is\nforeign key (DNO) references DEPARTMENT (DNUMBER) on delete restrict on update no action For our events, we can do\n restrict is the same as rejecting the operation cascade set null no action  Note: MySQL may or may not be case sensitive, it depends on the host. We will use MySQL on a linux system, so it is case sensitive (table name / attribute names must be full caps).  Naming constraints #  DROP TABLE #  Allows us to remove tables.\nDROP TABLE DEPENDENT; The DBMS will check if anything is using the DEPENDENT table, and if so it will reject the operation. If your intent is to drop that table and all of its references, those references must be dropped first.\nNote: It is suggested not to use RESTRICT and CASCADE when dropping tables. Some DBMS do not support them, MySQL doesn\u0026rsquo;t change its behavior if they are included.  Order to create and drop tables #  If we are creating both employee and department, we want to create department first because employee will have a foreign key referencing department.\nCREATE TABLE DEPARTMENT( -- attributes ); CREATE TABLE EMPLOYEE( -- attributes with foreign key referencing DEPARTMENT ); When we are dropping tables, we want to drop the employee first, then the department. We need to do it in this order because dropping the department will be rejected by default because some employees reference it.\nDROP TABLE EMPLOYEE; DROP TABLE DEPARTMENT; ALTER TABLE #  We can use ALTER in place of dropping then recreating.\nWe can add an additional attribute like\nALTER TABLE EMPLOYEE ADD JOB VARCHAR(12); If we want to drop the address in an employee:\nALTER TABLE EMPLOYEE DROP ADDRESS; Or we can change defaults for attributes\n-- remove the default for MGRSSN ALTER TABLE DEPARTMENT ALTER MGRSSN DROP DEFAULT; -- set a new default for MGRSSN ALTER TABLE DEPARTMENT ALTER MGRSSN SET DEFAULT \u0026#39;122444444\u0026#39;; "}),a.add({id:120,href:'/notes/CS134/CS134-lecture-20210621/',title:"CS134-lecture-20210621",section:"CS134",content:"Assignment 2 solution #  Assignment 3 solutions #  SQL cont. #  INSERT #  The attributes (VALUES) are listed one by one in the same order as when the table was declared. If they are put in the wrong order the attributes will go into the wrong places (or violate domain constraints). You can specify the attributes and their order is\nINSERT INTO EMPLOYEE(FNAME, LNAME, SSN, DNO) VALUES (\u0026#39;Richard\u0026#39;, \u0026#39;Marini\u0026#39;, \u0026#39;1932914921\u0026#39;, 4) The attributes that are not null must be specified in the command. Attributes not supplied will go to their default value (or null if no default specified).\nNote: We will skip this slide because we haven\u0026rsquo;t covered queries yet.  DELETE #  Examples\nDELETE FROM EMPLOYEE WHERE LNAME=\u0026#39;Brown\u0026#39; Deletes all employees who have the last name \u0026ldquo;Brown\u0026rdquo;.\nDELETE FROM EMPLOYEE WHERE SSN=\u0026#39;123456789\u0026#39; Deletes all employees who have the ssn 123456789.\nDELETE FROM EMPLOYEE Since this doesn\u0026rsquo;t have a WHERE clause, it is the same as saying WHERE TRUE, so all employees will be deleted from the table. The table will still exist (as opposed to DROP, where all the tuples would be deleted and the table itself would be deleted).\nUPDATE #  Used to change values in existing tuples.\nUPDATE PROJECT SET PLOCATION=\u0026#39;Bellaire\u0026#39;, DNUM=5 WHERE PNUMBER=10 This will update each location and department number of all projects who have project number 10.\nQueries #  There are 6 clauses used in SQL queries, we will first talk about these 3.\n SELECT takes a list of attributes FROM takes a list of tables WHERE takes a condition, a filter  Consider the usual company schema,\n  Retrieve the birthdate and address of the employee whose name is \u0026lsquo;John B. Smith\u0026rsquo;.\nSELECT BDATE, ADDRESS FROM EMPLOYEE WHERE FNAME=\u0026#39;John\u0026#39;, AND MINIT=\u0026#39;B\u0026#39;, AND LNAME=\u0026#39;Smith\u0026#39;   Note: While relational algebra and relational model is set based, in SQL it is bag based. So by default a query result is a bag of tuples (duplicates are allowed).   Retrieve the name and address of all employees who work for the \u0026lsquo;Research\u0026rsquo; department.\nSELECT FNAME, LNAME, ADDRESS FROM EMPLOYEE, DEPARTMENT WHERE DNUMBER=DNO AND DNAME=\u0026#39;Research\u0026#39;   For every project located in \u0026lsquo;Stafford\u0026rsquo;, list the project number, the controlling department number, and the department manager\u0026rsquo;s last name, and birthdate.\nInclude this in the weekly exercise.  SELECT PNUMBER, DNUM, LNAME, BDATE FROM PROJECT, DEPARTMENT, EMPLOYEE WHERE DNUM=DNUMBER AND MGRSSN=SSN AND PLOCATION=\u0026#39;Stafford\u0026#39;   Qualify attribute name #  If we have ambiguous attribute names we can use the entity name and a dot operator to specify which attributes we need.\nFor example, since DNUMBER is ambiguous when joining department and dept_locations,\nSELECT DNAME, DLOCATION FROM DEPARTMENT, DEPT_LOCATIONS WHERE DEPARTMENT.DNUMBER=DEPT_LOCATIONS.DNUMBER "}),a.add({id:121,href:'/notes/CS134/CS134-lecture-20210623/',title:"CS134-lecture-20210623",section:"CS134",content:"MySQL assignment 4 #  Note\n Login to MySQL server using csus username (ssh) MySQL on this server is case sensitive  SQL cont. #  Aliases #  Aliases are other names for a table.\nConsider our normal company schema,\nSELECT DNAME, L.DLOCATION FROM DEPARTMENT AS D, DEPT_LOCATION AS L WHERE D.DNUMBER=L.DNUMBER; Here\n D is an alias for DEPARTMENT L is an alias for DEPT_LOCATION  To make 2 aliases of one entity:\nSELECT E.FNAME, E.LNAME, S.FNAME, S.LNAME FROM EMPLOYEE AS E, EMPLOYEE AS S WHERE E.SUPERSSN=S.SSN; Note: MySQL requires the keyword AS for aliases  Unspecified WHERE clause #  The WHERE clause is optional. Omitting it is the same as WHERE TRUE.\nTo emulate a Cartesian product,\nSELECT SSN,DNAME FROM EMPLOYEE, DEPARTMENT; -- no where clause * operator #  If we want to view all the columns of a table we can use the * operator, ie\nSELECT * FROM STUDENT; If we want to just see all the tables,\nSHOW TABLES Use of DISTINCT #  To convert a bag into a set, we can remove all duplicates. In SQL, we can use the keyword DISTINCT to remove any duplicate tuples.\nSELECT SALARY FROM EMPLOYEE; -- returns a bag  SELECT DISTINCT SALARY FROM EMPLOYEE; -- returns a set Set operations #  EXCEPT is the same as set difference. Note that entities must be union compatible, meaning\n both entities must have the same attributes, and both entities attribute\u0026rsquo;s must appear in the same order  Note: UNION ALL, EXCEPT ALL, and INTERSECT ALL are bag operations, and need not be studied in 134.  UNION example #  Using our same company schema,\n(SELECT DISTINCT PNUMBER FROM PROJECT, DEPARTMENT, EMPLOYEE WHERE DNUM=DNUMBER AND MGRSSN=SSN AND LNAME=\u0026#39;Smith\u0026#39;) UNION (SELECT DISTINCT PNUMBER FROM PROJECT, WORKS_ON, EMPLOYEE WHERE PNUMBER=PNO AND ESSN=SSN AND LNAME=\u0026#39;Smith\u0026#39;);  the result is in the union between workers and managers  Arithmetic operations #  Show the salary of employees with a 10% raise who work on the ProductX project:\nSELECT FNAME, LNAME, 1.1 * SALARY AS INCREASED_SAL FROM EMPLOYEE, WORKS_ON, PROJECT WHERE SSN=ESSN AND PNO=PNUMBER AND PNAME=\u0026#39;ProductX\u0026#39;  this will calculate 1.1 * SALARY an assign it the alias INCEASED_SAL, and it will be a column in the selected table  So are the salaries actually different after the query has been executed? The answer is no, this is just a temporary calculated column. SELECT is a read operation.\nSubstring pattern matching #  LIKE is a powerful operator to do pattern matching.\n The % is like a wildcard character The _ is a single character wildcard  ORDER BY #  A new clause, ORDER BY is used to sort the selected tuples. After a WHERE clause you can add a ORDER BY clause to specify the sort of the returned table.\nSELECT DNAME, LNAME, FNAME, PNAME FROM DEPARTMENT, EMPLOYEE, WORKS_ON, PROJECT WHERE DNUMBER=DNO AND SSN=ESSN AND PNO=PNUMBER ORDER BY DNAME DESC, LNAME ASC, FNAME ASC;  DESC means descending ASC means ascending, the default the tuples always remains together when being sorted  if there is a tie between 2 attributes in DNAME, then the tie is broken between LNAME if there is a tie in LNAME, then the tie is broken between FNAME    Nesting of queries #  Retrieve the name and address of all employees who work for the \u0026lsquo;Research\u0026rsquo; department\nSELECT FNAME, LNAME, ADDRESS FROM EMPLOYEE WHERE DNO IN (SELECT DNUMBER FROM DEPARTMENT WHERE DNAME=\u0026#39;Research\u0026#39;); The IN operator allows nesting of queries. Notice that the sub query will return a bag of tuples, and the result should be a single attribute, DNUMBER. When the outer SELECT is going through tuples, it is going to check if the current tuple\u0026rsquo;s DNO is in the bag of tuples returned by the sub query.\n"}),a.add({id:122,href:'/notes/CS134/CS134-lecture-20210624/',title:"CS134-lecture-20210624",section:"CS134",content:"SQL cont. #  Comparison operators #  To list all the names of employees whose salary is greater than the salary of all the employees in department 5:\nSELECT e1.lname, e1.fname FROM employee AS e1 WHERE e1.salary \u0026gt; ALL (SELECT e.salary FROM employee AS e WHERE e.dno=5);  it is suggested to use aliases when using nested queries if instead our where clause was E1.SALARY \u0026gt; some (..., it doesn\u0026rsquo;t need to be greater than all items in bag, just some (1 is enough).  EXISTS #  Often we want to check whether the result of a query is empty.\nRetrieve the name of each employee who has a dependent with the same first name as the employee.\nSELECT e.fname, e.lname FROM employee AS e WHERE EXISTS (SELECT * FROM dependent AS d WHERE d.essn=e.ssn AND d.dependent_name=e.fname);  if there are any tuples returned by the inner query, the exists will return true and the outer query was select the current employee the inner query can use the outer query\u0026rsquo;s variables we select * in the inner query to get the entire table back  Include the next example in the weekly homework  Retrieve the names of employees who have no dependents.\nSELECT e.fname, e.lname FROM employee AS e WHERE NOT EXISTS (SELECT * FROM dependent AS d WHERE d.essn=e.ssn); Explicit sets #  SELECT DISTINCT essn FROM works_on WHERE pno IN (1, 2, 3);  an easy way to explicitly declare a set  Renaming aliases #  Joined tables #  SELECT fname, lname, address FROM employee JOIN department ON dnumber=dno WHERE dname=\u0026#39;Research\u0026#39;;  not all DBMS has support for JOIN, however MySQL does have support.  JOIN on its own is the same as INNER JOIN.\nSELECT fname, lname, dname FROM employee LEFT OUTER JOIN department ON ssn=mgrssn;  INNER JOIN gets rid of the items that don\u0026rsquo;t match LEFT OUTER JOIN puts null values for items that don\u0026rsquo;t exist in the left table RIGHT OUTER JOIN puts null values for items that don\u0026rsquo;t exist in the right table the left and right tables are respective positions: left JOIN right  Aggregation functions #  Find the maximum salary, the minimum salary, and the average salary among all employees.\nSELECT MAX(salary), MIN(salary), AVG(salary) FROM employee Include the next example in weekly homework  Find the maximum salary, the minimum salary, and the average salary among employees who work for the \u0026lsquo;Research\u0026rsquo; department.\nSELECT MAX(salary), MIN(salary), AVG(salary) FROM employee, department WHERE dno=dnumber AND dname=\u0026#39;Research\u0026#39;; Retrieve the total number of employees in the company.\nSELECT COUNT(*) FROM employee; Consider these 2 queries\n-- amount of different salaries SELECT COUNT(DISTINCT salary) FROM employee; -- amount of all employees with salary SELECT COUNT(salary) FROM employee; Retrieve the number of employees in the \u0026lsquo;Research\u0026rsquo; department\nSELECT COUNT(*) FROM employee, department WHERE dno=dnumber AND dname=\u0026#39;Research\u0026#39;; Retrieve the names of all employees who have two or more dependents.\nSELECT e.lname, e.fname FROM employee AS e WHERE (SELECT COUNT(*) FROM dependent AS d WHERE e.ssn=d.essn) \u0026gt;= 2;  when COUNT returns the value, it is a single row/column in a table. This is a special case where you can compare the table directly to the interger 2. you cannot use a comparison in a SELECT statement  "}),a.add({id:123,href:'/notes/CS134/CS134-lecture-20210628/',title:"CS134-lecture-20210628",section:"CS134",content:"SQL cont. #  Aggregate functions cont. #  Include in weekly assignment.  List each employee(ssn, fname, lname) who has more than 3 daughters and the salary of the employee is less than 60000.\nSELECT e.ssn, e.fname, e.lname FROM employee AS e WHERE e.salary \u0026lt; 60000 AND (SELECT COUNT(*) FROM dependent AS dep WHERE e.ssn=dep.essn AND dep.relationship=\u0026#39;daughter\u0026#39;) \u0026gt; 3; GROUP BY clause #  A clause GROUP BY is used to create sub groups. This allows us to do some operations within a specific sub group.\nThe attributes being grouped by must appear in the select clause:\nSELECT x, y -- from ... GROUP BY x, y For each department, retrieve the department number, the number of employees in the department, and their average salary.\nSELECT dno, COUNT(*), AVG(salary) FROM employee GROUP BY dno HAVING clause #  Since the WHERE clause comes before the GROUP BY clause, if we want to filter the results of the grouping, we can use the HAVING clause. This allows us to filter the results of the grouping by making sure each sub group satisfies the condition after the HAVING clause.\n it is okay to have a GROUP BY clause without a HAVING it is not okay to have a HAVING clause without a GROUP BY  For each department which has more than two employees, retrieve the department number, the number of employees in the department, and their average salary.\nSELECT dno, COUNT(*), AVG(salary) FROM employee GROUP BY dno HAVING COUNT(*) \u0026gt; 2; Summary of SQL queries #  The optional clauses are surrounded in square brackets [].\nIn class exercise #  Retrieve the department name if the lowest employee salary of the department is greater than 50000. List department name and lowest salary.\nSELECT dname, MIN(salary) FROM department, employee WHERE dno=dnumber GROUP BY dname HAVING MIN(salary) \u0026gt; 50000; Another solution to a previous problem #  Our previous problem can be solved using our new clauses:\nList each employee(ssn, fname, lname) who has more than 3 daughters and the salary of the employee is less than 60000.\nSELECT ssn, fname, lname FROM employee, department WHERE ssn=essn AND relationship=\u0026#39;daughter\u0026#39; AND salary \u0026lt; 60000 GROUP BY ssn, fname, lname HAVING COUNT(*) \u0026gt; 3; Returning to earlier problems we skipped #  Before we skipped the delete statement with the subquery.\nDELETE FROM employee WHERE dno IN (SELECT dnumber FROM department WHERE dname=\u0026#39;Research\u0026#39;); We can also use a subquery in an UPDATE:\nUPDATE employee SET salary=salary*1.1 WHERE dno IN (SELECT dnumber FROM department WHERE dname=\u0026#39;Research\u0026#39;); We can use a subquery in an insert statement:\nCREATE TABLE dept_info( dept_name VARCHAR(10), no_of_emps INTEGER, total_sal INTEGER ); INSERT INTO dept_info (dept_name, no_of_emps, total_sal) SELECT dname, COUNT(*), SUM(salary) FROM department, employee WHERE dnumber=dno GROUP BY dname;  the result of the subquery will be inserted into the dept_info table\u0026rsquo;s values.  "}),a.add({id:124,href:'/notes/CS134/CS134-lecture-20210629/',title:"CS134-lecture-20210629",section:"CS134",content:"SQL cont. #  Subqueries can be used inside insert statements:\nThis insert statement will update the numbers dynamically based on the response from the subquery. The next time an employee is inserted, we can run this insert statement to update DEPTS_INFO using a trigger.\nOr, we can use views\u0026hellip;\nVirtual table view #  CREATE VIEW dept_info_view AS SELECT dname, COUNT(*) AS no_of_emps, SUM(salary) AS total_sal FROM department, employee WHERE dnumber=dno GROUP BY dname; This results in a self updating table, called a view:\nWe can query the view the same way we\u0026rsquo;d query a table.\nSELECT * FROM dept_info_view; The views are maintained by the DBMS. The views will be automatically updated, to main consistency between the view and the table being viewed. This is a way we can have derived attributes.\nNote: Views are covered more in depth in CS174.  Functional dependencies and normalization #  File: Normalization slides  Formal measures are also called normal forms. To understand normal forms, we will start with functional dependency.\nFunctional dependencies #    \\[\\begin{aligned} X \\to Y \\end{aligned}\\]    \\( X \\)  and  \\( Y \\)  are sets of attributes  The functional dependency means that if 2 tuples share the same  \\( X \\)  value for an attribute, it means they also share the same  \\( Y \\)  value for an attribute.\nWhen  \\( X \\)  and  \\( Y \\)  are sets of a single item, they may be commonly notated like\n \\[\\begin{aligned} \\text{ssn} \\to \\text{ename} \\end{aligned}\\]  So if 2 tuples share the same  \\( \\text{ssn} \\)  , they will share the same  \\( \\text{ename} \\)  .\nArmstrong\u0026rsquo;s inferences rules #    For reflexivity, if  \\[\\begin{aligned} \\{\\text{ssn}\\} \\subseteq \\{\\text{ssn,ename}\\} \\end{aligned}\\]  then  \\[\\begin{aligned} \\{\\text{ssn,ename}\\} \\to \\text{ssn} \\end{aligned}\\]    For augmentation, if  \\[\\begin{aligned} \\text{ssn} \\to \\text{ename} \\end{aligned}\\]  we can add something to both sides, and it still holds  \\[\\begin{aligned} \\{\\text{ssn, address}\\} \\to \\{\\text{ename, address}\\} \\end{aligned}\\]    For transitivity,    For decomposition, if  \\[\\begin{aligned} \\text{ssn} \\to \\{\\text{ename, bdate, address}\\} \\end{aligned}\\]  then we also know  \\[\\begin{aligned} \\text{ssn} \u0026amp;\\to \\text{ename} \\\\ \\text{ssn} \u0026amp;\\to \\text{bdate} \\\\ \\text{ssn} \u0026amp;\\to \\text{address} \\\\ \\text{ssn} \u0026amp;\\to \\{\\text{ename, bdate}\\} \\\\ \\text{ssn} \u0026amp;\\to \\{\\text{bdate, address}\\} \\\\ \\text{ssn} \u0026amp;\\to \\{\\text{ename, address}\\} \\\\ \\end{aligned}\\]   Union is the opposite of the decomposition above Pseudotransitivity is the transitivity between decomposed sets above  Closure #  Each element of the set  \\( F \\)  is a functional dependency. The set  \\( F^\u0026#43; \\)  is all the dependencies in  \\( F \\)  , plus all the dependencies that can be inferred from  \\( F \\)  .\nThe set  \\( X^\u0026#43; \\)  is the set of attributes that are functionally deteremined by  \\( X \\)  based on  \\( F \\)  .\nEquivalence #  Minimal sets #  Normalization #  There are 4 normal forms we will study: 1NF, 2NF, 3NF, BCNF. The higher the number, the more strict the form.\nKeys and superkeys #   any key is a superkey  First normal form #  Since the Research department has a set of locations, it is not in first normal form. We can put it in first normal form by using decomposition.\n The disadvantage to solution 2 is that the department name and manager\u0026rsquo;s ssn is repeated for each location. The disadvantage to solution 3 is that any tuple that doesn\u0026rsquo;t have exactly 3 locations will have a lot of null values in the table. Also the schema would needed to be modified if a department needed 4 locations.  "}),a.add({id:125,href:'/notes/CS134/CS134-lecture-20210702/',title:"CS134-lecture-20210702",section:"CS134",content:"Normalization cont. #  We can also use an alternate notation to indicate dependencies:\nIf we remove the ssn then the dependency is no longer true.\nSecond normal form #  An attribute that is part of any candidate key is a prime attribute. If we have a relation   \\[\\begin{aligned} R(a, b, c, d, e) \\end{aligned}\\]  and our candidate keys are  \\( \\{a,b\\} \\)  and  \\( c \\)  , that means our prime attributes are  \\( a,b,c \\)  .\nAny attribute that isn\u0026rsquo;t a prime attribute is called an non-prime attribute, that is it is not part of any candidate key. So our non-prime attributes from the last example are  \\( d,e \\)  .\n A relational schema  \\( R \\)  is in second normal form if every non-prime attribute  \\( A \\)  in  \\( R \\)  is fully functionally dependent on every key of  \\( R \\)  .\n  FD1. if we know the PROPERTY_ID then we also know the attributes COUNTY_NAME, LOT#, AREA, PRICE, TAX_RATE FD2. if we know the COUNTY_NAME and LOT#, then we also know the attributes PROPERTY_ID AREA PRICE TAX_RATE FD3. if we know the COUNTY_NAME, then we also know the TAX_RATE  So is this in second normal form?\n Our non-prime attributes are AREA PRICE and TAX_RATE, we need to go through and make sure each of these non-prime attributes are fully functional on the keys.  Is AREA fully functionally dependent on PROPERTY_ID?  \\[ \\begin{aligned} \\text{property id} \\to \\text{area} \\end{aligned} \\]  Yes, because we cannot remove anything from the left hand side and have the dependency hold true. (Any attribute that depends on a single key will automatically be fully functionally dependent). The rest of the non-prime attributes are fully functionally dependent on PROPERTY_ID for the same reason as above Next we need to check if the non-primes are fully functionally dependent on the key {COUNTY_NAME, LOT#}  \\[ \\begin{aligned} \\{ \\text{county name, lot num} \\} \\to \\text{area} \\end{aligned} \\]  If we remove LOT# will this dependency still hold true? Yes, this is fully functionally dependent. (If there was another dependency COUNTY_NAME  \\( \\to \\)  AREA then it would still hold true).  \\[ \\begin{aligned} \\{ \\text{county name, lot num} \\} \\to \\text{price} \\end{aligned} \\]  This is also fully functionally dependent for the same reason.  \\[ \\begin{aligned} \\{ \\text{county name, lot num} \\} \\to \\text{tax rate} \\end{aligned} \\]  This is not fully functionally dependent because if we remove LOT#, there still exists a dependency COUNTY_NAME  \\( \\to \\)  TAX_RATE (FD3).   Therefore, this is not in second normal form because non-prime attribute TAX_RATE is not fully functionally dependent on key {COUNTY_NAME, LOT#}.  Note: As soon as you find a single non-prime attribute that is not fully functionally dependent on a key you can immediately see it is not in second normal form.  In class exercise #  Include this in weekly homework.  Consider the relation\n \\[\\begin{aligned} R(A, B, C, D, E) \\end{aligned}\\]  where the keys are  \\( \\{A,B\\}, \\{C,D\\} \\)  , and the dependencies are\n \\[ \\{A,B\\} \\to \\{C,D,E\\}\\\\ \\{C,D\\} \\to \\{A, B, E\\}\\]  Is  \\( R \\)  in second normal form?\n The non-prime attribute is  \\( E \\)  . So is  \\( E \\)  fully functional on all keys?  Is  \\( E \\)  fully functionally dependent on  \\( \\{A,B\\} \\)  ? Yes. Is  \\( E \\)  fully functionally dependent on  \\( \\{C,D\\} \\)  ? Yes.   Therefore,  \\( R \\)  is in second normal form.  Include this in weekly homework.  Consider the relation  \\[\\begin{aligned} R(A, B, C, D) \\end{aligned}\\]  with key  \\( \\{A,B\\} \\)  Is  \\( R \\)  in second normal form?\nNo, because we can remove  \\( B \\)  from the dependency  \\[\\begin{aligned} \\{A,B\\} \\to D \\end{aligned}\\]  and still fulfill the depdendency via  \\[\\begin{aligned} A \\to B \\end{aligned}\\]  So,  \\( R \\)  is not in second normal form.\nThird normal form #  Third normal form is easier to check than second normal form.\n A relational schema  \\( R \\)  is in third normal form if, whenever a non-trivial functional dependency  \\( X \\to A \\)  holds in  \\( R \\)  , then either\n  \\( X \\)  is a superkey of  \\( R \\)  , or  \\( A \\)  is a prime attribute of  \\( R \\)     Recall, any key is a superkey:\n So is this schema in third normal form?\n First we should check to see if FD1 has any violation  Check left hand set {PROPERTY_ID}: Is this a superkey? Yes.   Check if FD2 has any violation  Check left hand set {COUNTY_NAME, LOT#}: Is this a superkey? Yes.   Check if FD4 has any violation  Check left hand set {AREA}: Is this a superkey? No. Check right hand set {PRICE}: Is this a prime attribute? No.   Therefore, since we had a violation, this schema is not in third normal form.  In class exercise #  Include in weekly homework.  Is this schema in third normal form?\n Check FD1  Left hand set is a superkey, good.   Check FD2  Left hand set is a superkey, good.   Check FD5  Left hand set is not a superkey\u0026hellip; Right hand set is a prime attribute, good.   Therefore, this schema is in third normal form.  Boyce-Codd normal form (BCNF) #  This is the highest normal form we will study.\n A relational schema  \\( R \\)  is in Boyce-Codd Normal Form (BCNF) if whenever a nontrivial functional dependency  \\( X \\to A \\)  holds in  \\( R \\)  , then  \\( X \\)  is a superkey of  \\( R \\)  .\n This is a stricter version of the third normal form, it only checks the first condition.\nIs this schema in BCNF?\n Check FD1  Left hand set is a superkey, good.   Check FD2  Left hand set is a superkey, good.   Check FD5  Left hand set is not a superkey.   Therefore, this schema is not in BCNF.  Normal form examples #  If we have the relation  \\[\\begin{aligned} R(A, B, C, D, E) \\end{aligned}\\]  with key  \\( \\{A,B\\} \\)  , and we have these dependencies:\nWhich normal form is  \\( R \\)  in? Why?\n Is  \\( R \\)  in BCNF?  FD1: left hand set is a superkey? Yes FD2: left hand set is a superkey? No Not in BCNF   Is  \\( R \\)  in third normal form?  FD1: left hand set is a superkey? Yes FD2: left hand set is a superkey? No. Right hand set prime attribute? Yes Passed third normal form checks    Therefore,  \\( R \\)  is in third normal form.\nNote: We can check normal forms in increasing or decreasing order.  Storage #  File: Storage slides  Now that we\u0026rsquo;ve finished studying implementation, we will look at physical storage. We will look closer at how a DBMS accesses files on disk.\nSpecific file format meant for read/write by the DBMS.\nPhysical storage #  Records #  Record spanning #  File headers #  File operations #  Record ordering #  Moving items when deleting from the middle, ie\ncan be really expensive. So instead we put a marker for deletion in place\nOnce there are a lot of markers in a block, space will have to be reorganized.\n This file spans multiple blocks It is sorted by name If we search based by name, we can use binary search, resulting in  \\( O(\\lg n) \\)  time complexity. If we search by salary, best we can do is a linear search, resulting in  \\( O(n) \\)  time complexity.  If we order by salary, then we could use a binary search.    "}),a.add({id:126,href:'/notes/CS134/CS134-lecture-20210707/',title:"CS134-lecture-20210707",section:"CS134",content:"Storage cont. #  Sorted files cont. #  Since inserting into a ordered structure is expensive, we keep track of new inserts in a separate file.\nMaster files are ordered, overflow file are unordered.\nNew inserts go to the overflow file.\nWhen we search:\n Start by searching the ordered master file,   \\( O(\\lg n) \\)   If we don\u0026rsquo;t find it, it is possible that it is in the overflow file   Search the unordered overflow file,  \\( O(n) \\)  however it is a small file  If at any point during the search process we find a match, the search returns. Periodically, the overflow file is merged into the master file.\nHashing functions #   Applies hashing techniques to DBMS Hashing for files on disk is called external hashing  In summary #  There are 3 ways to order files\n unordered sorted organized by hash  We can order the same table in multiple ways by using the tuple\u0026rsquo;s indexes. That way we can do a fast search on any attribute.\nIndexing structures #  File: Indexing slides  DBMS can take care of building indexes for specific attributes for you.\nB-Tree #  A lot of DBMS use B+ Tree for indexing files.\n"}),a.add({id:127,href:'/notes/CS135/CS135-hw-20210203/',title:"CS135-hw-20210203",section:"CS135",content:"FSM #  Alphabets: {a, b} or {0, 1}\n  Strings which begin and end with a different letter\n#alphabet a b #states 0 aa ab ba bb #initial 0 #accepting ab ba #transitions 0:a\u0026gt;aa 0:b\u0026gt;bb aa:a\u0026gt;aa aa:b\u0026gt;ab bb:b\u0026gt;bb bb:a\u0026gt;ba ab:b\u0026gt;ab ab:a\u0026gt;aa ba:a\u0026gt;ba ba:b\u0026gt;bb   Strings with at least 2 occurences of ab\n#alphabet a b #states 0 s1 1 s2 2 #initial 0 #accepting 2 #transitions 0:a\u0026gt;s1 0:b\u0026gt;0 s1:a\u0026gt;s1 s1:b\u0026gt;1 1:a\u0026gt;s2 1:b\u0026gt;1 s2:a\u0026gt;s2 s2:b\u0026gt;2 2:a\u0026gt;2 2:b\u0026gt;2   Strings with exactly one 0 and at least one 1\n#alphabet 0 1 #states s0 onezero oneone good garb #initial s0 #accepting good #transitions s0:0\u0026gt;onezero s0:1\u0026gt;oneone onezero:1\u0026gt;good onezero:0\u0026gt;garb oneone:0\u0026gt;good oneone:1\u0026gt;oneone good:0\u0026gt;garb good:1\u0026gt;good garb:0\u0026gt;garb garb:1\u0026gt;garb   Strings that container ab\n#alphabet a b #states s0 s1 good #initial s0 #accepting good #transitions s0:a\u0026gt;s1 s0:b\u0026gt;s0 s1:b\u0026gt;good s1:a\u0026gt;s1 good:a\u0026gt;good good:b\u0026gt;good   Strings that start with ab\n#alphabet a b #states s0 s1 good garb #initial s0 #accepting good #transitions s0:a\u0026gt;s1 s0:b\u0026gt;garb s1:a\u0026gt;garb s1:b\u0026gt;good good:a\u0026gt;good good:b\u0026gt;good garb:a\u0026gt;garb garb:b\u0026gt;garb   Draw a deterministic FA (a DFA) using the alphabet {0,1} that recognizes all strings that either begin or end with three 0s (or both).\n#alphabet 0 1 #states s0 s1 s2 good #initial s0 #accepting good #transitions s0:0\u0026gt;s1 s0:1\u0026gt;s0 s1:0\u0026gt;s2 s1:1\u0026gt;s0 s2:0\u0026gt;good s2:1\u0026gt;s0 good:0\u0026gt;good good:1\u0026gt;s0   RE #  Alphabets are {a,b} and {0,1}\n Strings which begin and end with the same letter a(a+b)*a + b(a+b)*b Strings with exactly two occurences of ab a*(abab)b* + a*(abab)b* + b*(abab)a* + b*(abab)b* (a* + b*)(abab)(a* + b*) Strings with at most two occurences of ab ``  "}),a.add({id:128,href:'/notes/CS135/CS135-hw-20210302/',title:"CS135-hw-20210302",section:"CS135",content:"Old MM2 hw #  1 Write a recursive Racket function \u0026ldquo;sum-alternate\u0026rdquo; that takes a positive integer x as a parameter. The function should return the sum of all the integers x, x-2, x-4, x-6, etc, as long as the numbers are positive. For example, (sum-alternate 5) should evaluate to 5+3+1, and (sum-alternate 6) should evaluate to 6+4+2.\n(define (sum-acc sum acc) (if (\u0026lt;= sum 0) acc (sum-acc (- sum 2) (+ sum acc)))) (define (sum-alternate sum) (sum-acc sum 0))    2 Write a recursive Racket function \u0026ldquo;sum\u0026rdquo; that takes two integers as parameters, each greater or equal to zero, and evaluates to their sum. In this problem, you must use the built-in functions add1 and sub1 and may not use the built-in functions \u0026ldquo;+\u0026rdquo; or \u0026ldquo;-\u0026rdquo;. For example, (sum 2 3) should evaluate to 5. Note: (add1 5) evaluates to 6 and (sub1 4) evaluates to 3. Hint: like you saw in the \u0026ldquo;append\u0026rdquo; lecture, treat one of the parameters as the size of the problem and recurse until it reaches your base case.\n(define (sum-acc a b acc) (cond ((\u0026gt; a 0) (sum-acc (sub1 a) b (add1 acc))) ((\u0026gt; b 0) (sum-acc a (sub1 b) (add1 acc))) (else acc))) (define (sum a b) (sum-acc a b 0))    3 Write a recursive Racket function \u0026ldquo;remove-char\u0026rdquo; that takes two string parameters, s and c, and evaluates to string s with all occurrences of c removed. The string c is guaranteed to be a length-1 string; in other words a single character string. For example (remove-char \u0026quot;abc\u0026quot; \u0026quot;b\u0026quot;) should evaluate to \u0026ldquo;ac\u0026rdquo;. Here is pseudocode that you could implement.\nif s is empty return s else if (c = first char of s) return remove-char(all but first char of s) else return first char of s concatenated with remove-char(all but first char of s) (define (remove-char s c) (cond ((string=? s \u0026#34;\u0026#34;) s) ((string=? c (substring s 0 1)) (remove-char (substring s 1) c)) (else (string-append (substring s 0 1) (remove-char (substring s 1) c)))))    4 Write a recursive Racket function \u0026ldquo;all-same\u0026rdquo; that takes a string as a parameter and evaluates to true iff every character in the string is the same. Note: A string of length 0 or 1 should also evaluate to true.\n(define (all-same s) (cond ((\u0026lt;= (string-length s) 1) #t) ((string=? (substring s 0 1) (substring s 1 2)) (all-same (substring s 1))) (else #f)))    "}),a.add({id:129,href:'/notes/CS135/CS135-lecture-20210126/',title:"CS135-lecture-20210126",section:"CS135",content:"http://athena.ecs.csus.edu/~mei/135/index.html\nCT = Computing theory\nResources on the Prof\u0026rsquo;s website for Set Theory to review\nThis is not correct:\n"}),a.add({id:130,href:'/notes/CS135/CS135-lecture-20210129/',title:"CS135-lecture-20210129",section:"CS135",content:"dfa.pdf\n"}),a.add({id:131,href:'/notes/CS135/CS135-lecture-20210201/',title:"CS135-lecture-20210201",section:"CS135",content:"http://krovetz.net/135/module_reg/fa_design.html\nThis FSM keeps track of whether there are an even or odd number of a\u0026rsquo;s.\n#alphabet a b #states even odd #initial even #accepting odd #transitions even:a\u0026gt;odd even:b\u0026gt;even odd:a\u0026gt;even odd:b\u0026gt;odd FSM Design advice #   Have a meaning for each state, its the only memory a FA has First write just the part that accepts good strings Make sure your FA is legal. Double check that every state has an arrow out for each alphabet symbol and that their\u0026rsquo;s a start state Try to break your solutions. Look for strings it accepts that it shouldn\u0026rsquo;t. Look for strings that it rejects that it shouldn\u0026rsquo;t.   Write a FSM for the language: L = {abba}\nThis is the \u0026ldquo;write the part that accepts the good strings\u0026rdquo;.\nWe can start to figure out what we don\u0026rsquo;t want to initially accept in the string, \u0026ldquo;starting with a b\u0026rdquo;\n#alphabet a b #states 0 1 2 3 4 5 #initial 0 #accepting 4 #transitions 0:a\u0026gt;1 0:b\u0026gt;5 1:b\u0026gt;2 1:a\u0026gt;5 2:b\u0026gt;3 2:a\u0026gt;5 3:a\u0026gt;4 3:b\u0026gt;5 4:a\u0026gt;5 4:b\u0026gt;5 5:a\u0026gt;5 5:b\u0026gt;5  Write a FSM for the language {w in {a,b}*: w has at least two a's}\n#alphabet a b #states 0 1 2 #initial 0 #accepting 2 #transitions 0:a\u0026gt;1 0:b\u0026gt;0 1:a\u0026gt;2 1:b\u0026gt;1 2:a\u0026gt;2 2:b\u0026gt;2 In steps:\n Write a FSM for the language {w in {a,b}* : w begins and ends in the same letter}\n#alphabet a b #states 0 aa ab ba bb #initial 0 #accepting aa bb #transitions 0:a\u0026gt;aa 0:b\u0026gt;bb aa:a\u0026gt;aa aa:b\u0026gt;ab bb:b\u0026gt;bb bb:a\u0026gt;ba ab:b\u0026gt;ab ab:a\u0026gt;aa ba:a\u0026gt;ba ba:b\u0026gt;bb In Steps:\n Write a FSM for the language: {a^n b^m : n is odd and m is even}\n#alphabet a b #states 0 ae ao be bo garb #initial 0 #accepting ao be #transitions 0:a\u0026gt;ao 0:b\u0026gt;garb ao:a\u0026gt;ae ae:a\u0026gt;ao ae:b\u0026gt;garb ao:b\u0026gt;bo bo:b\u0026gt;be be:b\u0026gt;bo be:a\u0026gt;garb bo:a\u0026gt;garb garb:a\u0026gt;garb garb:b\u0026gt;garb In steps:\nNow this accepts all the good strings, lets make it legal.\nWe can optimize this by making ae the initial state:\n"}),a.add({id:132,href:'/notes/CS135/CS135-lecture-20210204/',title:"CS135-lecture-20210204",section:"CS135",content:"re.pdf\n"}),a.add({id:133,href:'/notes/CS135/CS135-lecture-20210205/',title:"CS135-lecture-20210205",section:"CS135",content:"DFA, RE, and NFA have equal expressive power.\n Every DFA can be converted into an equivalent RE Every RE can be converted into an equivalent NFA Every NFA can be converted into an equivalent DFA  Today we will take a NFA and convert it into a DFA.\nabba will leave you in states 1 and 3.\nOur NFA:\n#states empty 13 2 23 3 123 #initial 13 #accepting 13 123 #alphabet a b #transitions 13:a\u0026gt;13 13:b\u0026gt;2 2:a\u0026gt;23 2:b\u0026gt;3 23:a\u0026gt;123 23:b\u0026gt;3 3:a\u0026gt;13 3:b\u0026gt;empty 123:a\u0026gt;123 123:b\u0026gt;23 empty:a\u0026gt;empty empty:b\u0026gt;empty This is now a legal DFA, except the accept state. So, any accept state in the NFA is also a DFA accept state:\nLegal!\n"}),a.add({id:134,href:'/notes/CS135/CS135-lecture-20210209/',title:"CS135-lecture-20210209",section:"CS135",content:"How to show what a finite atomata can\u0026rsquo;t do #  Pumping Lemma for regular languages #  Let   \\(M\\)  be a DFA with  \\(p\\)  states. Let  \\(s \\in L(M)\\)  , and  \\(|s| \\geq p\\)  , \u0026ldquo;the length of  \\(s\\)  is greater than or equal to the number of states.\u0026rdquo;\nAt one point we reach a state that is going to be visited twice first, we can call this \u0026ldquo;the first state that gets repeated.\u0026rdquo;\nAt one point we get back to this state.\nThe part of the string that takes us to the twice-visited state can be called  \\(x\\)  , the second part that returns to the twice-visited state can be called  \\(y\\)  , and the rest that goes to the accept can be called  \\(z\\)  .\nSo,  \\(s\\)  .\nObserve,\n  \\(|xy| \\leq p\\)  , the length of  \\(x\\)  and  \\(y\\)  is less than the amount of states. We can\u0026rsquo;t avoid a repeat longer.  \\(|y| \u0026gt; 0\\)  , the length of  \\(y\\)  is not empty.  \\(xy^i z \\in L(m)\\)  , for all  \\(i \\geq 0\\)  . We can traverse the  \\(y\\)  string as many times, and as long as its followed by  \\(z\\)  it\u0026rsquo;ll take us to an accept state.  A theorem for pumping lemma for regular languages #  If  \\(L\\)  is a regular language, then there is a positive integer  \\(p\\)  such that any string  \\(s \\in L\\)  and has length  \\(|s| \\geq p\\)  , can be broken into  \\(s\\)  where\n \\[\\begin{aligned} |y| \u0026gt; 0 \\\\ |xy| \\leq p \\\\ xyz \\in L \\end{aligned}\\]  Note: If you know  \\(s\\)  is in  \\(L\\)  and at least  \\(p\\)  long, you don’t get to pick  \\(xyz\\)  . You only get to claim they exist.\nLanguages that aren\u0026rsquo;t regular #   \\(L = \\{0^n1^n: 0 \\leq n \\leq 3\\}\\)  .\nThis is a legal NFA, not a DFA though, so:\nSince the DFA recognizes this language, it proves that its a regular language.\nIf  \\(n\\)  doesn\u0026rsquo;t have an upper limit, i.e.  \\(L\\)  then we cannot say that this is a regular language. Finite state machines cannot do unbounded counting.\nProof template #  Theorem:  \\(L\\)  is not regular.\nProof:\nFor purposes of contradicition assume  \\(L\\)  is regular. Because  \\(L\\)  is regular there must be a pumping length  \\(p\\)  . Consider the string ???? which is in  \\(L\\)  . The pumping lemma says there exists  \\(xyz\\)  . This contradicts that the pumping lemma says ( \\(xy\\)  or  \\(xyyz\\)  ) is in  \\(L\\)  .\nYou must pick a string to replace the ????.\nA hint that often works: pick your string so that the first  \\(p\\)  chars are all the same.\n So in our language  \\(L\\)  Theorem:  \\(L\\)  is not regular.\nProof:\nFor purposes of contradicition assume  \\(L\\)  is regular. Because  \\(L\\)  is regular there must be a pumping length  \\(p\\)  . Consider the string  \\(0^p1^p\\)  which is in  \\(L\\)  . The pumping lemma says there exists  \\(xyz\\)  . Because  \\(|xy| \\leq p\\)  ,  \\(x\\)  and  \\(y\\)  are all 0s. Because  \\(|y| \u0026gt; 0\\)  ,  \\(xyyz\\)  will have more 0s than 1s, and so is not in  \\(L\\)  . This contradicts that the pumping lemma says  \\(xyyz\\)  is in  \\(L\\)  .\n"}),a.add({id:135,href:'/notes/CS135/CS135-lecture-20210216/',title:"CS135-lecture-20210216",section:"CS135",content:"Regular languages #  Any language specifiable by regular expression or finite automata.\nRE to NFA #  Building blocks\nExample #  (0+1)*1\n"}),a.add({id:136,href:'/notes/CS135/CS135-lecture-20210217/',title:"CS135-lecture-20210217",section:"CS135",content:"Example proofs for pumping lemma #  1 #  Let   \\(L\\)  be the set of all strings with an equal number of 0 and 1 over the alphabet {0,1}. i.e. { \\(\\lambda\\)  , 01, 10, 0011, 0101, 0110, 1001 \u0026hellip;}\nTheorem:  \\(L\\)  is not regular.\nProof:\nFor purposes of contradicition assume  \\(L\\)  is regular. Because  \\(L\\)  is regular there must be a pumping length  \\(p\\)  . Consider the string  \\(0^p 1^p\\)  which is in  \\(L\\)  . The pumping lemma says there exists  \\(xyz\\)  . This means that  \\(x\\)  and  \\(y\\)  are all 0, since  \\(y\\)  is not empty  \\(xz\\)  fill have fewer 0s than  \\(xyz\\)  , but the same number of 1s. This means that  \\(xz\\)  has a different number of 0s than 1s, and is therefore not in  \\(L\\)  . This contradicts that the pumping lemma says  \\(xy\\)  is in  \\(L\\)  .\n2 #  Let  \\(L\\)  be the set of all palindroms over alphabet {0,1}, i.e. { \\(\\lambda\\)  , 0, 1, 00, 11, 000, 010, 101, 111, 0000, \u0026hellip;}\nTheorem:  \\(L\\)  is not regular.\nProof:\nFor purposes of contradicition assume  \\(L\\)  is regular. Because  \\(L\\)  is regular there must be a pumping length  \\(p\\)  . Consider the string  \\(0^p 1 0^p\\)  which is in  \\(L\\)  . The pumping lemma says there exists  \\(xyz\\)  . Since  \\(|xy| \\leq p\\)  ,  \\(x\\)  and  \\(y\\)  are all 0s. Since  \\(y\\)  is not empty,  \\(xyyz\\)  will cause more 0s before the 1 than after. The result is not a palindrome so  \\(xyyz\\)  is not in  \\(L\\)  . This contradicts that the pumping lemma says  \\(xyyz\\)  is in  \\(L\\)  .\n"}),a.add({id:137,href:'/notes/CS135/CS135-lecture-20210218/',title:"CS135-lecture-20210218",section:"CS135",content:"Immutability #  Strings in Java are an example of immutability.\nSomething like\ns = s + \u0026#34;abc\u0026#34;; Actually creates a new object with the 2 new strings, and the reference to s is updated, but actual strings are immutable.\nLists #  In Java a popular List class is LinkedList.\nA change to either a or b will change both!\na.add(1, 5); b.get(1); Lets make an immutable List (pseudo): #  a = new List b = a.cons(1) cons stands for \u0026ldquo;construct new list from old.\u0026rdquo;\nc = b.cons(2) This \u0026ldquo;creates a new view\u0026rdquo; of the list, without disturbing any older views of the list.\nd = b.cons(3) So a = [], b = [1], c = [2,1], d = [3,1].\ne = d.rest() rest gives back the list without the first element, so e = [1]\nFor efficiency and to keep views from changing, changes only happen at the front of the list.\n Implementing it #  Racket #  https://docs.racket-lang.org/guide/to-scheme.html\nTest using www.wescheme.org/openEditor\n empty is a constant for the empty list cons is the function that adds to the beginning of a list. (cons elem list) elem is element to be added, list is the list to be added to (rest nonemptylist) returns the list of everything but the first element (first nonemptylist) returns the first element of the list (empty? list) returns true or false (because the ? \u0026ldquo;huh?\u0026quot;) if the list is empty (list 1 2 3) creates a list with elements 1 2 3, can also be alised as '(1 2 3)  empty -- const for the empty list (cons elem list) (rest nonemptylist) (first nonemptylist) (empty? list) (list 1 2 3) \u0026#39;(1 2 3) (empty? empty) ; true (empty? (list 1 2 3)) ; false (cons 3 empty) ; (list 3) (cons 2 (cons 3 empty) ; (list 2 3) (cons 1 (cons 2 (cons 3 empty))) ; (list 1 2 3) \u0026#39;(1 2 3) ; (list 1 2 3) (first \u0026#39;(1 2 3)) ; 1 (rest \u0026#39;(1 2 3)) ; (list 2 3) The if construct in Racket:\n(if boolexpr trueexpr falseexpr) An example to return the length of a list: #  Some pseudo for recursive functions:\nif (very small) solve directly else make recursive call (use smaller-solver) For our problem:\nif (empty list) return 0 else return 1 + listlen(list without front) In racket:\n(define (listlen xs) (if (empty? xs) 0 (+ 1 (listlen (rest xs))))) Note\n Traditional in Racket to pass the list name as plural: xs There are no returns in Racket, everything is an expression  We can then run this function via the interactions panel\n(listlen empty) ; 0 (listlen \u0026#39;(1)) ; 1 (listlen \u0026#39;(1 1)) ; 2 "}),a.add({id:138,href:'/notes/CS135/CS135-lecture-20210225/',title:"CS135-lecture-20210225",section:"CS135",content:"Tail recursion and accumulators #  Tail recursion #  Claim: recursive overhead is expensive.\nNot always the case.\nFor example:\nWe have a function foo(x) that takes a parameter x.\nfoo(x): if (x == 0) return answer else // do stuff, then make recursive call return foo(x - 1) The value of x is being decremented, and being passed in as the new x in the next call. Once the base case is returned there isn\u0026rsquo;t any more work that needs to be done. So we can rewrite this function mechanically as a loop:\nfoo(x): label if (x == 0) return answer else // do stuff, but instead of return // we update our variable, and goto label x = x - 1 goto label This behaves exactly as the original, in terms of computational steps, but we\u0026rsquo;ve eliminated the function call so the overhead goes away. This only works if the recursive call is in tail position, which is a recursive call at the very end of the work that has no work to do after the recursive call. So you get the performance of a loop, but with the written style of recursive code.\nSo lets do the factorial:\nfact(x): if (x == 0) return 1 else return x * fact(x - 1) So we should assume that the compiler should be able to tail call optimize this code. However, there is a multiplication that has to occur after the function call, so it cannot.\nSo we can fix this by getting rid of the multiplication by x. If there is multiplication that needs to happen, it has to happen before the recursive call. We can do this using accumulators.\nAn example accumulator:\nacc = 1 while (x \u0026gt; 0) acc = acc * x x = x - 1 return acc So we can use that same idea to modify our fact function:\nfact(x, acc): if (x == 0) return acc else return fact(x - 1, x * acc) Now the last function call is in tail position. There is no computation that happens after the recursive call.\nInvariant:   \\(\\text{answer} = x! \\cdot \\text{ accumulator } \\)     x acc     4 1   3 4   2 12   1 24   0 24    Proof that this works using C #  Using C code and looking at its compiled assembly:\ngcd.c:\nWe can compile this with optimization level 1:\ngcc -01 gcd.c -S Lets do optimization level 2 (adds tail call optimization):\ngcc -01 gcd.c -S2 This is now a tighter loop instead of a recursive call. It also inline calls the helper function to fact:\nThe iterative version is identical to the inline factorial version:\nThe gcd function is also a tail recursive function. It could be written iterative however:\nint gcd_iter(int x, int y) { while (y != 0) { int t = y; y = x % y; x = t; } return x; } This is arguably a more complex version, compared to the recursive version. Lets look at the compiled assembly code:\nIt has a loop, but no recursive calls. The iterative version:\nIt also has the same length loop, so they are identical, due to the tail call optimization.\nFactorial method implementation in Racket #  Here is a tail recursive version.\n(define (fact-helper x acc) (if (= x 0) acc (fact-helper (- x 1) (* x acc)))) To test this:\n(fact-helper 4 1) ; 24 We can also define a nicer method for the user:\n(define (fact x) (fact-helper x 1)) So now we can call it like this:\n(fact 4) ; 24 "}),a.add({id:139,href:'/notes/CS135/CS135-lecture-20210227/',title:"CS135-lecture-20210227",section:"CS135",content:"Functional Programming #  Other functions may write to this.sum, so this could be incorrect in the future.\nAny loop can be turned into a recursively structured function.\nExample of pow #  int pow(int x, int y) if (very small) solve directly else solve with smaller_pow So when is exponentiation very small? This is the base case, where y = 0.\nint pow(int x, int y) if (y == 0) return 1 else solve with smaller_pow Now we need to figure out the else branch, we know that x^y = x^(y-1) * x.\nint pow(int x, int y) if (y == 0) return 1 else return x * pow(x, y - 1) Intro to Racket #  racket-lang.org\nwescheme.org\nRacket is a form of scheme, and scheme is a form of Lisp.\nA method definition (which just calls the built-in sting-append).\n(define (my-concat s1 s2) (string-append s1 s2)) So we can call this function like:\n(my-concat \u0026#34;abc\u0026#34; \u0026#34;def\u0026#34;) ; \u0026#34;abcdef\u0026#34; Lets define a strlen function:\n(define (strlen s) (if (= 0 (string-length s)) 0 (+ 1 (strlen (substring s 1))))) Yes, this is calling a built in string length function, but its just displaying how a recursively called function is setup.\n(strlen \u0026#34;\u0026#34;) ; 0 (strlen \u0026#34;a\u0026#34;) ; 1 (strlen \u0026#34;abc\u0026#34;) ; 3 Racket non-list examples #  Lists are used a lot as a primary data structure in lisps.\nA factorial function #  (define (fact n) (if (= n 0) 1 (* n (fact (-n 1))))) (fact 0) ; 1 (fact 1) ; 1 (fact 2) ; 2 (fact 10) ; 3628800 Fibonacci numbers #  We can utilize the cond function, used like this:\n(cond (bool expr) (bool expr) ... (else expr)) This is equivalent to a nested if. cond goes one by one and checks each boolean expression, and if true it replaces with expr. The ... means that there can be any number of expressions to check, this is like a switch. As soon as it finds the first true it executes the replacement then ends. At least one thing has to evaluate to true otherwise you\u0026rsquo;ll get a runtime error, so we can end with an else.\n(define (fib n) (cond ((= n 0) 1) ((= n 1) 1) (else (+ (fib (- n 1)) (fib (- n 2)))))) So we can test this:\n(fib 0) ; 1 (fib 1) ; 1 (fib 2) ; 2 (fib 3) ; 3 (fib 4) ; 5 String reverse #  If given \u0026quot;abc\u0026quot;, it should go to \u0026quot;cba\u0026quot;. To test for string equality we can use built in string=?, \u0026ldquo;string equal huh?\u0026rdquo;. We can use substring to cut the string down, and string-append to append. \u0026quot;cba\u0026quot; = \u0026quot;cb\u0026quot; + \u0026quot;a\u0026quot;\n(define (strev s) (if (string=? s \u0026#34;\u0026#34;) s (string-append (strev (substring s 1)) (substring s 0 1)))) We can test now:\n(strev \u0026#34;\u0026#34;) ; \u0026#34;\u0026#34; (strev \u0026#34;a\u0026#34;) ; \u0026#34;a\u0026#34; (strev \u0026#34;ab\u0026#34;) ; \u0026#34;ba\u0026#34; (strev \u0026#34;abc\u0026#34;) ; \u0026#34;cba\u0026#34; There is a built in called check-expect, which we can use to test.\n(check-expect (strev \u0026#34;abc\u0026#34;) \u0026#34;cba\u0026#34;) When you run this, if you see nothing then it works correctly. If it fails you will see the explanation in the output.\nwriteSequence problem from practiceit #  Note that if you call the sequence on 8, the center is the 6 sequence, then you divide 8 but 2 and round up to get the outside number. We can explicitly change the number to a string with number-\u0026gt;string.\n(define (ws n) (cond ((= n 1) \u0026#34;1\u0026#34;) ((= n 2) \u0026#34;11\u0026#34;) (else (string-append (number-\u0026gt;string (ceiling (/ n 2))) (ws (- n 2)) (number-\u0026gt;string (ceiling (- n 2))))))) So we can test this to see if its working:\n(ws 1) ; \u0026#34;1\u0026#34; (ws 2) ; \u0026#34;11\u0026#34; (ws 3) ; \u0026#34;212\u0026#34; (ws 4) ; \u0026#34;2112\u0026#34; Racket under the hood #  Whenever Racket encounters a define in its top down compilation, it stores it in a table. When it calls a function call, it can be thought of as a constant replacing of definition names with its implementation. So a functions name gets replaced by its value. This is easy to think about with single value definitions, like (define n 1), but when a function is defined all the parameters are replaced in the replacement as well.\nSo if you have this definition:\n(define (listlen xs) (if (empty? xs) 0 (= 1 ( listlen (rest xs))))) And you call the function like:\n(listlen \u0026#39;(1 2 3)) listlen is actually being replaced with:\n(if (empty? \u0026#39;(1 2 3)) 0 (+ 1 (listlen (rest \u0026#39;(1 2 3))))) Which is then replaced by\n(+ 1 (listlen (rest \u0026#39;(1 2 3)))) (+ 1 (listlen `(2 3))) and so forth.\nDebugging in DrRacket #  We can click step in DrRacket to open up a stepper window, that highlights the next substitution that will happen.\nThis continues on until the base case\u0026hellip;\n"}),a.add({id:140,href:'/notes/CS135/CS135-lecture-20210307/',title:"CS135-lecture-20210307",section:"CS135",content:"Mergesort in Racket #  Mergesort breaks the list in half and sorts each half recursively.\nSome pseudo:\nms(list) front = front half of list back = back half of list ms(front) ms(back) return merge(front, back) In racket, there is a function called drop that takes a list and a number. It drops the numbers off the list. There is also take, that takes the first number of elements of the list and returns them.\n(define list \u0026#39;(1 2 3 4 5 6)) ; helper definition (drop list 2) ; \u0026#39;(3 4 5 6) (take list 2) ; \u0026#39;(1 2) (drop list (quotient (length list) 2)) ; drops the first half of the list So we can start our mergesort definition:\n(define (ms xs) (if (\u0026lt; (length xs) 2) xs (merge (ms (take xs (quotient (length xs) 2))) (ms (drop xs (quotient (length xs) 2)))))) However, we haven\u0026rsquo;t defined merge yet, so:\n(define (merge xs ys) (cond ((empty? xs) ys) ((empty? ys) xs) ((\u0026lt; (first xs) (first ys)) (cons (first xs) (merge (rest xs) ys))) (else (cons (first ys) (merge (rest ys) xs))))) So we can test this:\n(ms \u0026#39;(5 3 6 2 7 1 4)) ; \u0026#39;(1 2 3 4 5 6) Higher-order functions #  Treat functions as first class data. We\u0026rsquo;re going to allow functions to be passed as parameters. We\u0026rsquo;ll consider 3 functions that take functions as parameters.\n (map f xs) – applies f to each element of xs, and builds a list from the results (filter f xs) – f is a boolean, it applies f to each element of xs and filters out any element for which f is false (foldl f acc xs) – abstracts the acumulator process we did earlier. It applies f to each value of xs and integrates that value into the accumulator acc. The l in foldl means that it is going from left to right. foldl is   \\( O(n) \\)  .  For example, to sum the elements of a list using foldl:\n(foldl + 0 xs) ; 10 Examples using map:\n(map add1 \u0026#39;(1 2 3 4)) ; \u0026#39;(2 3 4 5) We can use our own functions in map\n(define (double x) (+ x x)) (map double \u0026#39;(1 2 3 4)) ; \u0026#39;(2 4 6 8) Lets take a look at filter:\n(filter even? \u0026#39;(1 2 3 4 5)) ; \u0026#39;(2 4) Designing filter #  The base case is the empty list, which returns back the empty list. When we are calling the function recursively, we will have to use rest.\nHeres a screenshot using even? as f:\n; my-filter applies f to each element of xs ; and builds a list from those that make f true ; f: A --\u0026gt; boolean ; xs: list of A (define (my-filter f xs) (if (empty? xs) empty (if (f (first xs)) ; remember f is a function (cons (first xs) (my-filter f (rest xs))) (my-filter f (rest xs))))) So:\n(my-filter even? \u0026#39;(1 2 3 4 5)) ; \u0026#39;(2 4) Designing foldl #  Recall\n(foldl + 0 \u0026#39;(1 2 3 4)) ; 10 ; f: (A, B) --\u0026gt; A ; acc: A ; xs: list of B (define (my-foldl f acc xs) (if (empty? xs) acc (my-foldl f (f acc (first xs)) (rest xs)))) So lets test it:\n(my-foldl + 0 \u0026#39;(1 2 3 4)) ; 10 Lambda functions #  Lambdas are nameless (anonymous) functions.\n(lambda (x y) (+ x y)) How can we call this function if it doesn\u0026rsquo;t have a name? There are many uses, we can define an operation without writing the full definition.\nFor example, to double all the numbers of a list:\n(define (double-all xs) (if (empty? xs) empty (cons (* 2 (first xs)) (double-all (rest xs))))) (double-all \u0026#39;(1 2 3)) ; \u0026#39;(2 4 6) But we can do this with higher order functions:\n(define (double x) (* 2 x)) (define (double-all2 xs) (map double xs)) (double-all2 \u0026#39;(1 2 3)) ; \u0026#39;(2 4 6) Notice that we had to define our doubling function. This is where anonymous functions come in. Their main use is for one time application for a simple functions in a higher order situation.\n(define (double-all3 xs) (map (lambda (x) (* 2 x)) xs)) (double-all3 \u0026#39;(1 2 3)) ; \u0026#39;(2 4 6) Another lambda example #  Lets write a function that keeps the numbers 1 thru 100.\n(define (keep-1-100 xs) (filter (lambda (x) (and (\u0026gt; x 0) (\u0026lt; x 101))) xs)) (keep-1-100 \u0026#39;(1 -1 -10 50 99 100 101)) ; \u0026#39;(1 50 99 100) Returning a function using a lambda #  ; g(f(x)) (define (composer g f) (lambda (x) (g (f x)))) We can test out this function:\n; using double function from earlier (define double-add1 (composer add1 double)) (double-add1 10) ; 21 Expanding the keep-1-100 function #  If we want to expand our 1-100 function to take any range, we can use lambdas. We can make a higher order function that creates a tester for a specific interval.\n(define (interval-factory x y) (lambda (z) (and (\u0026lt; x z) (\u0026gt; y z)))) This returns a customized function based on the values we pass x and y. We can define the 1-100 interval like so:\n(define in-1-100 (interval-factory 1 100)) (in-1-100 50) ; #t (in-1-100 150) ; #f (filter in-1-100 \u0026#39;(-1 1 2 99 100 101)) ; \u0026#39;(2 99) ; another interval (define in-50-1000 (interval-factory 50 1000)) (filter in-50-1000 \u0026#39;(-1 1 2 99 100 101)); \u0026#39;(99 100 101) Functional closure #  Return an object that has copies of values in the current scope.\nGraphical pseudo:\nThis is the idea of a closure. In the definition of foo, we are constructing an object that copies the current value of x and y. If x and y change it would change the returned object, so we make a copy.\nWe did this earlier when we defined interval-factory. When we passed in certain values it copies those and returns an object with those values embedded.\n"}),a.add({id:141,href:'/notes/CS135/CS135-lecture-20210309/',title:"CS135-lecture-20210309",section:"CS135",content:"Tail recursive sum #  (define (sum xs) (if (empty? xs) 0 (+ (first xs) (sum (rest xs))))) This isn\u0026rsquo;t tail recursive however. The recursive call must be the last call in the function. Lets define it tail recursively, we can use an accumulator:\nInvariant: acc + sum of xs is desired answer.\n(define (sum-helper acc xs) (if (empty? xs) acc (sum-helper (+ acc (first xs)) (rest xs)))) (define (sum xs) (sum-helper 0 xs)) (sum \u0026#39;(1 2 3 4)) ; 10 "}),a.add({id:142,href:'/notes/CS135/CS135-lecture-20210310/',title:"CS135-lecture-20210310",section:"CS135",content:"Context-free grammars #  Recall, for regular languages: regular expressions are generators, and finite automata are recognizers. Context-free grammars are the recognizers of context free languages.\nAny string we can make in this process is in the language. Any string we can\u0026rsquo;t make in this process is not in the language.\nSo   \\( \\{a^n b^n: \\text{n is integer}\\} \\)  is context free. Remember, we couldn\u0026rsquo;t describe this language using regular expressions because finite automata don\u0026rsquo;t have memory.\nDesigning context-free grammar #  Consider the previous example\u0026rsquo;s language:  \\( \\{a^n b^n: \\text{n is integer}\\} \\)   \\(S \\to aSb \\\\ S \\to \\lambda\\)  If we wanted the language  \\( \\{a^n b^{2n}: \\text{n is integer}\\} \\)   \\( S \\to aSbb \\mid \\lambda\\)  If we want to have a language that decides one string from class  \\( A \\)  and one string from class  \\( B \\)  :\n \\( S \\to AB \\\\ A \\to aA \\mid \\lambda \\\\ B \\to bB \\mid \\lambda\\)  Another pattern we see occasionally is one that sequences things, in different stages.\nFor the language  \\( \\{a^n b^m c^r: n, m, r \\text{ are integers}\\} \\)   \\( S \\to aS \\mid T \\\\ T \\to bT \\mid R \\\\ R \\to cR \\mid \\lambda\\)  So it first takes strings from stage  \\( S \\)  , then stage  \\( T \\)  , then  \\( R \\)  .\nSo a derivation of  \\( a^2b^2c^2 \\)  would be:\n \\( S \\to aS \\to aaS \\to aaT \\to aabT \\to aabbT \\to aabbR \\to aabbcR \\to aabbccR \\to aabbcc \\)  An example designing a CFG #  Consider the language  \\( L = \\{a^l b^m a^n : l,m,n \u0026gt; 0, l\u0026#43;n=m\\} \\)  , for example the strings  \\( abba, aabbba, abbbaa \\)  have the same number of  \\( a \\)  \u0026rsquo;s and  \\( b \\)  \u0026rsquo;s.\nEvery substitution must introduce one  \\( a \\)  and one  \\( b \\)  to be matched.\nWe can think of 2 classes  \\( T \\)  and  \\( R \\)  .\n \\( S \\to TR \\\\ T \\to aTb \\mid \\lambda \\\\ R \\to bRa \\mid \\lambda\\)  This adds  \\( a \\)  \u0026rsquo;s and  \\( b \\)  \u0026rsquo;s in a one to one fashion, so this guarantees there will be the same amount.\nHowever, note that the empty string can be derived:\n \\( S \\to TR \\to R \\to \\lambda \\)  So we can fix our CFG to:\n \\( S \\to TR \\\\ T \\to aTb \\mid ab \\\\ R \\to bRa \\mid ba \\\\\\)  So the shortest string derived is now:\n \\( S \\to TR \\to abR \\to abba \\)  Solving the same example using a PDA #  Recall the language  \\( L = \\{a^l b^m a^n : l,m,n \u0026gt; 0, l\u0026#43;n=m\\} \\)  To create a push-down automata for this language we follow these steps:\n Consume  \\( a \\)  \u0026rsquo;s and push Consume  \\( b \\)  \u0026rsquo;s and match them with  \\( a \\)  \u0026rsquo;s (pop the  \\( a \\)  off the stack when we consume a  \\( b \\)  ). Consume  \\( b \\)  \u0026rsquo;s and push Consume  \\( a \\)  \u0026rsquo;s and pop  \\( b \\)  \u0026rsquo;s  The arrows are labeled as char to consume, top of stack, what to push from right to left:\nSo this handles the first  \\( a \\)  , so we can add:\nNow we handle the  \\( b \\)  and pop  \\( a \\)  :\nNow there will be more  \\( b \\)  \u0026rsquo;s, so we can self loop off the new state:\nWe need to consume more  \\( b \\)  \u0026rsquo;s and push them onto the stack:\nAnd finally handle the last  \\( a \\)  \u0026rsquo;s and pop  \\( b \\)  \u0026rsquo;s.\nSo this will go on, and if we have nothing on the stack then it is an accept.\nYou can only follow the last arrow if the stack is empty.\nTip: when designing these push-down automatas, think of the algorithm first (the steps above).  Odd length palindromes #  Consider the language  \\( L = \\text{odd length palindromes} \\)  over the alphabet  \\( \\{a,b\\} \\)  . Note that the empty string will not be accepted. There will always also be a center character.\nSo some of the strings accepted will be  \\( \\{a, b, aaa, aba, bab, bbb, aaaaa, aabaa, ...\\} \\)  .\nSo lets come up with the CFG:\n \\( S \\to aSa \\mid bSb \\mid a \\mid b\\)  Note: if we added a \\(\\lambda\\) to this definition, it would describe all palindromes.  Lets derive  \\( ababa \\)  :\n \\( S \\to aSa \\to abSba \\to ababa\\)  So for the push-down automata, lets think of the algorithm first:\n Consume and push first half of string Consume the middle char Consume and pop the second half of the string Check that stack is empty  So how do we know when we get to the middle? The middle can be either of our alphabet chars. Without a special char in the middle, there will be non-determinism in this push-down automata. In this case, non-determinism does give the push-down automata more power.\nSo lets start with step 1:\nThen we\u0026rsquo;ll encounter the middle character, step 2:\nNow we can consume the next input and see if it matches, step 3:\nFinally check if the stack is empty, step 4:\nWe can only get to the accept state if the stack is empty.\n"}),a.add({id:143,href:'/notes/CS135/CS135-lecture-20210311/',title:"CS135-lecture-20210311",section:"CS135",content:"Introduction to push-down automata #  A push-down automata is a finite automata with memory, more than what state its currently in. It is a non-deterministic finite automata with a stack for memory. Since it is drawn very similarly to drawing finite automata, we will just notate how the stack is being manipulated on the transitions.\nDrawing transitions for PDAs #  Each arrow has a triple: a,b,c, where\n a is the char to consume from input (or   \\( \\lambda \\)  ) b is the char to pop from the top of the stack, b is always popped when following this transition c is a string to push onto the stack (from right to left)  An arrow can be followed if and only if:\n a matches next input char (or  \\( \\lambda \\)  ), and b matches top of the stack  Following the arrow: consumes a, pops b, pushes c\nConvention: when drawing the PDAs,  \\( \\emptyset \\)  signifies the bottom of the stack at start.\nSteps to follow when creating a PDA #   Think of a stack-based algorithm Try to implement the algorithm with a PDA  Example 1 #  The language  \\( L = \\{a^n b^n: n \\geq 0\\} \\)  represents the strings  \\( \\{\\lambda, ab, aabb, aaabbb, \\ldots\\} \\)  .\nWe saw earlier that we cannot represent this language using finite automata, proving it wasn\u0026rsquo;t a regular language. Let\u0026rsquo;s think of an algorithm to accomplish this language:\n Consume an  \\( a \\)  and push it onto the stack When we start to see  \\( b \\)  \u0026rsquo;s we pop an  \\( a \\)    We can start with the first  \\( a \\)  seen:\nThen we can self loop for the next  \\( a \\)  when there is already one on the stack:\nWe can think of the first state as \u0026ldquo;pushing  \\( a \\)  \u0026rsquo;s onto the stack.\u0026rdquo; After this phase we will move onto \u0026ldquo;matching  \\( b \\)  \u0026rsquo;s\u0026rdquo;, this will be our second state.\nThe first self loop consumes the  \\( b \\)  , and pops the  \\( a \\)  , and pushes the empty string back to the stack ( \\( \\lambda \\)  ).\nThe arrow transitioning from the first to the second state will be  \\( b,a,\\lambda \\)  :\nNote: This arrow could also be labeled \\( \\lambda,a,a \\)  At this point the PDA will work with all of the good strings in the language. To decide where the accept state is we need to think of what the stack should look like once the string is consumed. When we no input and the bottom of the stack, we can accept,  \\( \\lambda, \\emptyset, \\emptyset \\)  :\nString is accepted if and only if  \\( a^n b^n \\)  seen and all input is consumed. The last thing to take care of is accepting the empty string  \\( \\lambda \\)  . To do this, we can add  \\( \\lambda, \\emptyset, \\emptyset \\)  on the middle arrow:\nExample 2 #  Consider the language  \\( L= \\{w \\mid w \\in \\{a,b\\} \\text{ and } w \\text{ has equal number of } a \\text{\u0026#39;s and } b \\text{\u0026#39;s} \\} \\)  .\nTo accomplish:\n Use the stack to keep match of excess  Input is accepted if and only if all input is consumed with an equal amount of  \\( a \\)  \u0026rsquo;s and  \\( b \\)  \u0026rsquo;s (stack is empty).\nRelative power of PDA #  Recall, we showed that any NFA can be expressed as a DFA, therefore they have the same expressive power. Every NFA can be turned into an equivalent PDA.\nAny arrow labeled  \\( x \\)  in a NFA can be expressed as an arrow triple  \\( x, \\emptyset, \\emptyset \\)  in a PDA.\nTherefore, the power a PDA has is greater than or equal to an NFA\u0026rsquo;s power.\nPDA\u0026rsquo;s can recognize  \\( a^nb^n \\)  , and no NFA can recognize this language.\nSo a PDA is not equal in power to a NFA, so therefore it must mean that a PDA is greater than a NFA in expressive ability.\n"}),a.add({id:144,href:'/notes/CS135/CS135-lecture-20210315/',title:"CS135-lecture-20210315",section:"CS135",content:"Parse trees and Ambiguity #  Parse trees are graphical representations of what each non-terminal produces during a derivation.\nAn example of a parse tree:\n  \\( S \\to AB \\\\ A \\to aaA \\mid \\lambda \\\\ B \\to bbB \\mid b\\)  This grammar produces all strings that have an even number of  \\( a \\)  \u0026rsquo;s and an odd number of  \\( b \\)  \u0026rsquo;s.\nSo we can prove that  \\( aabbbbb \\)  is in the language by showing a derivation:\n \\( S \\to AB \\to AbbB \\to AbbbbB \\to Abbbbb \\to aaAbbbbb \\to aabbbbb\\)  So to build a parse tree, at each production we draw a representation of what got replaced.\nIt doesn\u0026rsquo;t matter if we did the  \\( A \\)  stage or the  \\( B \\)  stage first, it would end in the same parse tree.\nNote: The fringe (the leaves of this tree concatenated together) is the intermediate string at each step during the derivation. When the entire parse tree is drawn, the fringe is the output string.  Ambiguous grammar #  A grammar is ambiguous if and only if there exists a string in the language of the grammar with 2 different parse trees.\nAn example of an ambiguous grammar is:\n \\( S \\to AA \\\\ A \\to aA \\mid \\lambda\\)  To prove that this is ambiguous, we can show 2 different derivations for  \\( aaa \\)  :\n \\( S \\to AA \\to aAA \\to aaA \\to aaAA \\to aaA \\to aaaA \\to aaa\\)    \\( S \\to AA \\to AaA \\to AaaA \\to Aaa \\to aAaa \\to aaa\\)    Since the fringes are identical, they both represent different ways to derive the string  \\( aaa \\)  , but since they are 2 different parse trees this proves that the grammar is ambiguous.\nSince CFGs can represent programming languages, a parse tree represents a program. If a compiler can produce 2 different parse trees (programs) for a single source code, that is a bad thing.\nSteps to show that a grammar is ambiguous #   Choose a string Demonstrate two legitimate parse trees for the string  Alternatively, you can show 2 different derivations for the same string. This doesn\u0026rsquo;t always work however, with the first language we expressed above (even  \\( a \\)  \u0026rsquo;s with odd  \\( b \\)  \u0026rsquo;s), because since that language is non-ambiguous, it doesn\u0026rsquo;t matter which order we process the string (it makes the same parse tree).\nLeftmost derivations #  If each step of the derivation converts the leftmost non-terminal, then it is impossible to show 2 different derivations in a non-ambiguous grammar.\nSo for example:\n \\( S \\to AB \\to aaAB \\to aaB \\to aabbB \\to aabbbbB \\to aabbbbb\\)  Every string in a non-ambiguous grammar will have exactly 1 string created in a leftmost derivation. However, in an ambiguous grammar, this is not the case.\nSo for our ambiguous grammar above, we can derive  \\( aaa \\)  using leftmost derivation:\n \\( S \\to AA \\to aAA \\to aaAA \\to aaA \\to aaaA \\to aaa\\)  We can show that this is ambiguous by showing another leftmost derivation of  \\( aaa \\)  :\n \\( S \\to AA \\to aAA \\to aA \\to aaA \\to aaaA \\to aaa\\)  "}),a.add({id:145,href:'/notes/CS135/CS135-lecture-20210318/',title:"CS135-lecture-20210318",section:"CS135",content:"Pumping lemma for CFL #  PL for RL\nGiven   \\( RL, L \\)  there exists  \\( p \\)  such that if  \\( w \\in L \\)  and  \\( |w| \\geq p \\)  then there exists  \\( w = xyz \\)  where\n  \\( |y| \u0026gt; 0 \\)    \\( |xy| \\leq p \\)    \\( xy^iz \\in L \\)    We consume  \\( w \\)  and we get to a state that is the first repeated state. At some point we come back to it, and then to the accept.\nSince  \\( w \\)  is  \\( p \\)  or longer, it must visit one state more than once. We can identify this state as the one we get repeated. The part that gets us there the first time  \\( x \\)  , the part that gets us there the second time  \\( y \\)  , and the part that goes to the accept state  \\( z \\)  .\nIf  \\( x \\)  gets us to the repeated state, then we can go around  \\( y \\)  as many times we want (or omit).\nProof template #  Given context-free language  \\( L \\)  , there exists  \\( p \\)  such that if  \\( w \\in L \\)  and  \\( |w| \\geq p \\)  , then there exists a  \\( w = uvxyz \\)  where\n  \\( |vy| \u0026gt; 0 \\)    \\( |vxy| \\leq p \\)    \\( uv^ixy^iz \\in L \\)    Main use: we look for strings that are in the language and at least  \\( p \\)  long, and then apply the pumping lemma to show that the language is not context-free.\nTo prove:\n Assume  \\( L \\)  is context-free Pick  \\( w \\in L \\)  with  \\( |w| \\geq p \\)   Argue that the pumping lemma says that there exists  \\( w = uvxyz \\)  with   \\( |vy| \u0026gt; 0 \\)    \\( |vyx| \\leq p \\)    \\( uv^ixy^i \\in L \\)     Argue that either if we pump down ( \\( i = 0 \\)  gives us  \\( uxz \\)  , or if we pump up  \\( i \u0026gt; 0 \\)  we get  \\( uvvxyyz \\)  and show that  \\( e \\not \\in L \\)   Pumping lemma says string is in  \\( L \\)  , contradiction, so  \\( L \\)  is not context-free.  Example #  Consider  \\( L = \\{a^n b^n c^n : n \\geq 0\\} \\)  This starts by consuming  \\( a \\)  \u0026rsquo;s and pushing them onto the stack. Then when we start seeing  \\( b \\)  \u0026rsquo;s we pop the  \\( a \\)  \u0026rsquo;s off. When we reach the  \\( c \\)  \u0026rsquo;s we don\u0026rsquo;t have a way to remember how many  \\( a \\)  \u0026rsquo;s or  \\( b \\)  \u0026rsquo;s we saw.\nNote: A Turning machine can do this because it has 2 stacks.  So lets prove its not context-free using the pumping lemma.\nThe string we pick must be length  \\( p \\)  and exist in  \\( L \\)  :\n \\[\\begin{aligned} w = a^p b^p c^p \\end{aligned}\\]   \\( w \\)  exists in the language and is at least  \\( p \\)  long (it is in fact  \\( 3p \\)  long).\nSo lets assume that this language is context-free, and apply the pumping lemma.\nPossible divisions for  \\( w \\)  :\nSince  \\( w = uvxyz \\)  , we don\u0026rsquo;t know exactly where they are however\nWe do know that  \\( 0 \u0026lt; |vxy| \\leq p \\)  Its possible that  \\( vxy \\)  :\n appear in the region of just  \\( a \\)  \u0026rsquo;s, since there are at least  \\( p \\)   \\( a \\)  \u0026rsquo;s. So  \\( vxy = \\)  all  \\( a \\)  \u0026rsquo;s. appear in the  \\( a \\)  \u0026rsquo;s and  \\( b \\)  \u0026rsquo;s. any other combination of 2, but not all 3  So,  \\( uvvxyyz \\)  will increase 1 or 2 types of characters, but not all 3. Thus it is out of balance, and the string is not in  \\( L \\)  .\n \\[\\begin{aligned} uvvxyyz \\not \\in L \\end{aligned}\\]  Therefore, the language  \\( L = \\{a^n b^n c^n : n \\geq 0\\} \\)  is not context-free.\nWhy the pumping lemma is true #  If  \\( L \\)  is context-free, then there is a context-free grammar for it. So, every string  \\( w \\in L \\)  has a parse tree:\nwhere the fringe is  \\( w \\)  and the interior is non-terminals.\nObserve,\n The longer that  \\( w \\)  is, the taller the tree The taller the tree, the more non-terminals in the longest root-to-leaf path Once the root-to-leaf path is long enough, some non-terminal must repeat in it  There are a finite number of productions in the grammar, and so as the tree gets longer and longer until there must be a repeat. This is where the pumping lemma comes in.\nAs an abstraction:\nSome part of  \\( w \\)  will be derived from  \\( A \\)  .\nThis tells us that\n  \\( x \\in L(A) \\)  , and  \\( vxy \\in L(A) \\)    So each time that  \\( A \\)  is reached, we can replace it with  \\( x \\)  or  \\( vxy \\)  , we can pump the  \\( v \\)  and  \\( y \\)  as many times we want.\nNote: This is similar to the pumping lemma for regular languages because it also uses the pigeon hole principle.  "}),a.add({id:146,href:'/notes/CS135/CS135-lecture-20210329/',title:"CS135-lecture-20210329",section:"CS135",content:"CFG to PDA algorithm #  Starting from a CFG and going to a PDA is a lot easier than going the other way.\nLets start out with this grammar:\n  \\( S \\to AB \\\\ A \\to aA \\mid \\lambda \\\\ B \\to bB \\mid \\lambda\\)  We can start our PDA by drawing 3 states, one start and one accept.\nThe first transition triple is  \\( \\lambda, \\empty, S \\empty \\)  , and the second transition is  \\( \\lambda, \\empty, \\empty \\)  .\nIn the middle there will be a self loop with a bunch of triples. For example, if we had a production  \\( X \\to \\alpha \\)  , then the triple will be  \\( \\lambda, X, \\alpha \\)  . \u0026ldquo;If the top of the stack is a non-terminal, we can replace it with a terminal.\u0026rdquo;\nAnother rule to follow is that for all terminals we use the triple  \\( a, a, \\lambda \\)  (if  \\( a \\)  is a terminal).\nWe can follow this same pattern for the other productions.\nSo we have 5 productions, so we have 5 triples of that form.\n \\( \\lambda, S, AB \\\\ \\lambda, A, aA \\\\ \\lambda, A, \\lambda \\\\ \\lambda, B, bB \\\\ \\lambda, B, \\lambda\\)  We also have the triples\n \\( a, a, \\lambda \\\\ b, b, \\lambda\\)  This PDA simulates a derivation, for example  \\( aab \\)  :\n \\(S \\to AB \\to aAB \\to aaAB \\to aaB \\to aabB \\to aab\\)  Note: A PDA simulates a leftmost derivation.  Another pumping lemma example with a context-free language #  For the language  \\( L = \\{ww \\mid w \\in \\{0,1\\}* \\} \\)  Theorem:  \\( L \\)  is not context-free\nProof:\nAssume for contradiction that  \\( L \\)  is context free.\nLet  \\( p \\)  be  \\( L \\)  \u0026rsquo;s pumping length. Consider the string  \\( w = 0^p 1^p 0^p 1^p \\)  , which is length at least  \\( p \\)  and is in  \\( L \\)  .\nThe pumping lemma says there exists  \\( w = uvxyz \\)  where  \\( v \\)  and or  \\( y \\)  is not empty,  \\( |vxy| \\leq p \\)  and  \\( uv^ixy^iz \\)  is in  \\( L \\)  for all  \\( i \\)  .\nIf  \\( vxy \\)  is entirely in the first set of  \\( p \\)  0\u0026rsquo;s, then the pumped  \\( v \\)  and  \\( y \\)  will create string that isn\u0026rsquo;t in the language  \\( L \\)  .\n"}),a.add({id:147,href:'/notes/CS135/CS135-lecture-20210405/',title:"CS135-lecture-20210405",section:"CS135",content:"Introduction to Compilers #  Structure of a compiler #  The economy of programming languages #  Lexical analysis #  Lexical examples #  Lexical specification #  Introduction to parsing #  Predictive parsing #  "}),a.add({id:148,href:'/notes/CS135/CS135-lecture-20210407/',title:"CS135-lecture-20210407",section:"CS135",content:"Compiler front end #  Compilers are presented with source code, and that goes through the front end of the compiler. This front end builds a parse tree and sends that to the back end of the compiler. The back end produces an executable.\nThe front end is composed of multiple steps\n Lexical analysis, sometimes called the scanner. This takes the source code and produces tokens. Syntactic analysis, called a parser. The parser consumes the tokens and produces a parse tree. Semantic analysis. This produces an annotated parse tree. This is stuff like type checking.  Everything in the front end is CPU independent. All it cares about is what language you are in. There is 1 front end per programming language.\nThe back end of the compiler takes a tree and goes through a code generator. This then passes through an optimizer, and then is passed into the final code generation.\nIR = intermediate representation, code that isn\u0026rsquo;t in a CPU\u0026rsquo;s language yet.\nYou only need 1 code generator per CPU. By taking 1 front end and 1 back end, you can have a compiler that compiles a specific language for a specific CPU.\nLexical analysis / scanner #  The scanner takes in source code, and skips all the meaningless stuff in the source code and focuses on the chunks of your program.\nFor example\n// a comment if (x == y) { x = -x; } The parts of this code that is important is the keywords, the variables, the operators, and the grouping elements. Things that are not important are whitespace and comments.\nThe scanner takes this and turns it into a sequence of tokens.\n\u0026quot;if\u0026quot;, \u0026quot;(\u0026quot;, \u0026quot;x\u0026quot;, \u0026quot;==\u0026quot;, ... Interface to a scanner #  We have 2 essential functions:\n next() returns, but does not remove, the next token match(t), if the next token in the stream is t, then remove t from the stream, otherwise throw an exception  Scanner behavior #  When we call next(),\n The first thing we do is skip meaningless characters. Here meaningless characters are things like comments and whitespace. Then, we find the longest prefix that is a legal token (the principle of longest sub string). For example if we see ifelse we don\u0026rsquo;t want to stop after seeing if. The scanner will continue as deep as it can to find the longest legal token. Another example of this is the ==, which should be the equality operator and not 2 assignment operators. Subsequent calls to next() return the found token until match() is called.  When we call match(t),\n if next() == t, then we remove t from the input stream, otherwise throw an exception  Where do scanners come from? #  Scanners can be written by hand. It is possible to completely write both these functions by hand, if the language is simple enough. These are usually a bunch of if elses that compare the tokens. For example, gcc is considered an adhoc scanner, and written this way.\nThe other way to build a scanner is from a scanner generator. The scanner generator is a program that takes in a file, called a lexical specification. This reads the specification, and outputs scanner source code.\nThis is an automated process to build scanner source code.\nLexical specifications #  The first step is to write down all the rules for tokens. An example format for a specification is\nTOKEN_CLASS: regular expression The regular expression here represents one token. For example for an identifier:\nID: [a-zA-Z][a-zA-Z0-9]* So for example:\nWORD: aa+aaa OTHER: aa* So here, next() will skip meaningless chars, and then find the longest prefix that matching a regular expression, it will then return the class and lexem that match.\nSince aaa will match both regular expressions, the scanner will return WORD because it is listed first. The token that is returned will be WORD, \u0026quot;aaa\u0026quot;.\nSo if our input is\n a aa aaa aaaa The whitespace at the beginning will skipped, and the first a will match (because neither of our regular expressions accounts for a space). So the first token that next() returns will be OTHER, \u0026quot;a\u0026quot;. Once this token is consumed via match(), the next token that next() will return is WORD, \u0026quot;aa\u0026quot; because WORD comes before OTHER. This continues on through the stream\u0026hellip;\nLexical specification to DFA algorithm #   Use the RE-to-NFA algorithm for each regular expression.  For aa+aaa:\nFor aa*:\nMake new start state and use   \\( \\lambda \\)  transitions to all NFA start states.  Use the NFA-to-DFA algorithm to create the scanner. Mark each DFA accept state with token class.  "}),a.add({id:149,href:'/notes/CS135/CS135-lecture-20210419/',title:"CS135-lecture-20210419",section:"CS135",content:"Lexical specification to DFA #  WORD: aa+aaa OTHER: aa* Heres an NFA for each regular expression:\nSo now we can take the NFA and make a DFA out of it. Recall, the scanner will need to use a DFA.\nThen we can label the accept states with the lexeme types:\nSo for example, to scan this sequence:\na aa aaa aaaa Nullablity #  A non-terminal, or a sequence of non-terminals, is nullable if the empty string can be derived from it.\nConsider the grammar\n  \\( A \\to AB \\mid \\lambda \\\\ B \\to aA\\)  We look at this and reason what is nullable. Since  \\( A \\)  goes to  \\( \\lambda \\)  ,  \\( A \\)  is nullable. We can also tell that  \\( B \\)  is not nullable because the single production for  \\( B \\)  has a terminal character in it. Once we replace  \\( B \\)  there is no way to remove the terminal, so it is not nullable.\nWe can also use a fixed-point algorithm to tell whether something is nullable. Sometimes a grammar is complicated enough where you can\u0026rsquo;t just tell what is nullable.\nThe algorithm is as follows:\n Write down all of the right hand sides of your productions   \\( AB \\\\ \\lambda \\\\ aA \\)  Write down all of the left hand sides, the non-terminals   \\( A \\\\B \\)  We can initially consider all of them false, as in non of them are nullable.\nWe can then look at the non-terminals and see if they are nullable (true or false), and fill in a new column. Likewise, we can turn any of the non-terminals true if any of their right hand sides are nullable.\nWe continue this until there is no change between the columns. We will continue until we reach a fixed-point (a point where nothing changes). Once we reach this state there will be no iterations done because nothing will continue changing.\nBecause at least one right hand side for  \\( A \\)  is true, that means that  \\( A \\)  can be nullable.\nAfter another iteration, there has been no change, so we are done.\nWe can tell from the column that  \\( A \\)  and  \\( \\lambda \\)  are nullable.\nFirst sets #  First is the set of all characters that the string could start with if its derived.\nFor example:\n \\( A \\to aA \\mid \\lambda \\)  The language of a is  \\( L(A) = \\{\\lambda, a, aa, aaa, \\ldots \\} \\)  . The empty string doesn\u0026rsquo;t have a first character so we ignore it, but all other strings start with an  \\( a \\)  .\nSo  \\( \\text{First } (A) = \\{a\\} \\)  Now consider\n \\( A \\to aA \\mid \\lambda \\mid bA \\)  .\nNow the language is  \\( L(A) = \\{ \\lambda, a, b, aa, ab, ba, bb, \\ldots \\}\\)  . So now the strings can start with an  \\( a \\)  or a  \\( b \\)  .\nSo  \\( \\text{First } (A) = \\{a, b\\} \\)  It is also useful to tell the first of multiple languages, i.e.\nIf  \\( A \\)  is not nullable, then  \\( \\text{First } (AB) \\)  will be equal to  \\( \\text{First } (A) \\)  . If  \\( A \\)  is nullable, then we can say that  \\( \\text{First } (AB) = \\text{First } (A) \\cup \\text{ First } (B)\\)  .\nThere is a fixed-point algorithm to determine if you can\u0026rsquo;t see it initially:\nConsider\n \\( A \\to Ba \\mid Cb \\\\ B \\to b \\mid \\lambda \\\\ C \\to c \\mid \\lambda\\)  We can tell that  \\( B \\)  and  \\( C \\)  are nullable, but  \\( A \\)  is not.\nFirst we can write down all the right hand sides of the productions and start them as the empty set  \\( \\{\\} \\)  . Also, we write down the left hand sides at the bottom.\nThe new column being built will be based on the prior column, and we determine if anything will be added to its first set. Also, consider nullability when checking.  \\( B \\)  is nullable, so the string could start with an  \\( a \\)  .\nAlso consider the non-terminal left hand sides and copy from the upper sets.\nThis continues until the columns don\u0026rsquo;t change anymore.\nAfter one more iteration, there is no change so we are done.\nUnified algorithm #  Recall the rules of the previous algorithms\nConsider this grammar\n \\( T \\to R \\mid aTc \\\\ R \\to bR \\mid \\lambda\\)  We can tell that we will have an equal number of  \\( a \\)  s and  \\( c \\)  s, then we will have  \\( b \\)  in the middle, any number of times.\nThis is generating the language  \\( \\{a^n b^m c^n : n,m \\geq 0\\} \\)  .\nSo which of the above rules apply?\nLets first look at  \\( T \\to R \\)   \\( \\text{First } (R) \\subseteq \\text{ First } (T) \\\\\\)   \\( \\text{Follow } (T) \\subseteq \\text{ Follow } (R) \\)  Now lets look at  \\( T \\to aTc \\\\ \\)   \\( \\{a\\} \\subseteq \\text{ First } (T) \\\\\\)   \\(\\{c\\} \\subseteq \\text{ Follow } (T) \\)  Note that  \\( T \\)  and  \\( R \\)  are nullable.\nLets do  \\( R \\to bR \\\\ \\)   \\( \\{b\\} \\subseteq \\text{ First } (R) \\\\ \\)   \\( \\text{ Follow } (R) \\subseteq \\text{ Follow } (R) \\)  The last one doesn\u0026rsquo;t actually produce any information, any subset is of itself. This is a tautology.\nWe also have to consider  \\( R \\to \\lambda \\)  , which does not produce anything.\nWe also usually add a new start symbol followed by the  \\( \\$ \\)  to indicate the end of the input.\n \\( T\u0026#39; \\to T\\$ \\)  This is to force checking that the whole input is in the language, not just a prefix. Also note that this produces the rule\n \\( \\{ \\$ \\} \\subseteq \\text{ Follow } (T) \\)  Now we can use the fixed-point algorithm to find the specific sets. We have to determine the first sets and follow sets of both  \\( T \\)  and  \\( R \\)  .\n \\( \\text{ First } (T) = \\{a,b\\}\\\\ \\)   \\( \\text{ First } (R) = \\{b\\}\\\\ \\)   \\( \\text{ Follow } (T) = \\{c, \\$\\}\\\\ \\)   \\( \\text{ Follow } (R) = \\{c, \\$\\}\\\\ \\)  Now that we have the minimum sets that satisfy the rules, we can create a prediction table.\n   Production  \\( \\text{First(right hand side)} \\)   If right handside is nullable,  \\( \\text{ Follow(left hand side) }\\)        \\( T \\to R \\)    \\( \\{b\\} \\)    \\( \\{c, \\$\\} \\)      \\( T \\to aTc \\)    \\( \\{a\\} \\)       \\( R \\to bR \\)    \\( \\{b\\} \\)       \\( R \\to \\lambda \\)    \\( \\{\\} \\)    \\( \\{c, \\$\\} \\)      We can use this table for predictive descent by looking at the rows for each non-terminal and making sure the sets are disjoint.\nRecursive-descent predictive-parsing example #  An example parser in racket #  Consider the language\n \\( S\u0026#39; \\to S \\$ \\\\ S \\to aSz \\mid bSy \\mid \\lambda\\)  #lang racket ; next : list -\u0026gt; string or false ; if list not empty and first item a string, eval to first item, else false ; Examples: ; (next \u0026#39;(\u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;)) -\u0026gt; \u0026#34;a\u0026#34; ; (next \u0026#39;(\u0026#34;a\u0026#34; 2 3)) -\u0026gt; \u0026#34;a\u0026#34; ; (next \u0026#39;(1 \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;)) -\u0026gt; false ; (next \u0026#34;a\u0026#34;) -\u0026gt; false ; (next \u0026#39;()) -\u0026gt; false (define (next toks) (cond ((empty? toks) false) ((not (list? toks)) false) ((string? (first toks)) (first toks)) (else false))) (next \u0026#39;(\u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;)) (next \u0026#39;(\u0026#34;a\u0026#34; 2 3)) (next \u0026#39;(1 \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;)) (next \u0026#34;a\u0026#34;) (next \u0026#39;()) ; match : list item -\u0026gt; list or false ; if first item of list equals item return rest of list, else false ; Examples: ; (match \u0026#39;(\u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;) \u0026#34;a\u0026#34;) -\u0026gt; \u0026#39;(\u0026#34;b\u0026#34; \u0026#34;c\u0026#34;) ; (match \u0026#39;(\u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;) \u0026#34;b\u0026#34;) -\u0026gt; false ; (match \u0026#39;(\u0026#34;a\u0026#34;) \u0026#34;a\u0026#34;) -\u0026gt; \u0026#39;() ; (match \u0026#39;() \u0026#34;a\u0026#34;) -\u0026gt; false ; (match false \u0026#34;a\u0026#34;) -\u0026gt; false (define (match toks tok) (cond ((empty? toks) false) ((not (list? toks)) false) ((equal? tok (first toks)) (rest toks)) (else false))) (match \u0026#39;(\u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;) \u0026#34;a\u0026#34;) (match \u0026#39;(\u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;) \u0026#34;b\u0026#34;) (match \u0026#39;(\u0026#34;a\u0026#34;) \u0026#34;a\u0026#34;) (match \u0026#39;() \u0026#34;a\u0026#34;) (match false \u0026#34;a\u0026#34;) ; S\u0026#39; → S$ ; S → aSz | bSy | λ (define (parseS toks) (cond ((not (list? toks)) false) ((empty? toks) toks) ((equal? (first toks) \u0026#34;a\u0026#34;) (match (parseS (match toks \u0026#34;a\u0026#34;)) \u0026#34;z\u0026#34;)) ((equal? (first toks) \u0026#34;b\u0026#34;) (match (parseS (match toks \u0026#34;b\u0026#34;)) \u0026#34;y\u0026#34;)) (else toks))) ; First(S\u0026#39;) = {a,b,$}. On any of these three, (parseS toks) and verify result is end-of-input. (define (parseSprime toks) (cond ((not (list? toks)) false) ((empty? toks) (equal? (parseS toks) empty)) ; $ predicts S\u0026#39; -\u0026gt; S$ ((equal? (next toks) \u0026#34;a\u0026#34;) (equal? (parseS toks) empty)) ; a predicts S\u0026#39; -\u0026gt; S$ ((equal? (next toks) \u0026#34;b\u0026#34;) (equal? (parseS toks) empty)) ; b predicts S\u0026#39; -\u0026gt; S$ (else false))) ; these should be true (parseSprime \u0026#39;(\u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;y\u0026#34; \u0026#34;z\u0026#34;)) (parseSprime \u0026#39;(\u0026#34;a\u0026#34; \u0026#34;a\u0026#34; \u0026#34;z\u0026#34; \u0026#34;z\u0026#34;)) (parseSprime \u0026#39;(\u0026#34;a\u0026#34; \u0026#34;z\u0026#34;)) (parseSprime \u0026#39;(\u0026#34;b\u0026#34; \u0026#34;y\u0026#34;)) ; these should be false (parseSprime \u0026#39;(\u0026#34;a\u0026#34; \u0026#34;b\u0026#34;)) (parseSprime \u0026#39;(\u0026#34;b\u0026#34; \u0026#34;b\u0026#34;)) "}),a.add({id:150,href:'/notes/CS135/CS135-lecture-20210423/',title:"CS135-lecture-20210423",section:"CS135",content:"Introduction to Turing machines #  Note: See text book readings for formal history of the Turing machine.  A Turing machine has a tape that is infinitely long in both directions. The machine has a tape head that can read and write to the tape.\nThe control unit of the Turing machine is an automata. Each transition has a pair   \\( x,y \\)  , follow the arrow if the tape head is over  \\( x \\)  , and do operation  \\( y \\)  .\n \\( y \\)  can be:\n  \\( R \\)  , move right  \\( L \\)  , move left  \\( y \\)  , write  \\( y \\)  , can be a blank (indicated by  \\( B \\)  ).  Turing machines are deterministic, and have no  \\( \\lambda \\)  transitions. The machine halts when no transition matches, so Turing machines don\u0026rsquo;t require a transition for every alphabet character.\nThere are two types:\n Recognizer, which accepts/rejects input. Transducer, which takes input and produces output.  By convention, the tape head always starts at the far left of the input, and ends at the far left of the output.\nFirst example #  With a tape starting with  \\( n \\)  1s, we want the output to be  \\( n \\)  0s.\nSome simple pseudo code might be\nwhile head is over 1 write 0 move R move L while head is over 0 move L move R Make sure to check edge cases, i.e. only a single 1 being on the tape. Also check if the tape is empty initially.\nThis starts out as a self loop on the initial state that has the pair  \\( 1,0 \\)  .\nThe move R can be added as another pair  \\( 0,R \\)  .\nNote: This would be a problem if we had any 0s in the input to begin with, we are assuming the input is good. To handle this we could have a state like\nWhich would halt on a 0 in the initial input.\n When this loop finishes, it means we are no longer over a 1. The head should be over a blank. So to transition to the next state we have the pair  \\( B,L \\)  .\nThe next loop can be handled by  \\( 0,L \\)  . And when we reach the far right blank we can move right.\nThe last state has no arrows, so the program will halt.\nSecond example #  The pair  \\( B,B \\)  is kind of like \u0026ldquo;no operation\u0026rdquo;.\nTesting #  "}),a.add({id:151,href:'/notes/CS135/CS135-lecture-20210426/',title:"CS135-lecture-20210426",section:"CS135",content:"Parsing using Java #  Consider\n  \\( S\u0026#39; \\to S\\$ \\\\ S \\to aSx \\mid bSx \\mid \\lambda \\)  Heres the predictor table\n   Production  \\( \\text{First (right hand side)} \\)   If nullable,  \\( \\text{Follow(left hand side)} \\)        \\( S \\to aSx \\)    \\( a \\)       \\( S \\to bSx \\)    \\( b \\)       \\( S \\to \\lambda \\)     \\( x,\\$ \\)      In code:\nWe are using a queue of strings to simulate the scanner.\nimport java.util.Queue; import java.util.LinkedList; import java.util.Arrays; public class ParseTest { private static Queue\u0026lt;String\u0026gt; toks; private static boolean isEmpty() { return toks.isEmpty(); } private static String next() { return toks.element(); } private static void match(String tok) { if (isEmpty() || !next().equals(tok)) throw new IllegalStateException(\u0026#34;Error on match(\u0026#34; + tok + \u0026#34;)\u0026#34;); toks.remove(); } public static void parseS() { if (isEmpty()) { // $ predicts S-\u0026gt; \\lambda, so leave toks alone  } else if (next().equals(\u0026#34;a\u0026#34;)) { match(\u0026#34;a\u0026#34;); parseS(); match(\u0026#34;x\u0026#34;); } else if (next().equals(\u0026#34;b\u0026#34;)) { match(\u0026#34;b\u0026#34;); parseS(); match(\u0026#34;x\u0026#34;); } else if (next().equals(\u0026#34;x\u0026#34;)) { // x predicts S-\u0026gt; \\lambda, so leave toks alone  } else { throw new IllegalStateException(\u0026#34;Unexpected: \u0026#34; + next()); } } public static void main(String[] args) { toks = new LinkedList\u0026lt;String\u0026gt;(Arrays.asList(\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;x\u0026#34;,\u0026#34;x\u0026#34;)); parseS(); System.out.println(isEmpty() ? \u0026#34;accept\u0026#34; : \u0026#34;reject\u0026#34;); } } Creating a parse tree #  Using the previous language, the string  \\( abxx \\)  \u0026rsquo;s structure isn\u0026rsquo;t at first clear. Lets turn it into a tree:\nIt is useful to represent files as a tree (like structured XML files), to make it easy to traverse the data.\nWe should be able to take a grammar and turn it into a tree that represents the structure of the input. Whenever we do a parse, it returns a reference to a node representing that symbol.\nEach leaf will be a node, and each interior non-terminal will also be a node. The non-terminals have a responsibility to build a node and return a reference to it.\nWe will use Java\u0026rsquo;s DefaultMutableTreeNode class, which implements TreeNode.\nimport javax.swing.tree.DefaultMutableTreeNode; // other existing methods from above  public static DefaultMutableTreeNode parseS() { DefaultMutableTreeNode rval = new DefaultMutableTreeNode(\u0026#34;S\u0026#34;); if (isEmpty() || next().equals(\u0026#34;x\u0026#34;)) { // S --\u0026gt; lambda  rval.add(new DefaultMutableTreeNode(\u0026#34;\u0026#34;)); } else if (next().equals(\u0026#34;a\u0026#34;) || next().equals(\u0026#34;b\u0026#34;)) { // S --\u0026gt; aSx | bSx  String tok = next(); match(tok); rval.add(new DefaultMutableTreeNode(tok)); rval.add(parseS()); match(\u0026#34;x\u0026#34;); rval.add(new DefaultMutableTreeNode(\u0026#34;x\u0026#34;)); } else { // Unexpected token  throw new IllegalStateException(\u0026#34;Unexpected: \u0026#34; + next()); } return rval; } Same method but thoroughly commented import javax.swing.tree.DefaultMutableTreeNode; // ....  public static DefaultMutableTreeNode parseS() { // Create node to be returned and label it \u0026#34;S\u0026#34;  DefaultMutableTreeNode rval = new DefaultMutableTreeNode(\u0026#34;S\u0026#34;); if (isEmpty()) { // S non-terminal is nullable, so $ and x both indicate S -\u0026gt; lambda  // Make child be a leaf node labeled \u0026#34;\u0026#34; (empty string)  rval.add(new DefaultMutableTreeNode(\u0026#34;\u0026#34;)); } else if (next().equals(\u0026#34;a\u0026#34;)) { // Match \u0026#34;a\u0026#34; and add first child, a leaf node labeled \u0026#34;a\u0026#34;  match(\u0026#34;a\u0026#34;); rval.add(new DefaultMutableTreeNode(\u0026#34;a\u0026#34;)) // parseS() and have resulting subtree be our second child  rval.add(parseS()); // Match \u0026#34;x\u0026#34; and add third child, a leaf node labeled \u0026#34;x\u0026#34;  match(\u0026#34;x\u0026#34;); rval.add(new DefaultMutableTreeNode(\u0026#34;x\u0026#34;)) } else if (next().equals(\u0026#34;b\u0026#34;)) { // Match \u0026#34;b\u0026#34; and add first child, a leaf node labeled \u0026#34;b\u0026#34;  match(\u0026#34;b\u0026#34;); rval.add(new DefaultMutableTreeNode(\u0026#34;b\u0026#34;)) // parseS() and have resulting subtree be our second child  rval.add(parseS()); // Match \u0026#34;x\u0026#34; and add third child, a leaf node labeled \u0026#34;x\u0026#34;  match(\u0026#34;x\u0026#34;); rval.add(new DefaultMutableTreeNode(\u0026#34;x\u0026#34;)) } else if (next().equals(\u0026#34;x\u0026#34;)) { // S non-terminal is nullable, so $ and x both indicate S -\u0026gt; lambda  // Make child be a leaf node labeled \u0026#34;\u0026#34; (empty string)  rval.add(new DefaultMutableTreeNode(\u0026#34;\u0026#34;)); } else { // Unexpected token, so throw an exception  throw new IllegalStateException(\u0026#34;Unexpected: \u0026#34; + next()); } return rval; }    Note: The add() method will create a new child at the next index.  When we want to print out this tree we can use a method like so:\npublic static void printLeaves(TreeNode noderef) { if (noderef.getChildCount()==0) { // noderef is a leaf node  String label = noderef.toString(); System.out.print(label); } else { for (int i=0; i\u0026lt;noderef.getChildCount(); i++) { printLeaves(noderef.getChildAt(i)); } } } "}),a.add({id:152,href:'/notes/CS135/CS135-lecture-20210428/',title:"CS135-lecture-20210428",section:"CS135",content:"Acceptance algorithm #  Decision problems #  A decision problem is a problem that has a binary answer, true or false (or accept and reject). A decision problem may be something like: \u0026ldquo;given   \\( x \\)  , is  \\( x \\)  prime?\u0026rdquo; We can use decision problems to prove the limitations for Turing machines, because there isn\u0026rsquo;t a pumping lemma for Turing machines.\nIf we can show that a decision problem can\u0026rsquo;t be solved, then we can show that computers can\u0026rsquo;t solve the same problem.\nConsider this theorem: There is no algorithm accept(m,x), where m is another algorithm and x is an input, that for every m and x returns true if m outputs \u0026ldquo;accept\u0026rdquo; for x and \u0026ldquo;reject\u0026rdquo; otherwise.  Why not? Why don\u0026rsquo;t we just try to run the algorithm m on the input x?\naccept(m,x): tmp = m(x) if tmp == \u0026quot;accept\u0026quot;: return true return false What if m takes a long time? For m to output \u0026ldquo;accept\u0026rdquo; it has to finish its computation and output. The complement of that is that it doesn\u0026rsquo;t return \u0026ldquo;accept\u0026rdquo;, OR it doesn\u0026rsquo;t finish its computation (infinte loop). If m is still running, we don\u0026rsquo;t know if its going to halt and accept, halt and reject, or never halt. So, the above pseudocode does not work.\nThe Towers of Hanoi #  The game where there is 3 pegs, and discs that get shorter and shorter up on the peg. The rule is you can only move one disc at a time, and you can\u0026rsquo;t put a bigger disc on top of a smaller disc.\nThere is a strategy for doing this: take all but the biggest disc and move it to the far peg, move the biggest disc to the middle, and move the discs back to the first disc.\nThis algorithm has a runtime complexity of  \\( O(2^n) \\)  . So if the game starts with  \\( n = 64 \\)  discs, the runtime is going to take a really long time. There is no algorithmic way to tell whether we are stuck in an infinite loop, or that the algorithm is simply taking a really long time to complete.\nA proof sketch to show there isn\u0026rsquo;t an accept algorithm #  We will assume accept(m,x) exists. Lets define an algorithm D(m), where m is an algorithm:\nD(m): if accept(m,m): output reject else: output accept Note: accept(m,m) may look weird, but its really just testing the source code of m on itself. This is similar to a C compiler being written in C (a common test is to see if a C compiler can compile itself and output a functioning compiler).  D(m) is using accept(m,x) as a subroutine. So lets try to use it by running D(D). This would result in this substitution:\nD(D): if accept(D,D): output reject else: output accept So if D accepts D, then accept(D,D) is true by definition. But,\n if D accepts D, when we run D(D), accept(D,D) will be true and the output will be \u0026ldquo;reject.\u0026rdquo; if D doesn\u0026rsquo;t accept D, it will output \u0026ldquo;accept.\u0026rdquo;  These are contradictions.\nAll of this works because we assume that accept(m,x) exists.\nReductions #  A reduction, in a sense, is a way to say that if one problem isn\u0026rsquo;t possible, than the other problem isn\u0026rsquo;t possible also. You see this in NP-complete problems a lot.\nProblem A \u0026ldquo;reduces\u0026rdquo; to Problem B, if a Problem A Solver could be constructed using a Problem B Solver.\nASolver(a_instance): ... BSolver ... returns a_answer ASolver takes an instance of A, and returns an answer. Notice that ASolver uses the BSolver subroutine. Then it shows that problem A reduces to problem B.\nThis pseudocode shows that if there exists a BSolver, that implies that there exists an ASolver.\nConcrete example #  Consider a function that finds the median from an array of numbers. Lets assume that the array is odd length so the median is well defined.\nFindMedian(arr): sorted_array = sort(arr) ans = sorted_array[len(arr) / 2] return ans Since this FindMedian function is possible, if the sort function is available. That means that FindMedian reduces to sort. So if there exists a sorting algorithm, then there exists a median finder algorithm.  \\[\\begin{aligned} \\exists \\text{ sort} \\to \\exists \\text{ median} \\end{aligned}\\]  A more abstract example #  Consider the function GetRich\nGetRich(): lotto = Genie(\u0026quot;next lottery winner\u0026quot;) return lotto So the algorithm solves the problem of how to get rich, which uses a subroutine that gives the lottery numbers. So GetRich reduces to Genie.  \\[\\begin{aligned} \\exists \\text{ Genie} \\to \\exists \\text{ GetRich} \\end{aligned}\\]  Since there is no genie algorithm, we have no way of writing a get rich algorithm.\nHow to use reductions to show something doesn\u0026rsquo;t exist #  Recall contrapositives:\n \\[\\begin{aligned} p \\to q \\equiv \\neg q \\to \\neg p \\end{aligned}\\]  This can be represented as a truth table:\nSo these 2 statements are logically equivalent.\nSince the existence of BSolver implies the existence of ASolver, we can write this as a contrapositive as: \u0026ldquo;if there does not exists an ASolver, than BSolver doesn\u0026rsquo;t exist either.\u0026rdquo;\nAcceptance #  Recall: accept(m,x) is trying to output true if algorithm m accepts input x, otherwise false.\nWe\u0026rsquo;ve previously established that accept(m,x) is not computable on all (m,x). The reason why this is not possible is because it could go into an infinite loop and never terminate.\nTo show BSolver cannot exist:\naccept(m, x): ... BSolver ... return answer This would show that the existence of BSolver implies the existence of accept, but we are more interested in the contrapositive  \\[\\begin{aligned} \\neg \\exists \\text{ accept} \\to \\neg \\exists \\text{ BSolver} \\end{aligned}\\]  Because accept cannot exist, neither can BSolver.\nThe Halting problem #  This is possibly the most famous non-computable problem.\nhalt(m,x) outputs true if m halts on x. m is an algorithm, and x is an input to that algorithm. It can either\n Halt on x and accept Halt not on x and reject or, get stuck in an infinite loop  We can show this isn\u0026rsquo;t computable by using our template\naccept(m,x): if halt(m,x): return m(x) else: return false If there existed halt(m,x) that worked on all inputs, then accept(m,x) would exist.  \\[\\begin{aligned} \\exists \\text{ halt(m,x)} \\to \\exists \\text{ accept(m,x)} \\end{aligned}\\]  But we are interested in the contrapositive:  \\[\\begin{aligned} \\neg \\exists \\text{ accept(m,x)} \\to \\neg \\exists \\text{ halt(m,x)} \\end{aligned}\\]  Since accept(m,x) doesn\u0026rsquo;t exist on all inputs, halt(m,x) also doesn\u0026rsquo;t exist.\n"}),a.add({id:153,href:'/notes/CS135/CS135-lecture-20210505/',title:"CS135-lecture-20210505",section:"CS135",content:"bf #  A programming language that is reminiscent of a Turning machine.\nRead more\nThere is a tape and a pointer to that tape. The tape holds data, and its infinite to right. Each position on the tape is initialized to a 0.\n00000000000000000... ^ Each position holds a single byte. The tapehead starts at the very most left position.\nThe program is a sequence of characters. The legal characters are\n+ // ++*ptr - // --*ptr \u0026gt; // ++ptr \u0026lt; // --ptr [ // while(ptr) { ] // } , // scanf(\u0026quot; %c\u0026quot;, ptr) . // putchar(*ptr) where ptr is current pointer to the tape in C.\nAn example program may look like\n[.\u0026gt;.\u0026lt;,\u0026gt;,] Note: Square braces must be properly nested.  Each position on the tape is a char in C, so values may overflow from 127 to -128 if incremented. When you use the , command, the values read from stdin are ASCII values.\nThe language is considered Turing complete, because it has the same expressive power as a Turing machine.\nInput/output #  If your program is the input symbol followed by the output symbol:\n,.and you input the 1 key, the tape will look like\n49 0 0 0 0 0 ... ^ and a 1 will be printed.\nLooping #  The [] characters essentially construct a while loop where the pointer is the check. This looks like a while loop in C:\nwhile (*ptr) // [ { } // ] The loop can be optimized by checking the boolean on the end bracket ], and either go back to the [ symbol, or just move forward and be done.\nA program to calculate a sum #  If we want to add   \\( 2 \u0026#43; 3 \\)  , we can read in each value to a tape cell, so our tape looks like this:\n2 3 0 0 ... So lets start by reading the 2 characters in from input:\n.read \u0026gt;move right .read [while not 0 -decrement c0 \u0026gt;move right +increment c1 \u0026lt;move left ]\u0026lt;move left .print result After this runs, the tape will look like\n5 0 0 ... So if we run this program with the input $% and the tape will be\n36 37 0 0 ... and after the program complete it will look like this:\n73 0 0 0 ... and an I will print out.\nA bf interpreter in Java #  import java.nio.file.Files; import java.nio.file.Paths; import java.io.IOException; public class Bf { public static void main(String[] args) throws IOException { String program; byte[] data = new byte[30000]; int didx = 0; int pidx = 0; try { program = Files.readString(Paths.get(\u0026#34;bf.txt\u0026#34;)); program = program.replaceAll(\u0026#34;[^-+\u0026lt;\u0026gt;,\\\\.\\\\[\\\\]]\u0026#34;,\u0026#34;\u0026#34;); } catch (Exception e) { System.out.println(\u0026#34;Could not read bf.txt.\u0026#34;); return; } while (pidx \u0026lt; program.length()) { char pc = program.charAt(pidx); if (pc==\u0026#39;+\u0026#39;) data[didx] += 1; else if (pc==\u0026#39;-\u0026#39;) data[didx] -= 1; else if (pc==\u0026#39;\u0026gt;\u0026#39;) didx += 1; else if (pc==\u0026#39;\u0026lt;\u0026#39;) didx -= 1; else if (pc==\u0026#39;.\u0026#39;) System.out.print((char)data[didx]); else if (pc==\u0026#39;,\u0026#39;) data[didx] = (byte)System.in.read(); else if (pc==\u0026#39;]\u0026#39; \u0026amp;\u0026amp; data[didx]!=0) { int balance=1; do { pidx -= 1; if (program.charAt(pidx)==\u0026#39;[\u0026#39;) balance -= 1; if (program.charAt(pidx)==\u0026#39;]\u0026#39;) balance += 1; } while (program.charAt(pidx)!=\u0026#39;[\u0026#39; || balance!=0); } else if (pc==\u0026#39;[\u0026#39; \u0026amp;\u0026amp; data[didx]==0) { int balance=1; do { pidx += 1; if (program.charAt(pidx)==\u0026#39;[\u0026#39;) balance += 1; if (program.charAt(pidx)==\u0026#39;]\u0026#39;) balance -= 1; } while (program.charAt(pidx)!=\u0026#39;]\u0026#39; || balance!=0); } pidx += 1; } System.out.println(); System.out.println(\u0026#34;Program complete!\u0026#34;); for (int i=0; i\u0026lt;10; i++) System.out.print(data[i] + \u0026#34; \u0026#34;); System.out.println(); System.out.println(\u0026#34;didx=\u0026#34; + didx); } } It is traditional to have the tape be 30,000 cells long, all initialized to 0. didx is the data pointer. pidx is a pointer to the source program.\n"}),a.add({id:154,href:'/notes/CS135/CS135-lecture-20210511/',title:"CS135-lecture-20210511",section:"CS135",content:"More reduction examples #  Recap on reductions: A reduction is simply a hypothetical algorithm.\nASolver(a) ... BSolver(...) ... ASolver relies on the existence of BSolver. So ASolver reduces to BSolver. So if BSolver exists, then ASolver exists.\nAcceptance problem #  If we have an algorithm accept(m,x), we are wondering if we run the algorithm m on input x, it will either output \u0026ldquo;accept\u0026rdquo; or \u0026ldquo;reject\u0026rdquo;. The claim is there is no algorithm that can produce this on all inputs (m,x).\nThe idea of reductions gives us the framework to show that other algorithms cannot exist.\nSo if we establish that accept(m,x) isn\u0026rsquo;t computable on all inputs, then we can also show that subroutines that accept may use also don\u0026rsquo;t exist.\naccept(m,x) ... subroutine(...) ... Since accept reduces to subroutine, subroutine also doesn\u0026rsquo;t exist.\naccept(m,x): construct temporary new program m': m'(w): if w != x: output reject else output m(x) output acceptAny(m') acceptAny(m') outputs \u0026ldquo;accept\u0026rdquo; if m' accepts any input.\nLets say that accept is running, and it is passed the algorithm m, and an input x. The first thing it does is create a new program m'. The new program that is created is passed to acceptAny. If m' doesn\u0026rsquo;t accept anything, it outputs reject on almost everything. The only time that it outputs \u0026ldquo;accept\u0026rdquo;, is when m accepts x. acceptAny will be true, if and only if m accepts x. So accept works only if acceptAny works.\nBuilding and interpreting bf parse trees #  We are going to write some Java that parses this grammar:\nThis will be based on our Java parser a couple lectures back.\nVisualizing the tree for the program:\n[..]This will first follow the production   \\( S \\to LS \\)  Then we follow the production  \\( S \\to CS \\)  "}),a.add({id:155,href:'/notes/CS137/CS137-lecture-20210126/',title:"CS137-lecture-20210126",section:"CS137",content:"csc137syl Spring-2021.docx\n"}),a.add({id:156,href:'/notes/CS137/CS137-lecture-20210128/',title:"CS137-lecture-20210128",section:"CS137",content:"Ch1.pdf\n"}),a.add({id:157,href:'/notes/CS137/CS137-lecture-20210202/',title:"CS137-lecture-20210202",section:"CS137",content:"CSc 137 Presentation -Topics-1-1.docx\nHow to convert 5.375 to a floating point representation using IEEE 754:\n Convert the number to a binary representation Start with the whole part: 5 101 Then do the fractional part: .375 Using successive multiplication   \\[0.375 * 2 = 0 \u0026#43; .75 \\\\ 0.75 * 2 = 1 \u0026#43; .5 \\\\ 0.5 * 5 = 1 \u0026#43; .0 \\]  So .375 = .011 So 5.375 = 101.011 in fixed point  Continued on next lecture  "}),a.add({id:158,href:'/notes/CS137/CS137-lecture-20210204/',title:"CS137-lecture-20210204",section:"CS137",content:"Continued from last lecture:\nHow to convert 5.375 to a floating point representation using IEEE 754:\n  Convert the number to a binary representation Start with the whole part: 5 = 101. Then do the fractional part: .375 Using successive multiplication\n  \\[ \\begin{aligned} 0.375 * 2 = 0 \u0026#43; .75 \\\\ 0.75 * 2 = 1 \u0026#43; .5 \\\\ 0.5 * 5 = 1 \u0026#43; .0 \\end{aligned} \\]  So .375 = 011. So 5.375 = 101.011 in fixed point\n  Convert the number to scientific notation (move the decimal point over, \u0026ldquo;normalize\u0026rdquo;)\n   \\[ \\begin{aligned} 101.011 = 1.01011 \\cdot 2^2 \\end{aligned} \\]  So we have 1.01011 * 2^2. Our unbiased exponent is 2 and our mantissa is 01011.\nCalculate the bias exponent Biased offset is 7 because we are using 4 bits to represent the biased exponent.   \\[ \\begin{aligned} \\text{unbiased exponent } \u0026#43; \\text{ biased offset} \u0026amp;= \\text{biased exponent } \\\\ 2 \u0026#43; 7 \u0026amp;= 9 \\end{aligned} \\]  So our biased exponent is 9 = 1001.\n Fusion of floating point (put it all together) We are using 16 bits to represent our floating point numbers. The most significant bit is the sign bit, 0 for positive, 1 for negative. Then comes our 4 bit biased exponent. Last comes our mantissa, 11 bits set aside for it. So, [1 bit sign][4 bit biased exponent][11 bit mantissa]\n   Sign bit Biased exponent Mantissa     0 1001 01011    So our full number is: 5.375 = 0100101011000000 (pad the right side of the mantissa with zeros until you\u0026rsquo;ve used 11 bits.\n  Convert to hex 0100 1010 1100 0000 = 0x4AC0\n  "}),a.add({id:159,href:'/notes/CS137/CS137-lecture-20210209/',title:"CS137-lecture-20210209",section:"CS137",content:"Ch2.pdf\nLUT = lookup table\nSOP = sum of products\nDeMorgan\u0026rsquo;s theorem #   Two or more variables NAND\u0026rsquo;d together is the same as the two terms inverted and OR\u0026rsquo;d  Two or more variables NOR\u0026rsquo;d together is the same as the two variables inverted and AND\u0026rsquo;d together   Lets show this via tables for these two equations:\n  \\[\\begin{aligned} F1 \u0026amp;= F2 \\\\ \\neg(A \\cdot B) \u0026amp;= \\neg A \u0026#43; \\neg B \\end{aligned}\\]  Here is a table for  \\(F1\\)  :\n    \\(A B\\)    \\(A \\cdot B\\)    \\(\\neg(A \\cdot B)\\)       0 0 0 1   0 1 0 1   1 0 0 1   1 1 1 0    Here is a table for  \\(F2\\)  :\n    \\(A B\\)    \\(\\neg A \\neg B\\)    \\(\\neg A \u0026#43; \\neg B\\)       0 0 1 1 1   0 1 1 0 1   1 0 0 1 1   1 1 0 0 0    Notice that the output of each table is the same, thus the theorem is true.\n"}),a.add({id:160,href:'/notes/CS137/CS137-lecture-20210211/',title:"CS137-lecture-20210211",section:"CS137",content:" A Karnaugh map is a graphical representation of a logic function. The map for   \\(n\\)  -input logic function is an array with  \\(2^n\\)  cells, (one for each possible input combination). To represent a logic function in a k-map, we copy the 1s from the truth table to the corresponding cells. Implicants are squares or rectangles made up of minterms Pairs of adjacent 1 cells in the k-map have minterms that differ in ONLY 1 variable The minterm pairs can be combined into a single product term using the generalization of theorem T10:  T10) = term   Thus, we can use k-maps to simplify the sum of the function.  "}),a.add({id:161,href:'/notes/CS137/CS137-lecture-20210216/',title:"CS137-lecture-20210216",section:"CS137",content:"Ch3.pdf\nPropagation delay is the time delta between the input and the output.\nDesign of a full adder #  Carry Propagate Adder (CPA)\n Full adder is an arithmetic logic unit or circuit to add two single digit numbers with Carry-in It is still combinational circuit with inputs Ax and Bx  Sx is the sum (1 bit) C-in carry in Cx is the carry out   Adder is also called Ripple Carry Adder (RCA) Fundamental circuit for an adder and has longest propagation delay that is proportional to the number of the carry bits  To estimate the propagation delay of an   \\( n \\)  -bit CPA:\n \\[\\begin{aligned} \\Delta \\text{ CPA } (n) = \\left[ (n-1) \\cdot \\Delta FA_C \\right] \u0026#43; \\Delta FA_S \\end{aligned}\\]  eg calculating propagation delay #  Design of a full adder #     A B S C     0 0 0 0   0 1 1 0   1 0 1 0   1 1 0 1    Lets add\nA = 0111 B = 1111\n   Ai Bi C-in S C-out     1 1 0 0 1   1 1 1 1 1   1 1 1 1 1   0 1 1 0 1    "}),a.add({id:162,href:'/notes/CS137/CS137-lecture-20210218/',title:"CS137-lecture-20210218",section:"CS137",content:"CPA cont. #  Design a 1-bit full adder #     Ax Bx C-in Sx C-out     0 0 0 0 0   0 0 1 1 0   0 1 0 1 0   0 1 1 0 1   1 0 0 1 0   1 0 1 0 1   1 1 0 0 1   1 1 1 1 1    We can reduce the diagonals in Sx: note that Sx is true if only 1 of the inputs is on, or all are on (this is XOR).\n"}),a.add({id:163,href:'/notes/CS137/CS137-lecture-20210223/',title:"CS137-lecture-20210223",section:"CS137",content:"CS137-lecture-20210223 #  DeMorgan\u0026rsquo;s Theorem #  Theorem 1:   \\(\\neg(x \\cdot y) = \\neg x \u0026#43; \\neg y\\)  Theorem 2:  \\(\\neg(x \u0026#43; y) = \\neg x \\cdot \\neg y\\)  Steps to convert to all NAND gates:\n  Replace each NOT gate with its equivalent NAND gate. Connecting the inputs of a NAND gate makes a NOT gate.\n  Place two NOT gates on each of signals going into the final OR.\n  Replace each AND NOT combo with a NAND gate.\n  "}),a.add({id:164,href:'/notes/CS137/CS137-lecture-20210225/',title:"CS137-lecture-20210225",section:"CS137",content:"Multiplexers #  An everyday example of a multiplexer is a TV remote.\n Selecting of data or information is a critical function in a digital system and computers. A multiplexer (mux for short) is a digital switch. Mux is a circuit used to select and route any of the several inputs to an output signal. Mux is a combination circuit, it has the following:     \\( 2^n \\)  inputs  \\( n \\)  control inputs, selector signals one set of output   For a mux, the value of the control inputs (selector signal) determines the data input that is selected. Multiplexer means many into one. A simple example of a non-electronic circuit of a mux is a single pole multiposition switch. Multi-position switches are widely used in many electronics circuit, however, circuits that operate at high speed require the multiplexer to be automatically selected. A mechanical switch cannot perform this task satisfactorily. Therefore, a mux is used to perform high speed switching and are constructed for digital circuits.  Example X and Y are inputs, S is the selector signal, r is the output.\n2 to 1 means that it has a total of 2 inputs, with 1 output. If you called this a \u0026ldquo;1 bit mux\u0026rdquo;, then each X and Y would only have one input (0 or 1).\nLets make a truth table of this:\n   Selector Input Input Output     S X Y r   0 0 0 0   0 0 1 1   0 1 0 0   0 1 1 1   1 0 0 0   1 0 1 0   1 1 0 1   1 1 1 1    So this is our equation we can simplify:\n \\[\\begin{aligned} r = \\bar{s} \\bar{x} y \u0026#43; \\bar{s} x y \u0026#43; s x \\bar{y} \u0026#43; s x y \\end{aligned}\\]  Simplifying using a K-map:\nSo, the outputs are selected based on the selector signal. Outputs, Y when S = 0; X when S = 1.\n \\[\\begin{aligned} r = \\bar{s} y \u0026#43; s x \\end{aligned}\\]    "}),a.add({id:165,href:'/notes/CS137/CS137-lecture-20210302/',title:"CS137-lecture-20210302",section:"CS137",content:"Sequential Circuits #  In combinational circuits, the outputs are only dependent on the inputs. In sequential circuits, the outputs depend on the inputs, and the previous state of the circuit.\nCore modules #  S-R Latches\n Latches are basic building blocks of flip-flops (basic memory unit) A 1 bit latch will store 1 bit, 4 bit latch stores 4 bits, and so forth \u0026hellip; Two types of memory elements based on the type of trigger that is suitable to operate Latches, asynchronous Latches operate with an enable signal, which is level sensitive  D flip-flop\n Basic memory storage device Block diagram of a D flip flop Flip flops, synchronous (the device samples its input based on a common clock) Flip flops are edge sensitive Doesn\u0026rsquo;t sample an input unless a clock comes in, clock signal needed to change states D flip flops is designed using S-R latches Similar to S-R latch, only we use set and reset function. (Ties D input to S and NOT D to R).  S-R flip flop with NOR gates #        \\( S \\)    \\( R \\)    \\( Q_t \\)    \\( Q_{t\u0026#43;1} \\)       0 0     0 1     1 0     1 1  Undefined    Finished in next lecture\n"}),a.add({id:166,href:'/notes/CS137/CS137-lecture-20210304/',title:"CS137-lecture-20210304",section:"CS137",content:'Sequential circuits cont. #  Creating the S-R latch cont. #        \\( S \\)    \\( R \\)    \\( Q_t \\)    \\( Q_{t\u0026#43;1} \\)       0 0  \\( Q_t \\)    \\( Q_t \\)     0 1 0 0   1 0 1 1   1 1  Undefined     \\( Q_{t \u0026#43; 1} \\)  is the "next output."  Case 1:  \\( S = 0 \\)  ,  \\( R = 0 \\)   \\[\\begin{aligned} Q_{t\u0026#43;1} \u0026amp;= \\overline{0 \u0026#43; \\overline{Q_t}} = Q_t \\\\ \\overline{Q_{t\u0026#43;1}} \u0026amp;= \\overline{0 \u0026#43; Q_t} = \\overline{Q_t} \\end{aligned}\\]  Case 2:  \\( S = 0 \\)  ,  \\( R = 1 \\)   \\[\\begin{aligned} Q_{t\u0026#43;1} \u0026amp;= \\overline{1 \u0026#43; \\overline{Q_t}} = \\overline{1} = 0 \\\\ \\overline{Q_{t\u0026#43;1}} \u0026amp;= \\overline{0 \u0026#43; \\overline{Q_t}} = \\overline{Q_t} \\end{aligned}\\]  Case 3:  \\( S = 1 \\)  ,  \\( R = 0 \\)   \\[\\begin{aligned} Q_{t\u0026#43;1} \u0026amp;= \\overline{0 \u0026#43; \\overline{Q_t}} = 1 \\\\ \\overline{Q_{t\u0026#43;1}} \u0026amp;= \\overline{1 \u0026#43; Q_t} = 0 \\end{aligned}\\]  Case 4:  \\( S = 1 \\)  ,  \\( R = 1 \\)   \\[\\begin{aligned} Q_{t\u0026#43;1} \u0026amp;= \\overline{1 \u0026#43; \\overline{Q_t}} = \\overline{1} = 0 \\\\ \\overline{Q_{t\u0026#43;1}} \u0026amp;= \\overline{1 \u0026#43; Q_t} = \\overline{1} = 0 \\end{aligned}\\]  Since the output and its complement are the same, this case is wrong.\n'}),a.add({id:167,href:'/notes/CS137/CS137-lecture-20210309/',title:"CS137-lecture-20210309",section:"CS137",content:"Exam 1 review #  "}),a.add({id:168,href:'/notes/CS137/CS137-lecture-20210316/',title:"CS137-lecture-20210316",section:"CS137",content:"Sequential circuits #  Ch5.pdf\n All small and large sequential circuits are made of flip-flops and set of combinational circuits. Contrary to combinational circuits, a sequential circuit design has states and transitions from current state to next state. A sequential circuit design problem is typically modeled as a finite state diagram (FSD). An FSD consists of circles as states and arrows as transitions, which specifies the behavior of the system.  Sequential circuit as a finite state machine #   Finite state diagrams (FSD) describe the behavior of the system. Finite state machine design are categorized into Mealy, Moore, or hybrid. Mealy is a FSM whose output values are determined by its current state and current inputs. In contrast, Moore machines output values are determined solely by its current state. A register is used as a storage module to save the output of the combinational circuit.  To determine what gets loaded into the register, it depends on the enable bit and the input.\n"}),a.add({id:169,href:'/notes/CS137/CS137-lecture-20210318/',title:"CS137-lecture-20210318",section:"CS137",content:"FSM cont. #  Design rules #   If we cannot determine function(s) of combinational circuit(s) in advance:  Model FSM as FSD  May need to design bit-slice 1st   Determine number of flip flops (dependent on the number of states you need) Convert the FSD to truth table Find minimal expressions for next state variable(s) and output(s) Draw the complete circuit with flip-flops   Otherwise  Use bit-serial design with known modules Or, bit-parallel design with known modules    Example #  Lets design a Moore state machine that accepts the string   \\( 101 \\)  .\nAs a box diagram:\nStep 1, create a finite state diagram:\n"}),a.add({id:170,href:'/notes/CS137/CS137-lecture-20210330/',title:"CS137-lecture-20210330",section:"CS137",content:"Finite state machine design cont. #  Moore machines #   Output depends only upon present state If input changes, output does not change More number of states are required There is more hardware requirement They react slower to inputs (one clock cycle later) Synchronous output and state generation Output is placed on states Easy to design  Step 1: create a FSD\nStep 2: determine the minimum number of states/bits required to store states\nNumber of bits =   \\( \\lceil \\log_2(k) \\rceil = \\lceil \\log_2(4)\\rceil = 2 \\)  , where  \\( k = \\text{number of states} \\)  .\nStep 3: From FSD, create the truth table for NSG (next state generator)\nWe can let our states be represented by binary values:\n \\( A = 00 \\\\ B = 01 \\\\ C = 10 \\\\ D = 11\\)  We can create our OG (output generator)\nStep 4: Truth table, determine min SOP expression for each state variable  \\( d_1, d_0 \\)  and output  \\( Z \\)  .\nWe can start with  \\( d_0 \\)  , note that  \\( d_0 \\)  is exactly the same as  \\( x \\)  .\n \\[\\begin{aligned} d_0 = x \\end{aligned}\\]  Then we can build a SOP for  \\( d_1 \\)  (and simplify):\n \\[\\begin{aligned} d_1 \u0026amp;= \\overline{x} \\overline{q_1} q_0 \u0026#43; \\overline{x} q_1 q_0 \u0026#43; x q_1 \\overline{q_0} \\\\ \u0026amp;= \\overline{x} (\\overline{q_1} q_0 \u0026#43; q_1 q_0) \u0026#43; x q_1 \\overline{q_0} \\\\ \u0026amp;= \\overline{x} q_0 \u0026#43; x q_1 \\overline{q_0} \\end{aligned}\\]  We can also find the SOP for our output  \\( Z \\)  :\n \\[\\begin{aligned} Z = q_0 q_1 \\end{aligned}\\]  "}),a.add({id:171,href:'/notes/CS137/CS137-lecture-20210401/',title:"CS137-lecture-20210401",section:"CS137",content:"Finite state machine design cont. #  Moore machine design cont. #  Recall\n  \\[\\begin{aligned} d_0 \u0026amp;= x \\\\ d_1 \u0026amp;= \\overline{x} q_0 \u0026#43; x q_1 \\overline{q_0} \\\\ Z \u0026amp;= q_0 q_1 \\end{aligned}\\]  Step 5: Circuit diagram\nMealy machine design #   Output depends on present state as well as present input If input changes, output also changes Less number of states are required There is less hardware requirements They react faster to inputs Asynchronous output generation Output is placed on transitions It is difficult to design  We will design a Mealy machine that detects the same overlapping \u0026ldquo;101\u0026rdquo;.\nStep 1: Generate the FSD (finite state diagram) for the machine\nStep 2: Determine the number of bits needed to store the states\n \\( \\text{number of bits } = \\lceil \\log_2(k) \\rceil = \\lceil \\log_2(3) \\rceil = 2 \\)  , where  \\( k = \\text{ number of states} \\)  Step 3: From FSD, create the truth table where\n \\( A = 00 \\\\ B = 01 \\\\ C = 10 \\\\ D = 11\\)  Note: State \\(D\\) is composed of \u0026ldquo;don\u0026rsquo;t cares.\u0026rdquo;  Step 4: Determine the logical expressions\n \\[\\begin{aligned} d_0 \u0026amp;= x \\\\ d_1 \u0026amp;= q_0 \\bar{x} \\\\ z \u0026amp;= q_1 x \\end{aligned}\\]  Step 5: Draw the circuit diagram\n"}),a.add({id:172,href:'/notes/CS137/CS137-lecture-20210406/',title:"CS137-lecture-20210406",section:"CS137",content:"Mealy machine design cont. #  Recall:\n  \\[\\begin{aligned} d_0 \u0026amp;= x \\\\ d_1 \u0026amp;= q_0 \\\\ Z \u0026amp;= q_1 x \\end{aligned}\\]  Sequential circuits: large design #  "}),a.add({id:173,href:'/notes/CS137/CS137-lecture-20210408/',title:"CS137-lecture-20210408",section:"CS137",content:"Large design sequential circuits #  RTN (register transfer notation) is used to describe an operation of a data path\n Formally describes the data path operation  "}),a.add({id:174,href:'/notes/CS137/CS137-lecture-20210413/',title:"CS137-lecture-20210413",section:"CS137",content:"Sequential circuits, large design cont. #   Data path contains two adder modules and one adder/subtractor module The single mode controls the functions of the adder/subtractor modules    Data path that computes either of these:   \\[\\begin{aligned} \u0026amp;A \u0026#43; B \u0026#43; C \u0026#43; D \\\\ \u0026amp;A \u0026#43; B \u0026#43; C - D \\end{aligned}\\]    Equation that estimates the minimum clock period ( \\( \\tau \\)  ) required to run the data path\n   \\( \\text{add} \\)  stands for adder,  \\( \\text{sub} \\)  stands for subtractor\n   \\( \\Delta \\)  is the time delay from input to output\n   \\( \\tau_p \\geq \\Delta_{\\text{add/sub} } \u0026#43; T_{\\text{st} } \u0026#43; T_{\\text{cq} } \u0026#43; T_{\\text{cs} }\\\\\\)   \\( \\tau_{p} = \\tau_{ \\text{pipeline} } \\)  Speedup equation defines the speed up between a faster system and a slower system.\n"}),a.add({id:175,href:'/notes/CS137/CS137-lecture-20210415/',title:"CS137-lecture-20210415",section:"CS137",content:"Memory technology #  IM = instruction memory, DM = data memory\nRAM = random access memory, ROM = read only memory\nEEPROM = electrically erasable programmable read only memory\nSRAM = static RAM, DRAM = dynamic RAM\nPeak memory bandwidth example #     \\( 32\\text{ bits} \\cdot \\frac{1\\text{ byte} }{8\\text{ bits} } = 4 \\text{ bytes} \\\\ \\)   \\( 1\\text{ MB} = 1,000,000 \\text{ bytes} \\\\ \\)   \\( 1 \\text{ Hz} = 1 \\text{ cycle/second}\\\\ \\)   \\( 1 \\text{ MHz} = 1,000,000 \\text{ cycles/second} \\\\\\)   \\( 100 \\text{ MHz} = 100,000,000 \\text{ cycles/second} \\\\\\)  So,\n \\[\\begin{aligned} 100 \\text{ MHz} \\cdot 4 \\text{ bytes/cycle} \u0026amp;= 400,000,000 \\text{ bytes/sec} \\\\ \u0026amp;= 400 \\text{ MB/sec} \\end{aligned}\\]  SRAM cycle diagrams #  Anything beginning with an underscore _ means it is active low, activated when 0.\n_ce = chip enable, _we 1 = write enable (determines whether in read cycle or write cycle), _oe = output enable.\nTri-state buffer #  hi-Z = high impedance\n"}),a.add({id:176,href:'/notes/CS137/CS137-lecture-20210420/',title:"CS137-lecture-20210420",section:"CS137",content:"Exam 2 review #  Sequential circuit small design #   All small and large sequential circuits are made of flip flops and sets of combination circuits Contrary to CC (combination circuits), a sequential circuit design has states and transitions from a current state to the next state A sequential circuit design problem is typically modeled as a finite state diagram FSD consists of circles as states and arcs (arrows) as transitions, which specifies the behavior of a sequential circuit FSD is systematically converted into circuit called finite state machine Finite state machines designs categorized into Mealy, Moore, or hybrid Mealy is a FSM whose output values are determined by its current e state and input. Moore machine whose output values are determined solely by its current inputs.  Moore machines\n Output depends only upon present state If input changes output does not change More number of states required There is more hardware requirement React slower to inputs (one clock cycle later) Synchronous output and state generation Output is placed on states Easy to design  Mealy machine\n Output depends on present state as well as present input If input changes, output also changes Less number of states Less hardware React faster to inputs Asynchronous output generation Output is placed on transitions Difficult to design  Reviewing the design process of a sequential circuit #  Example: design of a Moore FSM that detects overlapping sequence \u0026ldquo;101\u0026rdquo;.\nStep 1: design the FSD\nStep 2: Determine the minimum number of bits required to store the states\n   \\( \\text{number of bits } = \\log_2 \\lceil k \\rceil \\)  , where  \\( k = \\text{ number of states} \\)  So we need 2 flip flops to represent the states because  \\( \\log_2 \\lceil 4 \\rceil = 2 \\)  Step 3: From the FSD, create the truth table for the next state generator (NSG) and the output generator (OG)\nStep 5: built the circuit\nLarge design review #  "}),a.add({id:177,href:'/notes/CS137/CS137-lecture-20210427/',title:"CS137-lecture-20210427",section:"CS137",content:"Instruction set architectures #   SIMD = single instruction multiple data RISC = reduced instruction set computer CISC = complex instruction set computer ACC = accumulator  Types of instructions #  AES = advanced encryption standard\nHigh level language program to execution #  Instruction cycle #  Data path has four main tasks\n fetch decode execute  may access data memory (another cache)   write  "}),a.add({id:178,href:'/notes/CS137/CS137-lecture-20210429/',title:"CS137-lecture-20210429",section:"CS137",content:"ISA cont. #  Stack architecture #  Example stack style assembly to compute A = B * (C + D)\nPUSH (C) ; stack \u0026lt;- M[C] PUSH (D) ; stack \u0026lt;- M[D] ADD ; stack \u0026lt;- (C) + (D) ; values popped, added, result pushed PUSH (B) ; stack \u0026lt;- M[B] MUL ; stack \u0026lt;- ((C) + (D)) * (B) ; values popped, multiplied, result pushed POP (A) ; M[A] \u0026lt;- (((C) + (D)) * (B)) ; value popped and stored in memory Accumulator architecture #  LD = load\nExample accumulator style assembly to compute A = B * (C + D)\nLD (C) ; ACC \u0026lt;- M[C] ADD (D) ; ACC \u0026lt;- ACC + M[D] MUL (B) ; ACC \u0026lt;- ACC * M[B] ST (A) ; M[A] \u0026lt;- ACC CISC – complex instruction set computer #  Example CISC style assembly to compute A = B * (C + D)\nLD R1, (C) ; R1 \u0026lt;- M[C] ADD R1, (D) ; R1 \u0026lt;- R1 + M[D] MUL R1, (B) ; R1 \u0026lt;- R1 * M[B] ST (A), R1 ; M[A] \u0026lt;- R1 "}),a.add({id:179,href:'/notes/CS137/CS137-lecture-20210506/',title:"CS137-lecture-20210506",section:"CS137",content:"ISA cont. #  RISC – reduced instruction set computer #  Some RISC style assembly to calculate   \\( A = B \\cdot (C \u0026#43; D) \\)  LD R1, (C) ; R1 \u0026lt;- M[C] LD R2, (D) ; R2 \u0026lt;- M[D] ADD R3, R1, R2 ; R3 \u0026lt;- R1 + R2 LD R4, (B) ; R4 \u0026lt;- M[B] MUL R5, R3, R4 ; R5 \u0026lt;- R3 * R4 ST (A), R5 ; M[A] \u0026lt;- R5 Design example: Accumulator ISA #  "}),a.add({id:180,href:'/notes/CS137/CS137-lecture-20210511/',title:"CS137-lecture-20210511",section:"CS137",content:"ISA cont. #  Accumulator ISA cont. #  .code ; start of program code LD 0 ; initialize ACC \u0026lt;- 0 ST (sum) ; M[sum] \u0026lt;- ACC ST (i) ; M[i] \u0026lt;- ACC L1: CMP 7 ; i \u0026gt; 7? JGT L2 ; jump to L2 if greater flag is on MVX ; get next index, X \u0026lt;- ACC LD X(array) ; get next array element, ACC \u0026lt;- M[array + x] ADD (sum) ; add i to running sum, ACC \u0026lt;- ACC + M[sum] ST (sum) ; store running sum, M[sum] \u0026lt;- ACC LD (i) ; get i, ACC \u0026lt;- M[i] ADD 1 ; i++ ST (i) ; M[i] \u0026lt;- ACC JMP L1 L2: "}),a.add({id:181,href:'/notes/CS137/CS137-lecture-20210513/',title:"CS137-lecture-20210513",section:"CS137",content:"Review #   Boolean expressions, combinational circuit design IEEE754 example Sequential circuit design Finite state machine design Finite state machine examples Memory technology Instruction set architectures  "}),a.add({id:182,href:'/notes/CS138/CS138-lecture-20210126/',title:"CS138-lecture-20210126",section:"CS138",content:"syllabus_CSC138.pdf\n"}),a.add({id:183,href:'/notes/CS138/CS138-lecture-20210128/',title:"CS138-lecture-20210128",section:"CS138",content:"Chapter_1_Intorduction to Computer Networks and the Internet.pdf\n"}),a.add({id:184,href:'/notes/CS138/CS138-lecture-20210202/',title:"CS138-lecture-20210202",section:"CS138",content:"NAT = network address translator\nThe packet transmission delay is the delay that it takes your computer to send the packet to the link. (Your car from the garage to the driveway).\nHFC = hybrid fiber coax\nWithout fiber optic cable we could not span networks across oceans.\nBetween the source and destination, what if there are N routers?\n  \\( (N\u0026#43;1) \\frac{L}{R} \\)  The entire packet must fully arrive at the router before being transmitted. The packet holds the information on where it needs to go, so it needs to be fully stored before being forwarded.\nQueue = \u0026ldquo;waiting in line\u0026rdquo;\nhttps://wps.pearsoned.com/ecs_kurose_compnetw_6/216/55463/14198700.cw/index.html\n"}),a.add({id:185,href:'/notes/CS138/CS138-lecture-20210204/',title:"CS138-lecture-20210204",section:"CS138",content:"FDM = frequency division multiplexer TDM = time division multiplexer\n"}),a.add({id:186,href:'/notes/CS138/CS138-lecture-20210209/',title:"CS138-lecture-20210209",section:"CS138",content:"The jump from 11 to 12 is crossing the atlantic ocean.\nSo the answer is min(Rs, Rc).\nLayering can be harmful because each layer is only responsible for its own job, so if the presentation layer doesn\u0026rsquo;t encrypt, no other layers job to do that.\nInternet protocol stack is a practical perspective, ISO/OSI reference model is a reference perspective. The missing layers (presentation, session) must be implemented in the application layer if needed.\n"}),a.add({id:187,href:'/notes/CS138/CS138-lecture-20210211/',title:"CS138-lecture-20210211",section:"CS138",content:"RE: Wireshark lab 1. This is an intro to the wireshark software.\nobserve that the en0 has activity. Double click the card with activity to start packet analyzing.\n Hl = MAC address, Hn = IP address, Ht = port number\nEach time the packet goes thru a router, it must go up to the network layer and back down.\nAt the destination, the layers are removed on the way up to the application layer.\nTransport layer: port number, Network layer: IP address, Link layer: MAC address\nMost important things about encapsulation:\n End systems have all the layers, but a switch only has 2 layers, and a router only has 3 layers. On end systems, when packets are generated and sent, headers are added layer by layer. When the packets are received by the final destination, headers will be removed one by one. On switch/routers, the packet will need to go up and down each layer, for error checking or extracting information from headers for routing/forwarding. Some other actions may be taken as well, including the update of link layer header.  Emails can also be spoofed:\nCh 2 #  Chapter_2_Application Layer.pdf\n"}),a.add({id:188,href:'/notes/CS138/CS138-lecture-20210216/',title:"CS138-lecture-20210216",section:"CS138",content:"Broadcast can only be based on UDP, because you don\u0026rsquo;t know where to make a connection.\n11 tcp connections are needed in total\nRTT = round trip time\n"}),a.add({id:189,href:'/notes/CS138/CS138-lecture-20210218/',title:"CS138-lecture-20210218",section:"CS138",content:"https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/http-delay-estimation/index.html\nIn piplining, the object requests are \u0026ldquo;back to back\u0026rdquo;\nThe proxy server can have a web cache copy so it doesn\u0026rsquo;t have to request the origin again.\nCache\n hit, the request was cached miss, the request was not cached  "}),a.add({id:190,href:'/notes/CS138/CS138-lecture-20210223/',title:"CS138-lecture-20210223",section:"CS138",content:"Average rate to browsers:\n  \\[\\begin{aligned} 100\\text{ K } \\cdot 15/\\text{ sec } = 1.5 \\text{ MBps } \\end{aligned}\\]  So our LAN utilization is:\n \\[\\begin{aligned} \\frac{1.5 \\text{ Mbps }}{10 \\text{ Mbps}} = 15\\% \\end{aligned}\\]  And the access link utilization is:\n \\[\\begin{aligned} \\frac{1.5 \\text{ Mbps }}{1.54 \\text{ Mbps}} = 99\\% \\end{aligned}\\]  Access link utilization:\n \\[\\begin{aligned} 99\\% \\cdot 0.6 = 58\\% \\end{aligned}\\]  Total delay:\n \\[\\begin{aligned} 0.6 \\cdot (\\text{delay from origin}) \u0026#43; 0.4 \\cdot (\\text{delay when satisfied from cache}) \\end{aligned}\\]   FTP uses port: 21\n SMTP uses port: 25\nThe servers will play both roles, i.e. Gmail server will play the client and the Yahoo server will play the server. If they do the opposite then their roles will swap.\n"}),a.add({id:191,href:'/notes/CS138/CS138-lecture-20210225/',title:"CS138-lecture-20210225",section:"CS138",content:"Domain name system #  DNS is a application layer service, it is run at the network edge.\n ttl = \u0026ldquo;time to leave\u0026rdquo;, expiration time NS = name server, this is the point of contact CNAME = canonical name, this is where you can specify a smaller name for a long name MX = mailserver  Query and response are the same format.\ndig asks for the IP address of a site.\n"}),a.add({id:192,href:'/notes/CS138/CS138-lecture-20210302/',title:"CS138-lecture-20210302",section:"CS138",content:"DNS cont. #  For a backup authoritative DNS server (secondary), resource records inserted into .com TLD DNS server, by DNS registrar:\n(networkutopia.com, dns2.networkutopia.com, NS, TTL) (dns2.networkutopia.com, 212.212.212.2, A, TTL) In your company\u0026rsquo;s authoritative DNS server, you should have the following resource records for web server, email server (etc):\n(www.networkutopia.com, somethingelse.networkutopia.com, CNAME, TTL) (somethingelse.networkutopia.com, 212.212.212.56, A, TTL) (networkutopia.com, mailserver.networkutopia.com, MX, TTL) (mailserver.networkutopia.com, 212.212.212.89, A, TTL) DNS Poisoning #  Lets say its the first time that we are visiting a site, we will first ask the local DNS \u0026hellip;\nWhat if a man in the middle (in the same local area network with client), he can intercept the query from the client.\nAt the 7th step, the man in the middle can send a reply on behalf of the root.\nThe faked 7th step is a bogus answer to the clients query.\nSo if we\u0026rsquo;re asking for www.abcd.com, and the real address is 123.54.8.9, the bogus answer will respond with a different IP address. The bogus IP will arrive at the local DNS before the real one will, and it will be cached. If the faked website looks identical to the real one, they can have their information stolen.\nDNS-based DDoS #  Query: what is the IP address for www.abcd.com? The source IP should be the client\u0026rsquo;s IP.\nBut what if the client is part of the attack? So maybe the query is actually: what is the IP address for www.abcd.com, BUT the client changed their source IP address to be the same IP as (for example) Google? So this will redirect step 8 back to Google:\nWhat if we can manage to have 1 million machines do the same thing?\nThis can overwhelm the server.\nP2P (Peer to peer) #  This increases linearly with   \\( N \\)  .\n"}),a.add({id:193,href:'/notes/CS138/CS138-lecture-20210304/',title:"CS138-lecture-20210304",section:"CS138",content:"Socket programming #  UDP Client in Python #  SOCK_DGRAM means it will use UDP. The server\u0026rsquo;s socket is always open.\nUDPClient.py:\nfrom socket import * serverName = \u0026#39;hostname\u0026#39; serverPort = 12000 clientSocket = socket(AF_NET, SOCK_DGRAM) message = raw_input(\u0026#39;Input lowercase sentence:\u0026#39;) clientSocket.sendto(message, (serverName, serverPort)) modifiedMessage, serverAddress = clientSocket.recvfrom(2048) print modifiedMessage clientSocket.close() UDPServer.py\nfrom socket import * serverPort = 12000 serverSocket = socket(AF_INET, SOCK_DGRAM) serverSocket.bind((\u0026#39;\u0026#39;, serverPort)) print \u0026#39;The server is ready to receieve\u0026#39; while 1: message, clientAddress = serverSocket.recvfrom(2048) modifiedMessage = message.upper() serverSocket.sendto(modifiedMessage, clientAddress) Port numbers should be between 1024-65536.\nTCP Client in Python #  SOCK_STREAM means it will use TCP.\nTCPClient.py\nfrom socket import * serverName = \u0026#39;servername\u0026#39; serverPort = 12000 clientSocket = socket(AF_NET, SOCK_STREAM) clientSocket.connect((serverName, serverPort)) sentence = raw_input(\u0026#39;Input a lowercase sentence:\u0026#39;) clientSocket.send(sentence) modifiedSentence = clientSocket.recv(1024) print \u0026#39;From server:\u0026#39;, modifiedSentence clientSocket.close() TCPServer.py\nfrom socket import * serverPort = 12000 serverSocket = socket(AF_INET, SOCK_STREAM) serverSocket.bind((\u0026#39;\u0026#39;, serverPort)) serverSocket.listen(1) print \u0026#39;The server is ready\u0026#39; while 1: connectionSocket, addr = serverSocket.accept() sentence = connectionSocket.recv(1024) capitalizedSentence = sentence.upper() connectionSocket.send(capitalizedSentence) connectionSocket.close() "}),a.add({id:194,href:'/notes/CS138/CS138-lecture-20210309/',title:"CS138-lecture-20210309",section:"CS138",content:"Transport Layer #  Transport services #   Application Layer  App \u0026lt;-\u0026gt; app such as Outlook (email)   Transport layer  Process \u0026lt;-\u0026gt; process Data -\u0026gt; segments/datagrams Segment contains transport header + data portions from email   Network layer  Machine \u0026lt;-\u0026gt; machine Network header + segment    Rectangle = app, Diamond = socket, Circle = process\nMultiplexing/demultiplexing #  Connectionless transport: UDP #  "}),a.add({id:195,href:'/notes/CS138/CS138-lecture-20210311/',title:"CS138-lecture-20210311",section:"CS138",content:"UDP cont. #  Principles of reliable data transfer #  Expected features\n No bit errors No loss of data   Problems\n Bit error Data loss   Solutions\n Error detection (checksum) Data recovery    So how do we do recovery? We learn from human to human conversation, \u0026ldquo;pardon?\u0026quot; to recover data loss in the conversation.\nFeedback: ACK for positive, NAK for negative.\nSo the receiver will send an ACK if the packet was received without loss, otherwise it\u0026rsquo;ll send NAK. Then, from the sender\u0026rsquo;s perspective it will move on to the next data transmission if ACK is received from receiver. Otherwise, (NAK from receiver) it will retransmit the last data until an ACK is received.\nSo we have a new problem, what if ACK/NAK is corrupted on the way back?\nThe sender has no way to find out whether the current packet was successful or not. We can allow the sender to retransmit the data, but it can cause duplicates on the receiver\u0026rsquo;s side. To avoid and handle duplicates, the sender adds a sequence number to each packet, this way the receiver can discard duplicates.\nWe have to stop and wait, each time we only transmit one single packet. If we\u0026rsquo;re only sending 1 packet at a time, when we wait until its successful each time we give it a sequence number, so we actually only need 2 different sequence numbers.\npkt 0\u0026hellip; pkt 1\u0026hellip; pkt 0\u0026hellip; pkt 1\u0026hellip; etc\nWhat if the ACK response is corrupted?\nIf the sender receives the same ACK for the same packet, then that must mean that the last packet was corrupted during transmission. Instead of sending NAK for the current packet, it is equivalent of sending the ACK for the last packet. This tells the sender that the current packet wasn\u0026rsquo;t successful, and the sender should retransmit.\nNAK 1 -\u0026gt; ACK 0;\nNAK 0 -\u0026gt; ACK 1;\nIf the first packet has a problem, then simply no response shows that it had a problem.\n"}),a.add({id:196,href:'/notes/CS138/CS138-lecture-20210316/',title:"CS138-lecture-20210316",section:"CS138",content:'Review for exam #  Example question set for Ch 1-2 #    What are the layers in TCP/IP protocol stack?\nApplication, transport, network, link, physical\n  What are layers in OSI reference model?\nExtra 2 layers are presentation and\n  What is the major difference between packet switching and circuit switching?\nCircuit reserves some resources, packet switchings allows sharing\n  What is the difference between routing and forwarding?\nRouter is global, forwarding is local\n  What is the relationship between routing and forwarding?\nInterplay\n  How many types of packet delay does a network have?\n4, nodal processing, packet transmission, propagation delay, queueing delay\n  Which tool/utility/program can be used to find out the IP address of the routers on the path from one source and destination?\ntraceroute\n  Which tool/utility/program can be used to intercept and analyze network packets?\nWireshark\n  On which layer is SSL/TLS implemented for network security?\nApplication layer\n  What does DDoS mean?\nDistributed denial of service\n  Among HTTP, FTP, SMTP, DNS, which protocols use TCP?\nHTTP, FTP, SMTP\n  What are the service port numbers for HTTP, FTP, SMTP, DNS respectively?\n80, 21/20, 25, 53\n  What is the major difference between persistent and non-persistent modes of HTTP?\nPersistent allows one connection to be shared by multiple object transmissions. Non-persistent must have a connectino for each object transmission.\n  What is the major difference between Client/Server model and P2P model?\nClient/server has an always on server, P2P doesn\u0026rsquo;t have a server (everyone is a peer)\n  Where is URL specified in HTTP request format?\nIn the first line (the request line) of request format\n  Where is the status code specified in HTTP response format?\nIn the first line, the status line\n  Is web cache a client or server for the original browser who sent the request to get one object?\nServer\n  What benefits come from the conditional get technology? (at least 2 examples)\nNo object transmission delay, lower link utilization\n  What is the major difference between SMTP and POP/IMAP?\nPush versus pull\n  What is the format for DNS resource records? (RR)\nName, value, type, TTL\n  Among the socket library functions, what are used by TCP and what are used by UDP?\nTCP: UDP:\n  What is the major difference between TCP and UDP?\nTCP has a handshake, and is reliable. UDP is non-reliable\n  True or false questions #   Internet is a single network? (F) DNS runs on routers as it\u0026rsquo;s a network core function. (F) A network alyer does not need to rely on any service from its below layer. (F) TCP is a protocol on Application layer. (F) FDM/TDM is a pcket switching protocol (F) It\u0026rsquo;s impossible to have packet loss as the network is supposed to guarantee reliability (F) All the packet headers are added to data at application layer when the data leaves the application program (F) Routers support all seven layers of the OSI reference model (F) SMTP is a P2P protocol and there is no client in its communications (F) SMTP is a pull protocol (F)  Long answer questions #   Cookie scenario in slides of ch. 1. How many components to make cookie system function? What are they respectively? What are their functionalities respectively? Especially, what cookie header lines in the first HTTP response message and next HTTP request messages?  There are four functions. Cookie on client, database on server, header line with cookie ID, header line from server. Database on server side contains all the info, cookie contains the ID, all future client/server messages have ID in headers.\nTo insert resource records into DNS, what steps are needed? What RRs are inserted? Refer to the slides in Ch. 2  What are the functions related to TCP and UDP socket programming?  UDP cont. #  If packet isn\u0026rsquo;t lost:\n mermaid.initialize({ "flowchart": { "useMaxWidth":true }, "theme": "default" } ) sequenceDiagram participant S as Sender participant R as Receiver S - R: send pkt 0 R - S: ack 0 S - R: pkt 1 R - S: ack 1 S - R: pkt 0 In case d, the functionality still works but the performance is poor, because each packet is transmitted twice after the first premature timeout.\nRTT = round trip time\n'}),a.add({id:197,href:'/notes/CS138/CS138-lecture-20210330/',title:"CS138-lecture-20210330",section:"CS138",content:"Piplined protocols #  Go-back-n #  unacked = unacknowledged = no ACK response, not confirmed for success yet.\nThe number of bits needed for a   \\( k \\)  -bit sequence numbers is  \\( 2^k - 1 \\)  . The window size is  \\( N = 2^k \\)  .\nThe packet number that can be used for cumulative ack should be the largest number before any gap.  https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html\n Send window size  \\( N \\)  : it can send up to  \\( N \\)  packets on the fly Cumulative ACK ( \\( m \\)  ): means that packet  \\( m \\)  and also every packet before  \\( m \\)  are all received successfully Timer: only a single timer, bound to the oldest packet unacked. When timeout, resend all packets in the sender window. On receiver side, all packets after the gap are called \u0026ldquo;out of order\u0026rdquo;, and they are discarded. Hence, there can only be one gap.  Selective repeat #  For selective repeat, there is still  \\( k \\)  -bit sequence numbers, and a window size of  \\( N = 2^{k - 1} \\)  . The largest number is  \\( 2^{k - 1} - 1 \\)  .\n Send up to  \\( N \\)  packets: controlled by sender window size  \\( N \\)  . Individual ACK: the particular packet received successfully. Timer: there is one timer for each unacked packet. When timeout happens, the sender only resends the particular packet. On receiver side: packets after gap are called \u0026ldquo;out of order\u0026rdquo;, but this time they are buffered, waiting to be delivered.  https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html\nSo to combat this, if  \\( k = 2 \\)  , then the size of the window should be  \\( N = 2^{2-1} = 2 \\)  . The largest sequence number is  \\( 2^{1 - 1} = 1 \\)  .\n"}),a.add({id:198,href:'/notes/CS138/CS138-lecture-20210401/',title:"CS138-lecture-20210401",section:"CS138",content:"Connection oriented transport: TCP #  Entire header size is   \\( 32 \\text{ bits } \\cdot 5 = 160 \\text{ bits } = 20 \\text{ bytes } \\)  . The receive window is used for flow control.\nSequence number example:\nBoth sides randomize the sequence number they will use at the beginning.\nReliable data transfer #  Flow control #  The difference between flow control and congestion control:\n Flow control is to make sure the receiver is not overwhelmed Congestion control is to make sure that the road (routers, other resources) is not overwhelmed  "}),a.add({id:199,href:'/notes/CS138/CS138-lecture-20210406/',title:"CS138-lecture-20210406",section:"CS138",content:"TCP Cont. #  Flow control #  rwnd = receive window\nConnection management #  TCP 3-way handshake steps:\n SYN = 1, ACK = 0: SYN packet SYN = 1, ACK = 1: SYNACK packet SYN = 0, ACK = 1: ACK packet. This packet can contain real data from client to server.  Principles of congestion control #  In a perfect world:   \\( \\lambda_{\\text{in} } = \\lambda_{\\text{out} } \\)  , however this is not usually the case.\nCauses/costs of congestion:\n When data is lost, TCP will retransmit such data. This causes what is sent by sender to be bigger than expected. When premature timeout happens, the data will be re transmitted unnecessarily, which causes corresponding data to be sent twice or more. This also causes what is sent by the sender to be bigger than expected.  When one packet is dropped by one router, then all network resources/capacity used for this packet were wasted.  ssthresh is a parameter. It starts at an initial value, but will be dynamically change to half of the value before congestion.\nTCP congestion control phases:\n Slow start. It is exponentially growing at the beginning. Congestion avoidance. When you reach the threshold, TCP asks to slow down, from exponential to linear growth. Fast recovery. When a timeout happens, or when data loss happens, it indicates that possible traffic congestion has occurred. For fast recovery, TCP Reno and TCP Tahoe are different (drop to half vs drop to 1).  MSS = maximum segment size\nFast recovery:\n Data loss can be indicated by timeout or triple duplicate ACKs. TCP Tahoe always drops to 1, no matter if timeout or triple duplicate ACKs. TCP Reno  When timeout happens, it drops to 1 When triple duplicate ACKs happen, it drops to half    ssthresh is set to half of the cwnd (congestion window size) before congestion occurred.\nAIMD = additive increase multiplicative increase\nThis entire philosophy basically probes for usable bandwidth.\n"}),a.add({id:200,href:'/notes/CS138/CS138-lecture-20210408/',title:"CS138-lecture-20210408",section:"CS138",content:"SMTP socket programming assignment #  TCP cont. #  Congestion control #  https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/tcp-congestion/index.html\nThroughput #  Fairness #  Network layer #  Quick review\n The application layer is app to app. Transport layer is process to process Network layer is device to device (machine to machine), including routers  ATM = asynchronous transfer model\nFor internet\n Connection is at transport layer (TCP) Datagrams (network connectionless)   ATM/X.25/Frame relay\n Virtual connection is at network layer Virtual circuits (network layer connection)  Note: The current internet does not use this    Network service model #  Analogy: this is like the distance between cars on the road.\nCBR = constant bit rate, VBR = variable bit rate, AVB = available bit rate, UBR = undefined bit rate\nIn our internet service model, we do not guarantee anything. If we want to guarantee anything it must be done in the transport layer.\nVirtual circuits and datagram networks #  "}),a.add({id:201,href:'/notes/CS138/CS138-lecture-20210413/',title:"CS138-lecture-20210413",section:"CS138",content:"Review #   Devices, links, packet switches Protocols define format and order of messages sent and received among network entities Routers Routing and forwarding Packet switching   Worms do not need user\u0026rsquo;s interaction, viruses do Distributed denial of service. TLD name servers are easier to attack Recording packets passing through network Sends a packet with a forced source address Sends bogus replies to the DNS servers   P2P is more scalable IP address and port number TCP, because it is reliable TCP SSL is implemented at the app layer   Persistent allows multiple objects to be sent over a single connection set-cookie cookie Database or back end Cookie file managed by browser   host to IP mapping, host nick name, mail server nick name, load distribution iterative and recursive (fruit.com, dns.fruit.com, NS), (dns.fruit.com, 192.168.112.0, A)   The rarest chunk first, B The top 4 peers that seed her the most   SOCK_DGRAM sendto The client needs to close, but the server\u0026rsquo;s socket is reused 1 global socket to hand shake, 1 per connected client The socket connected to the client can be closed. The hand shake socket stays open.   application, presentation, session, transport, network, link, physical presentation and session save time, save bandwidth, save traffic if-modified-since 304 not modified      \\( \\frac{L}{R} = \\frac{30}{3} \u0026#43; \\frac{30}{5} \u0026#43; \\frac{30}{10} = 19 \\)    \\( \\frac{D}{S} = \\frac{100}{20} = 5 \\)    \\( 19 \u0026#43;5 \u0026#43; 2(2) \u0026#43; 1(2) = 30 \\)   queuing 3 Gbps is the bottleneck   SMTP or HTTP SMTP POP3 or IMAP or HTTP port 25 TCP  Network layer cont #  TCP vs UDP\n Transport layer connection vs connectionless Programmers have the choice to use TCP or UDP, by giving different parameters to the socket function Process to process Done within network devices   Datagram vs Virtual circuit\n Network layer connection vs connectionless No choice for programmers, the network provides one or the other Host to host Done on network core (routers)    Our internet uses Datagrams, hence it is connectionless on the network layer. We use TCP to get a connection service at the transport layer.\nVirtual circuits (VC) #  Datagram networks #  Datagram vs VC overview #  What\u0026rsquo;s inside a router #  "}),a.add({id:202,href:'/notes/CS138/CS138-lecture-20210415/',title:"CS138-lecture-20210415",section:"CS138",content:"Network layer cont. #  Switching fabrics #  Since data can flow bidirectionally, inputs can become outputs, and vice versa.\nOutput ports #  Input port queueing #  IP: Internet Protocol #  ICMP = internet control message protocol\nDatagram format #  The header is 20 bytes long.\nUpper layer can be TCP or UDP, or ICMP\nA type could be multimedia, satellite signal etc, used for priority.\nIP Fragmentation #  MTU = max transfer size\nThe original is 4000 bytes, but the MTU is 1500 bytes. So the original will be fragmented to accommodate the MTU.\nNote: IP header is in every fragment, but the TCP header is only in the first. The TCP header is regarded as payload at the network layer.  IPv4 #  NIC = network interface card\nA.B.C.D where each letter is 8 bits, so 32 bits total.\nSubnets #  "}),a.add({id:203,href:'/notes/CS138/CS138-lecture-20210420/',title:"CS138-lecture-20210420",section:"CS138",content:"Internet Protocol cont. #  Subnets cont. #  There are 6 subnets.\n192.192.134.1/24 means that the first 24 bits are the subnet mask, it is the network part of the address. A smaller sub set of the larger network could possibly be 192.192.134.1/26.\nDHCP #  The IP address 255.255.255.255 means that it will be broadcast to everyone in the network.\nNote: DHCP is in the application layer. DHCP uses UDP because of the fact that it needs to broadcast.  When connecting to a network for the first time, the DHCP server will be the first to help you.\nNAT #  Address shortage is the fact that there are only a finite number of IP addressed to be allocated.\nSolution 1 is manual configuration.\nICMP #  Note: ICMP is a network layer protocol but its used like a transport layer protocol.  IPv6 #  QoS = quality of service\n"}),a.add({id:204,href:'/notes/CS138/CS138-lecture-20210422/',title:"CS138-lecture-20210422",section:"CS138",content:"Routing algorithms #  Graph abstraction #  Algorithm classifications #  Dijkstra\u0026rsquo;s algorithm #  Hierarchical routing #  There can be multiple links between regions.\nRouting the internet #  OSPF #  Link state algorithms, because they are global, works perfect for smaller networks.\nBGP #  To help remember: iBGP = internal border gateway protocol, eBGP = external border gateway protocol\nBroadcast and multicast routing #  "}),a.add({id:205,href:'/notes/CS138/CS138-lecture-20210427/',title:"CS138-lecture-20210427",section:"CS138",content:"Note: We skipped the slides on multicast last lecture.  Link layer #  Link layer services #  MAC = media access control, MAC addresses are 48 bits.\nWhere the link layer is implemented #  rdt = reliable data transfer\nError detection/correction #     \\( G \\)  can be any sequence as long as the sender and receiver use the same sequence.\nSo if we pad the right side of  \\( D \\)  with  \\( R = 011 \\)  , we will get a remainder of  \\( 0 \\)  when the receiver performs the division.\nMultiple access protocols #  CSMA/CD is used by ethernet, CSMA/CA is used by wifi.\nOn axis: C = collision, E = empty, S = successful\nIf we have  \\( N \\)  nodes, for a given node in slotted ALOHA, the probability is  \\( Np(1 - p)(1-p)(1-p) \\cdots (1-p) \\)  .\nSuccess =  \\( Np(1-p)^{N-1} \\)  .\nCSMA is still a random access protocol.\n"}),a.add({id:206,href:'/notes/CS138/CS138-lecture-20210429/',title:"CS138-lecture-20210429",section:"CS138",content:"Multiple access protocols cont. #  CSMA cont. #  CSMA/CD is used by ethernet.\nCD = collision detection, CA = collision avoidance\nIt is not easy to detect collision (because of signal strength) in wireless LAN.\nCSMA/CD algorithm #  NIC = network interface card\nBinary backoff:\nAfter the   \\( m \\)  th collision, we choose  \\( K \\)  randomly in the range of  \\( \\{0, 1, 2, \\ldots, 2^m - 1\\} \\)  . We then wait  \\( 512K \\)  bit times to retransmit.\nSo, if\n  \\( m = 0 \\)  , there is no collision, immediate transmission  \\( m = 1 \\)  , there has been 1 collision,  \\( K \\)  will be either 0 or 1, and we we wait  \\( 512K = 0 \\)  or  \\( 512K = 512 \\)  bit times until retransmission. and so on\u0026hellip;  Note: A bit time is the speed that the NIC takes to send 1 bit. Read more.  \u0026ldquo;Taking turns\u0026rdquo; MAC protocols #  Cable access network #  Summary of MAC protocols #  LAN #  LAN = local area network\nARP: address resolution protocol #  Addressing #   A will know B\u0026rsquo;s IP address via DNS. A will know R\u0026rsquo;s address via DHCP. A will know R\u0026rsquo;s MAC address via ARP.  Ethernet #  Switches #  "}),a.add({id:207,href:'/notes/CS138/CS138-lecture-20210504/',title:"CS138-lecture-20210504",section:"CS138",content:"LAN cont. #  Switches vs routers #  VLAN #  VLAN = virtual local area network\nData center networks #  TOR = top of rack\nA day in the life of a web request #  DHCP (UDP) \u0026gt; ARP (BGP) \u0026gt; DNS \u0026gt; HTTP (TCP)\nSummary #  Review #    What is the difference between network and transport layer? Network is machine to machine, transport is process to process\n  Differences between TCP and UDP TCP is reliable, UDP is not\n  What is multiplex at sender? What is demultiplex at sender? View slides\n  What is different between UDP socket and TCP socket? UDP is SOCK_DGRAM and TCP is SOCK_STREAM, and different respective functions.\n  What is the usual size of UDP header? 8 bytes\n  What is the usual size of IPv4 header? 20 bytes\n  What is the purpose of UDP checksum? Error detection\n  What is the problem and solution in rdt 2.0, 2.1, 3.0? View slides\n  For non-pipelined protocols, why does sequence number surface (0,1) suffice? We only send 1 packet at a time\n  What is the difference between stop-and-wait protocols and pipelined protocols?/ Stop and wait only send 1 packet each time, pipelined send multiple\n  What is cumulative ACK? Cumulative ACK will confirm success for multiple packets\n  Why does selective repeat have a dilemma when sequence numbers 0,1,2,3 and window size = 3? View slides\n  For k-bit sequence number, what is the window size for GBN and selective repeat respectively? GBN is 2^k and selective repeat is 2^(k-1)\n  Name 5 features TCP has that UDP doesn\u0026rsquo;t.\n Reliability flow control Congestion control handshake connection management    What is called TCP fast retransmit? If the sender got triple duplicate it will retransmit\n  Two indicates of data loss. Count down timer, triple duplicate\n  What is ddefinition of sequence number and ack number for TCP? View slides\n  Among packet headers, which layer header contains port number?\n  What is diff between TCP flow control and congestion control? Flow control protects receiver, congestion control protects the network\n  How does receiver advertise free buffer space in TCP header? View slides.\n  Why do we need preamble in packet format? synchronization, or recognize start of new packet\n  3 costs of congestion\n data retranmission due to loss retransmission due to premature timeout Network resources allocated to dropped packet    Why does TCP have fairness? Because for all machines involved, each connection will have additive increase multiplicative decrease\n  What is called longest prefix matching? Selecting the longest matching IP, view slides.\n  IP: What is subset part and host part? A.B.C.D/X, the a-d is host, x is subnet mask\n  NAT, why can internal computers use private addresses? The private address is translated on its way out\n  What is the difference between inter-as and intra-as protocols? Inter is handling tasks between regions, and intra handles only the tasks inside the same region.\n  What is the functionality of inter-as? Advertise reachability information\n  Hot potatoe routing is to select which router when multiple choices are present\n  What is difference between eBGP and iBGP. External and internal\n  TDMA is time division, FDMA is frequency division\n  2 common drawbacks from \u0026ldquo;taking turns\u0026rdquo; MAC protocols? Token based has 1 point of failure, also delay\n  TRUE/FALSE\n Multiplexinf occurs at receiver and demultiplexing at sender. FALSE UDP ssocket is identified by 4 tuple: FALSE Checksum can be used to detect transmission error 100% correct. FALSE rdt 3.0 is pipelined: FALSE Stop and wait protocols are better than pipelined: FALSE Selective repeat utilizes cumulative ACK: FALSE GBN has buffers at receivers side: FALSE Forwarding and routing are independent: FASLE Forwarding table uses individual IP addresses as indexes, FALSE Internet is based on datagram network: FALSE IP address if flat: FALSE Like TCP and UDP, ICMP is transport layer: FALSE In tunneling, IPv4 is carried as payload of IPv6: FALSE For broadcasting, innetwork duplicating is betteer than source duplication: TRUE What is called reverse path forwarding based controlled flooding. Data link layer studies logical communication between remote hosts or processes. FALSE Data link layer studies logical communication between hosts or processes: FALSE MAC is hierarchical: FALSE  "}),a.add({id:208,href:'/notes/CS138/CS138-lecture-20210506/',title:"CS138-lecture-20210506",section:"CS138",content:"Network security #  What is network security? #  Cryptography #  RSA #  + = public, - = private\nGiven the public key   \\( K_{pub} \\)  and the private key  \\( K_{priv} \\)  , we can decrypt anything encrypted by the public key, and vice versa.\nAlice invents a symmetric key, and sends it to Bob using RSA encryption. That way the computationally slow RSA algorithm can be used to send the symmetric key, and the symmetric key can be used for continual encryption. This speeds up the overall encryption algorithms for large amounts of data.\n"}),a.add({id:209,href:'/notes/CS138/CS138-lecture-20210511/',title:"CS138-lecture-20210511",section:"CS138",content:"Network security cont. #  RSA cont. #  Authentication #  ap = authentication protocol (fictional)\nChallenge-response mechanism for authentication:\n Using symmetric shared key,   \\( K_{ab} \\)   Alice sends the message to bob saying \u0026ldquo;I am alice\u0026rdquo; Bob generates a random one-time use nonce, and encrypts it with the shared key  \\( R = K_{ab}(\\text{nonce}) \\)   Alice decrypts  \\( R \\)  based on the symmetric key  \\( K_{ab} \\)  . Alice sends the result to Bob. Bob matches the response, if it matches then it authenticates Alice.    This still relies on the transfer of the symmetric key. Also, Bob can spoof himself as Alice, and vice versa.\nHere, anyone could create their own public/private key combination to respond to Bob.\nHashing  \\( m_1 \\)  should not equal to the hash of  \\( m_2 \\)  , however it is possible. Read more on MD5.\nSo instead of Bob asking Alice for her public key, he should ask for her certificate.\nSecuring e-mail #  "}),a.add({id:210,href:'/notes/CS138/CS138-lecture-20210513/',title:"CS138-lecture-20210513",section:"CS138",content:"Network security cont. #  Note: These following topics will not be on the final  TLS – transport layer security #  TLS is implemented at application layer.\nIPSec – network layer security #  VPN = virtual private network\nIKE = internet key exchange, ESP = encapsulating security payloads\nRead more on kerberos\nFirewalls #  IDS = intrusion detection system\nIDS – intrusion detection systems #  Network security summary #  "}),a.add({id:211,href:'/notes/CS139/CS139-lecture-20210831/',title:"CS139-lecture-20210831",section:"CS139",content:"Course orientation #  File: 139-syllabus.pdf  Notes during orientation #   We will be looking at operating systems from a conceptual level, not any specific OS Files will be submitted as .tar.gz, NOT .zip  Introduction #  File: csc139-fall21-part0-logistics.pdf  "}),a.add({id:212,href:'/notes/CS139/CS139-lecture-20210902/',title:"CS139-lecture-20210902",section:"CS139",content:"Introduction to Operating systems #  What is an OS? #  The OS is the intermediary between the hardware and the software.\nPossibly the most famous test program in C:\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello, world!\\n\u0026#34;); exit 0; } Which is compiled via\ngcc hello.c -o hello which creates the executable hello.\nWe can run this via\n./hello we can run this with 2 instances like\n./hello \u0026amp; ./hello The more we run this the PID changes each time. Sometimes the order is different too.\nSo where is the executable file being stored? Can we run a program from the hard drive? The program is loaded into memory before it is executed, so how does it actually get loaded into memory? How does the executable actually print out the message so it is visible on the screen? When we run 2 instances of the same application, how can they run at the same time on a single CPU?\nAll of these questions can be answered via operating systems.\nWhen we run 2 instances of the executable at the same time, they will be allocated their own memory space.\nB, C, F\nEvolution of Operating Systems #  The want for reusability created a library of functions. The first OS started out as just a single library of functions.\nThe right graph optimizes for response time, but it has to do a lot more context switches, resulting in more overhead and an overall longer completion time.\n"}),a.add({id:213,href:'/notes/CS139/CS139-lecture-20210907/',title:"CS139-lecture-20210907",section:"CS139",content:"Introduction cont #  Parallel systems #  Intrachip transfer is much faster than interchip transfer.\nDistributed systems #  Real-time and embedded systems #  Other systems #  Organization #   PC = program counter, the address of the next instruction IR = instruction register, the address of the current instruction MAR = memory address register, address of the next memory IO MBR = memory buffer register, actual data to be read/written to/from memory I/O AR = input output address I/O BR = input output buffer register, the data  Memory is an array of bytes, each with its own address.\nI/O devices constantly content for memory cycles, so every controller has a local buffer.\nInterrupts #  Flow control with interrupts #  Here, the IO operation is concurrent with CPU processing.\nInterrupts allow overlap of CPU and IO operations.\nThe interrupt vector is just a lookup table.\nWe allow the overlap of CPU and IO operations.\n"}),a.add({id:214,href:'/notes/CS139/CS139-lecture-20210909/',title:"CS139-lecture-20210909",section:"CS139",content:"Organization cont #  Interrupts cont #  During a IO request:\n Device driver loads the registers in the device controller Device controller examines content Device controller starts the transfer of data Once the transfer is done, the device controller informs the operating system that the transfer is complete. Driver gives control back to the OS  Handling interrupts #  When calling a interrupt routine, we have 2 methods:\nMethod 1:\n Invoke a generic routine Call the interrupt specific routine   Method 2:\n A table of pointers to interrupt routines   Invoke the specific interrupt routine from the table, constant time    When we poll the device, we can tell whether the status is busy or ready. The status register is read over an over until the busy bit is turned on. However, this wastes a CPU cycle each time we have to read this register.\nSo, vectored interrupts are the answer.\nOperating system operations #  In user mode, only non-privileged instructions can be used. In kernal mode, both non-privileged and privileged instructions can be used.\nSystem calls #  In most operating systems, devices are treated like files.\nStorage device hierarchy #   the higher the level, the faster the speed the lower the level, the bigger the capacity  The CPU cannot read anything directly below the main memory level.\nStructure #  The layered ring structure was adopted by MULTICS.\n"}),a.add({id:215,href:'/notes/CS139/CS139-lecture-20210914/',title:"CS139-lecture-20210914",section:"CS139",content:"Structure cont #  Simple structure #  Layered structure #  A 5 layered approach:\n5. operator 4. user programs 3. IO management 2. communication 1. memory management 0. CPU, support for multi program This is easier to construct and debug, however there is a communication overhead. It is impractical to divide the kernel into layers.\nMicrokernel structure #  Microkernels are easier to extend, but there is a lot of communication overhead. This also doesn\u0026rsquo;t support a hot patch, if we had another feature we have to recompile the kernel.\nModular kernel #   More flexible than the layered More efficient than the microkernel  Processes #  File: 139-processes.pdf  Programs\n passive, on disk   Process\n active, in memory one of several states    One program can be executed by multiple processes.\nProcesses in memory #  Looking at processes #  Process states #  Note: \u0026ldquo;Waiting time\u0026rdquo; is the time spent in ready state.  This 5 state model is what we\u0026rsquo;ll use in this class.\nWhat causes the interrupt transition: running \u0026gt; ready?\n the OS  What causes the scheduler dispatch transition: ready \u0026gt; running?\n the OS  What causes the IO or event wait transition: running \u0026gt; waiting?\n the process itself  What causes the IO or event completion transition: waiting \u0026gt; ready?\n an external process  Process Control Block (PCB) #  Process number = PID\nScheduling #  "}),a.add({id:216,href:'/notes/CS139/CS139-lecture-20210916/',title:"CS139-lecture-20210916",section:"CS139",content:"Processes cont. #  Scheduling cont. #  A single linked list works well for ready and wait queues. Note the addition of a tail pointer. The tail pointer gives us a constant time complexity to get to the end of the queue. New processes are added at the tail.\nSchedulers #  Note the difference between short-term and long-term schedulers. Long-term scheduling handles multiprogramming.\nNote: Read more on medium term scheduling in the text.  Context switch #  Process operations #  So what is the relationship between the parent and child\u0026rsquo;s memory space? Are there things in common? Can a parent and child process talk to each other? It depends:\nHow can we see the process tree in linux:\nps auxf f is the option to show process tree, or\npstree  Directly after the fork() system call, both parent and child are both the same program, ie bash. They will share their entire memory space, even the program counter (the child doesn\u0026rsquo;t start from the beginning of the program). Once the child calls exec() it replaces the process' memory space with a new program, ie ps.  How do we tell the child and parent apart before the exec() call?\n The child gets a zero value for return The parent gets the child\u0026rsquo;s PID for return  Read more at the man page of fork()  Example program using fork() #  #include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int number = 7; int main(void) { pid_t pid; printf(\u0026#34;\\nRunning the fork example\\n\u0026#34;); printf(\u0026#34;The initial value of number is %d\\n\u0026#34;, number); pid = fork(); printf(\u0026#34;PID is %d\\n\u0026#34;, pid); if (pid == 0) { number *= number; printf(\u0026#34;\\tIn the child, the number is %d -- PID is %d\\n\u0026#34;, number, pid); return 0; } else if (pid \u0026gt; 0) { wait(NULL); printf(\u0026#34;In the parent, the number is %d\\n\u0026#34;, number); } return 0; } Output\nRunning the fork example The initial value of number is 7 PID is 15839 PID is 0 In the child, the number is 49 -- PID is 0 In the parent, the number is 7  #include \u0026lt;sys/types.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;unistd.h\u0026gt; int number = 7; int main(void) { pid_t pid; printf(\u0026#34;\\nRunning the fork example\\n\u0026#34;); printf(\u0026#34;The initial value of number is %d\\n\u0026#34;, number); pid = fork(); printf(\u0026#34;PID is %d\\n\u0026#34;, pid); if (pid == 0) { number *= number; fork(); printf(\u0026#34;\\tIn the child, the number is %d -- PID is %d\\n\u0026#34;, number, pid); return 0; } else if (pid \u0026gt; 0) { wait(NULL); printf(\u0026#34;In the parent, the number is %d\\n\u0026#34;, number); } return 0; } Output\nRunning the fork example The initial value of number is 7 PID is 15847 PID is 0 In the child, the number is 49 -- PID is 0 In the child, the number is 49 -- PID is 0 In the parent, the number is 7 We can determine which print line belongs to the child and which belongs to the grandchild by storing the value of the second fork().\n"}),a.add({id:217,href:'/notes/CS139/CS139-lecture-20210921/',title:"CS139-lecture-20210921",section:"CS139",content:"Processes cont. #  Termination #  A parent cannot wait on a grandchild.\nInter-process communication #  Message passing\n uses send and receieve API calls slower, more expensive small amount of data distributed   Shared memory\n process A sets aside some memory for process B restrictions must be lifted by kernel faster and cheaper because minimal kernel involvement doesn\u0026rsquo;t work for distributed systems (2 processes on remote machines)    Shared memory communication #  This uses a circular buffer:\nWe can only hold BUFFER_SIZE - 1 items, because we don\u0026rsquo;t want in and out to point at the same item when the buffer is full. in == out indicates that the buffer is empty. If we add BUFFER_SIZE items, then in == out and it\u0026rsquo;ll get stuck in the consumer\u0026rsquo;s while loop.\nIf we introduce a counter, we can utilize the entire buffer.\nMessage passing memory communication #  A good analogy for indirect communication is a drop off mailbox.\n"}),a.add({id:218,href:'/notes/CS139/CS139-lecture-20210923/',title:"CS139-lecture-20210923",section:"CS139",content:"Processes cont. #  Using fork and execl #  Consider this code\npid_t pid1, pid2; int status; struct rusage usage; if ((pid1=fork())) { printf(\u0026#34;I am parent %d; child is %d\\n\u0026#34;,getpid(),pid1); pid2=wait3(\u0026amp;status, 0, \u0026amp;usage); printf(\u0026#34;exit code for %d is %d\\n\u0026#34;, pid2, status); } else { execl(\u0026#34;/bin/cat\u0026#34;, \u0026#34;/bin/cat\u0026#34;, \u0026#34;/csc/139/news/0001.txt\u0026#34;, NULL); printf(\u0026#34;we should never get here!\\n\u0026#34;); } execl loads cat into the child\u0026rsquo;s memory space. When this child cat exits, it will never reach the subsequent printf.\nThis outputs\nI am parent ...; child is ... cat of 0001.txt exit code for ... is ... Another output possibility could be\ncat of 0001.txt I am parent ...; child is ... exit code for ... is ...  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;unistd.h\u0026gt;int main(int argc,char *argv[]) { printf(\u0026#34;A\\n\u0026#34;); fork(); printf(\u0026#34;B\\n\u0026#34;); fork(); printf(\u0026#34;C\\n\u0026#34;); return 0; } Output\nA B B C C C C Threads #  So far, the processes that we have defined only have one thread of execution.\nIdea: allow multiple threads of execution within the same process environment, to a large degree independent of each other.\nThreads maintain the same code, data, and open files in memory. Each thread will have its own registers and stack. Threads will share the heap. The thread\u0026rsquo;s register and stack will swap when switching to another thread.\nMultithreading #  PCB\n pid state pc registers open files \u0026hellip;   TCB (Thread control block)\n state pc registers    The server will dispatch threads and then continue listening.\nBenefits #  Multicore programming #  Concurrency\n supports more than one task making progress single processor / core, scheduler providing concurrency interleaves processes   Parallelism\n implies a system can perform more than one task simultaneously    User threads and kernel threads #  User processes\n can only run in user mode threads running in user mode are user processes   Kernel processes\n can only run in kernel mode threads running in kernel mode are kernel processes    "}),a.add({id:219,href:'/notes/CS139/CS139-lecture-20210928/',title:"CS139-lecture-20210928",section:"CS139",content:"Threads cont. #  How TCBs are mapped to the processes address space.\nUser-level threads #  Multithreading models #  The bottleneck created by the many-to-one model can be alleviated in the one-to-one model.\nThe M:M model maintains slightly more user threads than kernel threads.\nSo why do the biggest OSes use the one-to-one model? More cores in CPUs, more CPUs in general.\nThread libraries #  Implicit threading #  Issues #  Single threaded  Multi-threaded has 2 possibilities The child can either have 1 thread (the invoking thread), or all.   Thread local storage is stuff like\n stack allocated variables parameters return values other things on stack  "}),a.add({id:220,href:'/notes/CS139/CS139-lecture-20210930/',title:"CS139-lecture-20210930",section:"CS139",content:"CPU scheduling #  Long term scheduling\n job scheduling decides which process should enter the ready state   Short term scheduling\n cpu scheduling decides which ready process should run next on the CPU    Recall the overall state diagram for a process:\nNon-preemptive vs preemptive scheduling #  Preemptive here basically means \u0026ldquo;pause\u0026rdquo;. So the non-preemptive scheduling can only work in cases 1 and 4 (from prior slides). Preemptive scheduling can happen in cases 1-4.\nDispatcher #  Criteria #  These criteria can be used to evaluate the scheduler\u0026rsquo;s quality.\nWaiting time is the total amount of time waiting, whereas response time is how long it takes until the request is submitted, but not necesarily completed.\nWaiting time #  Note the assumptions in the above slide for later slides. Since each process runs to completion, this is non preemptive scheduling.  First come first served #  This is based on a FIFO queue.\nBy putting the shorter processes first, the overall average wait time is much better. So, the order in which the processes enter the queue really matters.\nWith a FIFO schedule, a slow process may create a blockage, known as the convoy effect:\nShortest job first #  Minimal spanning tree algorithms, like Prim\u0026rsquo;s and Kruskal\u0026rsquo;s, share the same underlying principle to a shortest job first scheduler. Shortest job first is a greedy algorithm.\nShortest remaining time first (preemptive) #  Response time #     \\( P_1 \\)  \u0026rsquo;s response time is 0.\n"}),a.add({id:221,href:'/notes/CS139/CS139-lecture-20211005/',title:"CS139-lecture-20211005",section:"CS139",content:"CPU scheduling cont. #  I/O Bursts #  Round robin #  Round robin strives on optimizing average response time.\nIf we make the value of   \\( q \\)  too small, we will have a lot of overhead due to context switches.\nPriority scheduling #  Technically, shortest job first is a type of priority scheduling (prioritizing shortest burst time).\nMultilevel queue #  Scheduling in Linux (CFS) #  Priority levels are 0-139.\n The smaller the priority number, the higher the priority. The higher priority processes have larger time quantums. Feedback based on sleep time (waiting/idle)  longer sleep processes are usually interactive, so we bump up the priority (lower value) shorter sleep processes are usually computational process, so we bump the priority down (higher value)   The run queue is 2 arrays of tasks  Real time\n important programs priority levels 0-99   Time sharing\n user programs priority levels 100-140 default is 120    Picking the next item in the array is constant time. When we create a process, we add it to the corresponding task list, based on priority.\nWhen the active array is exhausted, it is swapped with the expired array.\nHowever, this scheduling algorithm has some problems\n performance of interactive processes can be slow fairness issue  Linux\u0026rsquo;s new CFS (Completely Fair Scheduler) addresses these problems:\n CFS uses a red-black tree for its run queue The value that the red-black tree is ordered is called vruntime, which is the \u0026ldquo;virtual run time\u0026rdquo; that is a function of the run time.   CFS scheduling always picks leftmost node, the smallest value (smallest vruntime value) periodically address vruntime and compare to the leftmost, if it is still smaller we will allow the process to continue to run. When the vruntime surpasses the leftmost in the run queue tree, it will switch to the new smaller value. (Similar to shortest run time, but we\u0026rsquo;re looking at the history) vruntime progress rate depends on priority  progress rate faster for low priority progress rate slower for high priority   note that only 1 tree is used, for all priority  "}),a.add({id:222,href:'/notes/CS139/CS139-lecture-20211007/',title:"CS139-lecture-20211007",section:"CS139",content:"Scheduling cont. #  CFS cont. #  Recall that vruntime is a function, not the actual runtime of the process. The progress rate depends on the priority of the process.\n faster progress rate for low priority process slower progress for high priority process  Since we are always looking for the leftmost node in the process run queue, we can maintain a pointer to get the min value in constant time. Adding a node to a red-black tree can be done in   \\( O(\\lg n) \\)  time.\nThe overall time complexity for the CFS scheduler is  \\( O(\\lg n) \\)  . So this is a slower time complexity than the prior scheduler before CFS, but it is a lot more fair of a scheduler.\n"}),a.add({id:223,href:'/notes/CS139/CS139-lecture-20211021/',title:"CS139-lecture-20211021",section:"CS139",content:"Process synchronization #  Race condition #  Critical section and mutual exclusion #  In the above code examples, the counter++ and counter-- are considered a critical section.\nHow to implement mutual exclusion #  Note: This solution isn\u0026rsquo;t fully correct.  producer: while (lock == 0) lock = 1 put lock = 0 consumer: while (lock == 0) lock = 1 fetch lock = 0 The problem with this code is that if the OS does a context switch during a critical section, it can create an error.\nOne solution is to disable interrupts.\nSync hardware, spin locks and compare-and-swap #  Mutex locks #  Mutex locks allow the OS to provide a mutual exclusion as a service.\nSemaphores #  A semaphore is simply a non-negative interger that has two valid operations.\n"}),a.add({id:224,href:'/notes/CS139/CS139-lecture-20211026/',title:"CS139-lecture-20211026",section:"CS139",content:"Synchronization cont. #  Since these could output in any order, we can setup semaphores to ensure the run order.\nBounded buffer problem #   full and empty are counting semaphores.  full notifies consumers how many items are there empty notifies producers how many empty slots available   mutex is a binary semaphore.   mutex starts at 1, \u0026ldquo;unlocked\u0026rdquo;, so the first process can have mutual exclusion full is set to 0, and empty is set to n, because all slots are available   The first wait(empty) checks if there is an empty slot wait(mutex) checks if there is a process accessing the shared buffer wait(full) checks if there is any items to consume  Consider switching the order of the first to wait functions, to:\nwait(mutex); wait(empty); This would have the consequences of being able to get mutual exclusion first, then all other processes would be prevented from running. But then if the buffer is already full it won\u0026rsquo;t ever get past the wait(empty). So, the order cannot be swapped.\nNext, consider switching the order of the signal functions:\nsignal(full); signal(mutex); This is actually okay because the order of the unlock does not matter as much. The other process is waiting for both locks to continue.\nThe readers writers problem #  This is a slight difference in the producer consumer problem, because readers actually don\u0026rsquo;t change the shared buffer (just read it). Also, any number of readers can access data simultaneously.\n multiple readers are reading database new readers may join new writer must waiting   new readers must wait new writers must wait   if a new writer arrives at   \\( t = 1 \\)  , it waits if a new reader arrives at  \\( t=2 \\)  , there are 2 variations:  skip the line and join the other readers, prioritizing readers wait behind the writer, prioritizing writers    Why ensure mutual exclusion for updating readcount? We need to make sure that the readcount variable is being updated atomically.\nNote: The solution to the second readers writers problem (prioritizing writers) is more complex. It requires five variables.  The dining philosophers problem #   you can only use your adjacent chopsticks you can only pick up one chopstick each turn you can eat when you have both chopsticks the goal is to order the picking up and placing of chopsticks without deadlock or starvation  So if everyone starts by picking up the left chopstick, then the right chopstick, it will end up in deadlock.\nWe can treat each philosopher as a process, and the chopstick as a competing resource.\n wait(fork[i]) waits for the left chopstick wait(fork[i+1 % 5]); waits for the right chopstick then they may eat then they put the chopsticks back down right then left using the signal functions however, this current state results in deadlock  Note: fork here is the chopstick, for brevity.  "}),a.add({id:225,href:'/notes/CS139/CS139-lecture-20211028/',title:"CS139-lecture-20211028",section:"CS139",content:"Synchronization cont. #  Weakness of the semaphore #  In class exercises #   2 semaphores, 1 mutex semaphore allowing access to laoding zone, and 1 counting semaphore checking if there is a car waiting mutex initialized to 1 (unlocked) car counting semaphore initialized to   \\( n \\)     2 binary semaphores, with ping\u0026rsquo;s semaphore being set to 1 initially, and pong\u0026rsquo;s being set to 0. Since we want A to start, it\u0026rsquo;s initial semaphore is set to 1 Since we want pong to be after, we set its initial semaphore value to 0  Thread A\nwhile(1) wait(A) print \u0026quot;ping\u0026quot; signal(B)   Thread B\nwhile(1) wait(B) print \u0026quot;pong\u0026quot; signal(A)    Deadlocks #  A situation where process sync becomes locked (like when all diners try to grab left chopstick in the philosopher\u0026rsquo;s problem). A system with limited resources may experience deadlock (if there were enough chopsticks then there wouldn\u0026rsquo;t be deadlock).\n if thread 1 runs first, it grabs the first mutex if there is a context switch, and thread 2 tries to gain mutex, it grab the second mutex when thread 1 tries to get second mutex, it will be blocked and have to wait both threads are now locked, waiting for each other eventually both threads will starve  This really happens because both threads are attempting to gain both mutexs in opposite order. If we visually graph this, you can see it forms a cycle:\nCharacterization #  When trying to avoid deadlock, we just need to make 1 of these above conditions false.\nResource allocation graph #  The above graph of the thread 1/2 deadlock was a resource allocation graph.\n requests edges can be approved or denied an assignment edge represents something that has already happened   request edges point to the entire resource assignment (allocation) edges point to the particular instant of the resource  "}),a.add({id:226,href:'/notes/CS139/CS139-lecture-20211102/',title:"CS139-lecture-20211102",section:"CS139",content:"Deadlocks cont. #  Resource allocation graph cont. #     \\( P_2 \\)  and  \\( P_4 \\)  have the ability to exit, so the resources they hold will be allocated elsewhere. No deadlock.\nWe can use a depth first search to look for cycles, to detect the possibility of deadlock.\nMethods for handling deadlocks #   to impose total order: if we have multiple resources, force process requests for resources in an increasing order of enumeration  So, from the example before, if we swap the order in which each thread obtains lock (so they request the locks in the same order), we eliminate the deadlock:\nDeadlock avoidance #   dotted lines indicate future requests, so we can detect cycles  Banker\u0026rsquo;s algorithm #  Another algorithm from Dijkstra. The banker\u0026rsquo;s algorithm can be used where there are multiple instances of a resource type.\n available is the resource pool, the unallocated resources max is a matrix that stores the maximum use of each process, a quota for each process (the most resources a process may request) allocated is a matrix that stores the currently allocated resources to their respective process need is a matrix that stores how many more resources a process may request in the future  Total resources can be obtained by adding allocated + available.\nThe first subroutine in the banker\u0026rsquo;s algorithm is the safety algorithm:\n returns whether the current state is safe or not step 3 basically simulates that the process completes  "}),a.add({id:227,href:'/notes/CS139/CS139-lecture-20211104/',title:"CS139-lecture-20211104",section:"CS139",content:"Deadlocks cont #  Banker\u0026rsquo;s algorithm cont. #  Recall that the safety subroutine simulates allocating all resources, and if able to if returns true (because it is considered a safe state). If it is unable to simulate allocating all resources, it will return false.\nThe second subroutine of the Banker\u0026rsquo;s algorithm is the resource request:\n simulates allocating resource requests by modifying the state of the process if safe, the resources can be allocated otherwise, it has to wait  Example using Banker\u0026rsquo;s algorithm #  So first we run the safety algorithm:\nAfter the initial loop thru all processes, we then go back and check the remaining false finished processes.\nThis returns a safe sequence. A safe sequence may or may not be unique.\nWhen   \\( P_1 \\)  requests (1,0,2), the resource request subroutine is called.\nThen, the safety algorithm runs on this new simulated state. If it returns true, then we can approve this request. Otherwise, it is denied.\nDeadlock detection #  Incase we can\u0026rsquo;t always avoid deadlock, we need a way to detect whether we are in a deadlock state or not.\nOnce the wait-for graph is built, we can see that there are cycles (2). However, for multiple instance case, we rely on a variation of the Banker\u0026rsquo;s algorithm.\n this is the safety algorithm in the detection version if any process\u0026rsquo;s finish[i] is false, then a deadlock has occured  "}),a.add({id:228,href:'/notes/CS139/CS139-lecture-20211109/',title:"CS139-lecture-20211109",section:"CS139",content:"Memory Management #   recall, CPU does not have direct access to the disk, it must use the bus   note that the OS itself is a program residing in memory  Addresses #   notice that logically, the address 99 and 100 are next to each other in the purple program. However, physically they are not adjacent (non contiguous).  There are other types of addresses:\nConsider a variable declaration like:\nvar count; This is considered a symbolic address. We as the programmer don\u0026rsquo;t know the actual physical address, but we have a symbol that represents the address.\n Consider \u0026ldquo;14 bytes from the beginning of the module\u0026rdquo;.\nThis is considered a relocatable address.\n Consider an address like 0x7401.\nThis is considered an absolute address.\n  The symbolic address becomes a relocatable address in the executable. The relocatable address in the executable will become an absolute address when the program is running.\nUni-programming #  In uni-programming, we can only run 1 program at once. So, only 1 program can exist in memory at a time. If we want to switch to the next program, we need to swap out process\u0026rsquo;s memory.\nThis ends up being inefficient due to slow I/O.\nMultiple programs sharing memory #  Static relocation #   Static relocation is \u0026ldquo;software based relocation.\u0026rdquo; The loader does this during load time.  Dynamic relocation #   dynamic relocation is \u0026ldquo;hardware based relocation.\u0026rdquo;   when   \\( P_1 \\)  tries to write to  \\( P_2 \\)  \u0026rsquo;s address space, it will not be allowed (based on a simple check with the limit register).  Contiguous allocation #  Contiguous allocation is like the blue process in the drawing above. It is loaded into 1 contiguous place.\nAllocation policies #   \u0026ldquo;next fit\u0026rdquo; is basically \u0026ldquo;first fit\u0026rdquo; but starting at the position of the last allocated memory address \u0026ldquo;best fit\u0026rdquo; requires an exhaustive search (or sort the list based on hole size)  "}),a.add({id:229,href:'/notes/CS139/CS139-lecture-20211116/',title:"CS139-lecture-20211116",section:"CS139",content:"Memory cont. #  Fragmentation #  The small 2B chunk will never be able to be used, and the sum of all of these small gaps in memory is wasted, called internal fragmentation.\nCompaction #   compaction is expensive to invoke  Swapping #  Segmentation #  One of the methods of implementing non-contiguous memory is segmentation.\n an address may be something like \u0026lt;3, 14\u0026gt;, which represents segment 3 with a 14 byte offset another table keeps track of the segment\u0026rsquo;s addresses and lengths  Paging #   similar to segmentation, except that everything is divided into equal size blocks  Addressing #  VPN = \u0026ldquo;virtual page number\u0026rdquo;, PFN = \u0026ldquo;physical frame number\u0026rdquo;\nPaging hardware #   paging suffers internal fragmentation paging solves external fragmentation   D is the dirty bit, which indicates \u0026ldquo;write needs to be updated on disk\u0026rdquo; A is access bit, indicates if the page has been recently accessed R/W is protection bit, indicates read or write permission P is the valid/invalid bit, the \u0026ldquo;present\u0026rdquo; bit  Paging problems #   where do we store the page table itself? in memory  The TLB is the \u0026ldquo;translation lookaside buffer\u0026rdquo;. MMU is part of the CPU suite.\nTLB Hit\n 1 TLB lookup 1 mem access (load/store)   TLB Miss\n 1 TLB lookup (miss) 1 mem access(page table lookup) 1 TLB update 1 mem access (load/store)    We want a high TLB hit rate.\nEffective access time #  Structure of a page table #  "}),a.add({id:230,href:'/notes/CS139/CS139-lecture-20211118/',title:"CS139-lecture-20211118",section:"CS139",content:"Memory cont. #  Page tables / addressing cont. #   the more hierarchy you have, the more memory accesses you need  Hashed page tables #   we can use either method of resolving collision in the hash table: chaining or linear probing  Inverted page table #   instead of keep track of logical pages, we keep track of physical pages notice that we add a new field to the logical address: pid a linear search is involved at worst case, so the page table can be improved by using a hash table  Virtual memory #  Memory for the point of view of the program.\n how can we run a program that will use more memory than totally available? we\u0026rsquo;ll just load what is necessary  When to load a page? #   pages with the invalid bit do not have a frame number  Page fault #  If there is a reference to a page, but it is not in memory, it causes a page fault.\nDemand paging #   evicted pages go to swap, incase we need to bring it back soon swap space can be in memory, or on hard drive  Page replacement algorithms #   looks at when page was loaded, picks the oldest implement with FIFO queue   theoretically the best, but relies on knowing the future  "}),a.add({id:231,href:'/notes/CS139/CS139-lecture-20211123/',title:"CS139-lecture-20211123",section:"CS139",content:"Virtual memory cont. #  Page replacement algorithms cont. #  Recall:\n FIFO looks at the time the page was initially brought in LRU looks at the last time the page was accessed  Implementing LRU (least recently used)\n counter implementation has an exhaustive search, so   \\( \\Theta(n) \\)  runtime stack implementation has the least recently used at the bottom of the stack, each update is expensive because items are moved to the top of the stack when replaced   circles indicate page fault top shows 3 frame memory, bottom shows 4 frame memory, for comparison   second chance is like a warning before an eviction  "}),a.add({id:232,href:'/notes/CS139/CS139-lecture-20211202/',title:"CS139-lecture-20211202",section:"CS139",content:"Mass storage #  Magnetic disks #   we want to keep the same rate of data moving under the head.   a track is 2D but the entire disk is 3D  Watch: Inside of a hard disk drive  Disk performance #   seek and rotate times dominate the total latency hard disks are at the milisecond level  Disk history #  Solid state disks #   SSDs are generally faster because they do not have any moving parts, thus no seek and rotate times, this greatly speeds up the total latency SSDs are at the microsecond level  Magnetic tape #   magnetic tape remains in use today as a tertiary storage ideal for backup/logs  Disks vs memory #  Disk scheduling #  The one component of disk latency that we have the ability to optimize is the seek time. If we minimize the seek distance we can minimize the seek time.\n needs to know the entire sequence in advance   remember that the \u0026ldquo;giant leap\u0026rdquo; here is still a physical movement  Selecting a disk scheduling algorithm #  RAID #  "}),a.add({id:233,href:'/notes/CS139/CS139-lecture-20211207/',title:"CS139-lecture-20211207",section:"CS139",content:"Disk scheduling exercise #  File systems #  The file system is an abstraction of the collection of disk blocks.\nRequirements on data #  Files #  File names #   inode = index node  Interface to file system #  Directories #   requires unique filenames   requires unique pathnames   this allows multiple users to work on the same file (groups) recall \u0026ldquo;acyclic\u0026rdquo; means the graph does not contain a cycle  Directory operations #  "}),a.add({id:234,href:'/notes/CS139/CS139-lecture-20211209/',title:"CS139-lecture-20211209",section:"CS139",content:"File systems cont. #  Protection #  These permissions are implemented as an ACL (access control list). This keeps track of the capability of every object.\nOther systems keep track of the capability of every subject.\nWhy do most OS choose ACL? (Associating permission with the object, compared to associating permission with the subjects).\nOrganization #  Note: The linear list implementation can be done using a B+ tree.  Allocation #   Contiguous allocation works well with spinning disk memory (no giant leaps) but suffers greatly from external fragmentation   this is the file system used by linux   linked files is a non-contiguous allocation no more external fragmentation sequential access is easy random access is still a linear operation lots of physical movement for spinnning disks   maintain head and tail (to add to end)   File-Allocation Table = FAT, an example of the linked allocation.   OS must maintains pointer arrays for each file   block 19 doesn\u0026rsquo;t store any data from the file, just an array of pointers currently using 5 out of 8 sectors available sequential access is easy random access is easy  So how do we allow the file size to grow beyond maximum?\nNotes on the final #  Make sure I know how to calculate:\n fork(), exec(), wait() system calls Scheduling algorithms as Gantt charts  FCFS SJF SRTF RR Average wait time, turnaround time, response time Start counting once the process arrives, not from   \\( t = 0 \\)     Semaphore order with wait() and signal()  look for race conditions deadlock   Semaphore based solutions like  bounded buffer readers writers dining philosophers   Deadlock avoidance  Banker\u0026rsquo;s algorithm avoid version ensures system doesn\u0026rsquo;t enter unsafe state Safety checks if we\u0026rsquo;re in a safe state Resource-request checks if the process can receieve resource, and if so it checks the state using safety alg after \u0026ldquo;allocating\u0026rdquo;   Deadlock detection  Safety algorithm detection version checks to see if system is in unsafe state   Memory allocation  First fit, best fit, worst fit    Translatoin look-aside buffer (TLB)  Usually given page size, if we know the page size then  we know the offset (binary log of page size) Also know the VPN bits, (the difference) The VPN bits gives us the number of virtual pages   If asking for page table size  Size depends on the size of a page table entry (for example 4B) multiplied by number of pages   Performance: effective access time  Probability of a TLB hit and TLB miss probability of hit * time + probability of miss * time     Page faults  Effective access similar to TLB   Demand paging  FIFO Optimal LRU CLOCK  The numbers are addresses, they must be converted from addresses into page numbers first Calc using address mod page size  Run the algorithms using those page numbers   Access time for storage  Seek time + rotational latency + data transfer   Disk scheduling  FCFS SSTF SCAN/C-SCAN with/without LOOK   Multilevel indexed files  EXT2 filesystem, where do we find the data How many steps to fetch the data? (How many indexed tables do we need to hop) Check group exercise    Exam covers about 40% of midterm 1, 40% of midterm 2, 20% of rest\n"}),a.add({id:235,href:'/notes/CS140/CS140-lecture-20210830/',title:"CS140-lecture-20210830",section:"CS140",content:"Course orientation #  Syllabus #  File: 140-syllabus.pdf  Notes during orientation #   Regular quizzes 2 exams Modules has prerecorded lectures Homework assignments not graded Can watch videos during Zoom meeting, or prior Generally 1 quiz per lecture (calendar at end of syllabus), given at the first class after the last day of the lecture Turn in work as single PDF file  Methods of proof #  File: 140-methods_of_proof.pdf  Recap on methods of proof.\nDirect method #  A method we use to prove a statement directly. If we want to prove \u0026ldquo;if   \\( p \\)  then  \\( q \\)  \u0026rdquo;, we try to prove it directly by assuming if  \\( p \\)  is true, then  \\( q \\)  is true.\nProof by Counter Example #  A method we use when a general statement is stated, and we want to disprove it. If someone says \u0026ldquo;all triangles have the same length sides\u0026rdquo;, all we have to do is come up with a triangle that doesn\u0026rsquo;t have the same length sides.\nProof by Contradiction #  We assume that the negation of the statement is true, so we assume that  \\( p \\wedge \\neg q \\)  is true through contradiction.\n \\[\\begin{aligned} p \\to q \\equiv \\neg(p \\wedge \\neg q) \\end{aligned}\\]  A contradiction is generally a false statement.\nProof by Contrapositive #  The contrapositive of  \\( p \\to q \\)  is  \\( \\neg q \\to \\neg p \\)  .\n\u0026ldquo;If I wake up early, then I go to school.\u0026rdquo; The contrapositive of this would be \u0026ldquo;if I don\u0026rsquo;t go to school, I didn\u0026rsquo;t wake up early.\u0026rdquo;\nTo prove by contrapositive you try to prove  \\( \\neg q \\to \\neg p \\)  .\nProof by Mathematical Induction #  More examples in document above.\n Remember,  \\[\\begin{aligned} p \\to q \\end{aligned}\\]  does NOT mean that  \\[\\begin{aligned} \\neg p \\to \\neg q \\end{aligned}\\]   "}),a.add({id:236,href:'/notes/CS140/CS140-lecture-20210901/',title:"CS140-lecture-20210901",section:"CS140",content:"A note on learning in this class #  On different levels of learning\nWe will strive for about 60% of problems being level 3.\nWhen working on a problem, there can be 3 outcomes\n could solve it could not solve it solved, but incorrect  If solved incorrectly, tracing back to the exact part that went wrong can be really beneficial.\nMethods of proof cont. #  An easy starting example #  Suppose that   \\( x \u0026gt; 3 \\)  , is  \\( x^2-2y \u0026gt; 5 \\)  ?\nNote: Remember, this is a universal statement. So it is asking whether that is true for all  \\( x \\)  and  \\( y \\)  .  The first thing we can try to do is disprove the statement. We need to come up with values that show that this statement is false. Lets say we let  \\( x=4 \\)  , and  \\( y=10 \\)  , so\n \\[\\begin{aligned} 4^2 - 2(10) \u0026amp;\u0026gt; 5 \\\\ -4 \u0026amp;\\not \u0026gt; 5 \\end{aligned}\\]  So, by counter example, it is not true for all  \\( x \\)  and  \\( y \\)  values.\nExample 2 #  Suppose that  \\( a,b \\in \\mathbb{R} \\)  . If  \\( 0 \u0026lt; a \u0026lt; b \\)  , then  \\( a^2 \u0026lt; b^2 \\)  . We can let\n \\[\\begin{aligned} p \u0026amp;= 0 \u0026lt; a \u0026lt; b \\\\ q \u0026amp;= a^2 \u0026lt; b^2 \\end{aligned}\\]  The question is saying that \u0026ldquo;if  \\( p \\)  then  \\( q \\)  .\u0026rdquo;\nWe can start by trying to see if  \\( p \\to q \\)  is true. Lets start with  \\( p \\)  , and see if we can get to  \\( \\)   \\[\\begin{aligned} 0 \u0026lt; a \u0026amp;\u0026lt; b\\\\ a \\cdot a \u0026amp;\u0026lt; b \\cdot a \\\\ a^2 \u0026amp;\u0026lt; ab\\\\ \\end{aligned}\\]  Also,\n \\[\\begin{aligned} a \\cdot b \u0026amp;\u0026lt; b \\cdot b \\\\ ab \u0026amp;\u0026lt; b^2 \\end{aligned}\\]  And we can plug it back in:\n \\[\\begin{aligned} a^2 \u0026lt; ab \u0026lt; b^2 \\\\ a^2 \u0026lt; b^2 \\end{aligned}\\]  Example 3 #  Suppose that  \\( a,b,c \\in \\mathbb{R} \\)  and  \\( a \u0026gt; b \\)  . If  \\( ac \\leq bc \\)  , then  \\( c \\leq 0 \\)  .\nLooking at the direct method to solve this\n \\[\\begin{aligned} ac \\leq bc \\to c \\leq 0 \\end{aligned}\\]  show that it may be difficult to prove that given the constraints above. We can look at the opposite direction (remembering that  \\( a \u0026gt; b \\)  ),\n \\[\\begin{aligned} c \\leq 0 \\to ac \\leq bc \\end{aligned}\\]  to see that the problem is more doable.\nIf  \\( c = 0 \\)  , then\n \\[\\begin{aligned} ac = bc \\end{aligned}\\]  and if  \\( c \u0026lt; 0 \\)  , then\n \\[\\begin{aligned} c( a \u0026gt; b) = ac \\leq bc \\end{aligned}\\]  So in this case it was easier to prove  \\( \\neg q \\to \\neg p \\)  .\nExample 4 #  Show that for any natural number  \\( n \\)  ,\n \\[\\begin{aligned} 2^0 \u0026#43; 2^1 \u0026#43; \\cdots \u0026#43; 2^n = 2^{n\u0026#43;1} - 1 \\end{aligned}\\]  If we call this function  \\( p(n) \\)  , then the problem is really asking  \\( \\forall n \\in \\mathbb{N} : p(n) \\)  (is true). For this problem, we can try mathematical induction.\nSince the domain for this is natural numbers, we can start from 0 and increase.  \\( p(0) \\)  should be the base case, lets see:\n \\[\\begin{aligned} p(0) \u0026amp;= 2^0 = 2^{0\u0026#43;1} - 1 \u0026amp; \\text{true}\\\\ \\end{aligned}\\]  The inductive step: Suppose that  \\( p(n) \\)  is true, we show that  \\( p(n\u0026#43;1) \\)  is true.\n \\[\\begin{aligned} p(n) \u0026amp;= 2^0 \u0026#43; 2^1 \u0026#43; \\cdots \u0026#43; 2^n = 2^{n\u0026#43;1} - 1 \\\\ p(n\u0026#43;1) \u0026amp;= 2^0 \u0026#43; 2^1 \u0026#43; \\cdots \u0026#43; 2^{n\u0026#43;1} = 2^{(n\u0026#43;1)\u0026#43;1} - 1 \\end{aligned}\\]  Lets start with the left side of  \\( p(n\u0026#43;1) \\)  , and substitute in  \\( p(n) \\)   \\[\\begin{aligned} \\overbrace{\\underbrace{2^0 \u0026#43; 2^1 \u0026#43; \\cdots \u0026#43; 2^n}_{p(n)} \u0026#43; 2^{n\u0026#43;1}}^{p(n\u0026#43;1)} \u0026amp;= (2^{n\u0026#43;1} - 1) \u0026#43; 2^{n\u0026#43;1} \\\\ \u0026amp;= 2 \\cdot 2^{n\u0026#43;1} - 1 \\\\ \u0026amp;= 2^{(n\u0026#43;1)\u0026#43;1} - 1 \\end{aligned}\\]  So, by mathematical induction it is true.\nExample 5 #  Show that  \\( \\forall n \\geq 5 : 2^n \u0026gt; n^2 \\)  .\nNote: Since the variable is named  \\( n \\)  , and  \\( n \\)  starts as being equal to or greater than a natural number, we can assume that  \\( n \\)  is also a natural number. If  \\( n \\)  was real, the problem would most likely explicitly state that  \\( n \\)  is real.  Lets use mathematical induction for this problem, with the base case being  \\( p(5) \\)  :\n \\[\\begin{aligned} p(5) \u0026amp;= 2^5 \u0026gt; 5^2 \\\\ \u0026amp;= 32 \u0026gt; 25 \u0026amp;\\text{true} \\end{aligned}\\]  Inductive step: Assume  \\( p(n) \\)  is true, show that  \\( p(n\u0026#43;1) \\)  is true,\n \\[\\begin{aligned} p(n) \u0026amp;= 2^n \u0026gt; n^2 \\\\ p(n\u0026#43;1) \u0026amp;= 2^{n\u0026#43;1} \u0026gt; (n\u0026#43;1)^2 \\end{aligned}\\]  Lets start with the left side of  \\( p(n\u0026#43;1) \\)  , and substitute in  \\( p(n) \\)   \\[\\begin{aligned} 2^{n\u0026#43;1} = 2 \\cdot 2^n \u0026amp;\u0026gt; 2 \\cdot n^2 = 2 n^2 \\\\ \\end{aligned}\\]  Lets see if we can make  \\( 2n^2 \\)  as similar to  \\( (n\u0026#43;1)^2 \\)  as possible\n \\[\\begin{aligned} 2n^2 \\geq n^2 \u0026#43; 2n \u0026#43; 1 \\\\ n^2 \\geq 2n \u0026#43; 1 \\\\ n \\geq 2 \u0026#43; \\frac{1}{n} \\end{aligned}\\]  So as long as\n \\[\\begin{aligned} n \\geq 2 \u0026#43; \\frac{1}{5} \\end{aligned}\\]  We can argue that since\n \\[\\begin{aligned} n \\geq 2 \u0026#43; 1 \\geq 2 \u0026#43; \\frac{1}{n} \\end{aligned}\\]  So,\n \\[\\begin{aligned} 2^{n\u0026#43;1} \\geq (n\u0026#43;1)^2 \\end{aligned}\\]  Example 6 #  Show that for any  \\( n \u0026gt; 0 \\)  , a  \\( 2^n \\times 2^n \\)  grid square with any one square removed can be covered with L shaped tiles.\nSo for  \\( n = 1 \\)  :\nThe domain of this problem is all the squares made up of  \\( 2^n \\times 2^n \\)  , with the base case being  \\( n = 1 \\)  . So we can use mathematical induction.\nThe base case for the  \\( 2 \\times 2 \\)  grid shows that if any of the squares are removed, the rest can be covered with an L shape. We can show all 4 cases:\nThe inductive step: lets assume that it is true for  \\( 2^n \\times 2^n \\)  grid sizes, lets show it is true for  \\( 2^{n\u0026#43;1} \\times 2^{n\u0026#43;1} \\)  grid sizes also.\nIf we think of one square being removed in the top right quadrant, we can cover that with an L shape.\nThen we can think of that entire quadrant as being the square removed, and cover the middle 3 with an L shape.\nThe rest of each quadrant can now be covered with another L shape each.\nAsymptotic analysis #  File: 140-1.pdf  Anything worse than polynomial time, generally is not practical.\nIf we double the input size in a polynomial-time function, the algorithm should only slow down by some constant factor, ie\n \\[\\begin{aligned} n^2 \\to (2n)^2 \\to 4n^2 \\end{aligned}\\]  Compare with a non-polynomial run time:\n \\[\\begin{aligned} 2^n \\to 2^{2n} \\to 2^n \\cdot 2^n \\end{aligned}\\]  this shows that it does not increase by a constant factor, therefore it is not a polynomial time.\nExecution time depends greatly on the hardware that the program is running on.\nExample 1 #  The total cost of algorithm 1 is  \\( c_1 N \\)  The loop in algorithm 2 will run  \\( N\u0026#43;1 \\)  times, and the body of the loop will run  \\( N \\)  times, so the total cost is  \\( (c_2 \u0026#43; c_1) N \u0026#43; c_2 \\)  The outer loop runs  \\( N\u0026#43;1 \\)  times, and the inner loop run  \\( (N\u0026#43;1)N \\)  . The body of the inner loop will run  \\( N \\cdot N \\)  times. So, the total cost is\n \\[\\begin{aligned} c_1 \u0026#43; c_2(N\u0026#43;1) \u0026#43; c_2 N (N\u0026#43;1) \u0026#43; c_3 N^2 \\end{aligned}\\]  Comparing algorithms #  When analyzing an algorithm, we will go with a rough measure of the total cost. This is usually the highest degree, the rate of growth, of the function.\nThe rate of growth is dominated by the cost of elephants because they cost a lot more. So the rate of growth can be approximated by just looking at the cost of elephants.\nAsymptotic notation #   Big  \\( O \\)  , upper bound Big  \\( \\Theta \\)  , exact bound Big  \\( \\Omega \\)  , lower bound  When looking for a tight bound, look for the Big  \\( \\Theta \\)  .\nIf we have\n \\[\\begin{aligned} 2n^2 - n \u0026#43; 5 \\end{aligned}\\]  the  \\( n^2 \\)  dominates as  \\( n \\to \\infty \\)  . So the runtime is  \\( O(n^2) \\)  .\nWhile the algorithms may start with  \\( f_B \\)  being faster, once  \\( n \\)  gets large enough it will grow faster than  \\( f_A \\)  .\nNote: If we have  \\[\\begin{aligned} 2n^2 \u0026#43; 5 \\lg n \\end{aligned}\\]  the exponential term will always dominate the logarithmic term, so  \\( O(n^2) \\)  .\n Example problems #  Prove that  \\( 2n^2 = O(n^3) \\)  .\nWe want to find  \\( c \\)  and  \\( n_0 \\)  such that  \\( \\forall n \\geq n_0: 0 \\leq f(n) \\leq c(g(n)) \\)  .\nSo,\n \\[\\begin{aligned} 2n^2 \u0026amp;\\leq c n^3 \\end{aligned}\\]  and solve for  \\( c \\)  .\n \\[\\begin{aligned} 2 \u0026amp;\\leq cn \\\\ \\frac{2}{n} \u0026amp;\\leq c \\end{aligned}\\]  So this works when  \\( c = 2 \\)  and  \\( n = 1 \\)  , and up. So our initial  \\( n \\)  value that works is  \\( 1 \\)  , so  \\( n_0 = 1 \\)  . This makes the equality true for all values higher than the initial.\nNote: The functions can cross each other, but after the value  \\( n_0 \\)  , the functions no longer cross.   Prove that  \\( n^2 = O(n^2) \\)  .\n \\[\\begin{aligned} n^2 \\leq cn^2 \\to c \\geq 1 \\end{aligned}\\]  So  \\( c = 1 \\)  and  \\( n_0 = 1 \\)  .\n Prove that  \\( 1000n^2 \u0026#43; 1000n = O(n^2) \\)  .\n \\[\\begin{aligned} 1000n^2 \u0026#43; 1000n \\leq cn^2 \\end{aligned}\\]  This doesn\u0026rsquo;t show an easy value for  \\( c \\)  . So we can think of it as\n \\[\\begin{aligned} 1000n^2 \u0026#43; 1000n \u0026amp;\\leq 1000n^2 \u0026#43; 1000 n^2 \\\\ \u0026amp;= 2000 n^2 \\end{aligned}\\]  This works when  \\( n \\geq 1 \\)  .\nSo our  \\( c = 2000 \\)  , and  \\( n_0 = 1 \\)  .\nNote: So the general idea here was to transform the  \\( n \\)  term so it can be combined, and it is easier to see what the  \\( c \\)  value should be.   Prove that  \\( n = O(n^2) \\)  .\n \\[\\begin{aligned} n \u0026amp;\\leq cn^2 \\\\ cn \u0026amp;\\geq 1 \\end{aligned}\\]  So when  \\( c = 1 \\)  and  \\( n_0 = 1 \\)  it is true.\n Show that  \\( 30n \u0026#43; 8 \\)  is  \\( O(n) \\)  .\n \\[\\begin{aligned} 30n \u0026#43; 8 \u0026amp;\\leq cn \\\\ 30n \u0026#43; 8 \u0026amp;\\leq 30n \u0026#43; n \\\\ 30n \u0026#43; 8 \u0026amp;\\leq 31n \\end{aligned}\\]  Note that this is only true when  \\( n \u0026gt; 8 \\)  , so our values are  \\( c = 31 \\)  and  \\( n_0 = 8 \\)  .\nThe point where they cross is  \\( n_0 \\)  .\nNo uniqueness #  Trying to prove something that is not true #  Lets try to prove  \\( 4n^2 = O(n) \\)  .\n \\[\\begin{aligned} 4n^2 \u0026amp;\\leq cn \\\\ 4n \u0026amp;\\leq c \\end{aligned}\\]  Since  \\( n \\)  does not have an upper bound, we cannot have our constant  \\( c \\)  always larger than an arbitrarily large  \\( n \\)  . This is a contradiction.\n Show that  \\( n^2 - 2n \u0026#43; 3 \\lg n = O(n^2) \\)  .\n \\[\\begin{aligned} n^2 - 2n \u0026#43; 3 \\lg n \u0026amp;\\leq cn^2 \\\\ \u0026amp;\\leq n^2 \u0026#43; 3 \\lg n \\\\ \u0026amp;\\leq n^2 \u0026#43; 3n \\end{aligned}\\]  Which we can do because\n \\[\\begin{aligned} \\lg n \\leq n \\\\ n \\leq 2^n \\end{aligned}\\]  So  \\( n_0 = 1 \\)  , and we can see this is true by  \\( 1 \\leq 2^1 = 2 \\)  . The terms can combine to get  \\( c = 4 \\)  :\n \\[\\begin{aligned} \u0026amp;\\leq n^2 \u0026#43; 3 n^2 \\\\ \u0026amp;\\leq 4n^2 \\end{aligned}\\]  "}),a.add({id:237,href:'/notes/CS140/CS140-lecture-20210907/',title:"CS140-lecture-20210907",section:"CS140",content:"Asymptotic notation cont #  Big Omega #  Omega is lower bound (where Big O is upper bound).\nExamples #     \\[\\begin{aligned} 5n^2 = \\Omega(n) \\end{aligned}\\]   \\( \\exists c,n_0 \\)  such that  \\( 0 \\leq c_n \\leq 5 n^2 \\)  So,  \\[\\begin{aligned} c \\leq 5n \\end{aligned}\\]  so  \\( c = 1 \\)  and  \\( n_0 = 1 \\)  .\n  \\[\\begin{aligned} 100n \u0026#43; 5 \\neq \\Omega (n^2) \\end{aligned}\\]   \\( \\exists c, n_0 \\)  such that  \\( 0 \\leq cn^2 \\leq 100n \u0026#43; 5 \\)   \\[\\begin{aligned} 100n \u0026#43; 5 \u0026amp;\\leq 100n \u0026#43; 5n (\\forall n \\geq 1) = 105n \\\\ cn^2 \u0026amp;\\leq 105n \\\\ \u0026amp;\\Rightarrow n(cn - 105) \\leq 0 \\end{aligned}\\]  Since  \\( n \\)  is positive,  \\( cn - 105 \\leq 0 \\Rightarrow n \\leq \\frac{105}{c} \\)  . This is not possible to satisfy, because  \\( n \\)  can be arbitrarily large and go to infinity.  \\( n \\)  can not be smaller than a constant!\n  \\[\\begin{aligned} n = \\Omega (2n) \\end{aligned}\\]   \\( \\exists c,n_0 \\)  such that  \\( 0 \\leq c 2n \\leq n \\)   \\[\\begin{aligned} c 2n \u0026amp;\\leq n \\\\ 2c \u0026amp;\\leq 1 \\\\ c \u0026amp;\\leq \\frac{1}{2} \\end{aligned}\\]  Big Theta #  Big  \\( \\Theta \\)  is both Big  \\( O \\)  and Big  \\( \\Omega \\)  .\nWhen finding  \\( n_0 \\)  we usually find it via  \\[\\begin{aligned} n_0 = \\text{max}(n_0^O, n_0^\\Omega) \\end{aligned}\\]  Examples #   \\[\\begin{aligned} \\frac{n^2}{2} - \\frac{n}{2} = \\Theta(n^2) \\end{aligned}\\]  So, we can first prove that it is  \\( O(n^2) \\)  :\n \\[\\begin{aligned} \\frac{1}{2}n^2 - \\frac{1}{2}n \\leq n^2 \\forall n \\geq 0 \\end{aligned}\\]  where  \\( c_2 = \\frac{1}{2} \\)  and  \\( n_0 \\geq 0 \\)  .\nWe can then prove that it is  \\( \\Omega(n^2) \\)  :\n \\[\\begin{aligned} \\frac{1}{2}n^2 - \\frac{1}{2} n \u0026amp;\\geq \\frac{1}{2}n^2 - \\frac{1}{2} n \\cdot \\left( \\frac{1}{2} n \\right) \\\\ \u0026amp; = \\frac{1}{4} n^2 \\end{aligned}\\]  where  \\( c_1 = \\frac{1}{4} \\)  and  \\( n_0 \\geq 2 \\)  .\nSo for our Big  \\( \\Theta \\)  problem,  \\( n_0 = \\text{max} (0,2) = 2 \\)  .\n When we try to solve something like  \\( n \\neq \\Theta (n^2) \\)  , we can see there is a contradiction:\n \\[\\begin{aligned} c_1 n^2 \\leq n \\leq c_2 n^2 \\end{aligned}\\]  Note: Whenever we get something where  \\( n \\leq c \\)  , we can tell there will be a contradiction, because  \\( n \\to \\infty \\)  .  Relations between different sets #  Note: Factorial terms like  \\( n! \\)  are even worse than  \\( 2^n \\)  .  When we talk about the complexity of an algorithm, it doesn\u0026rsquo;t matter what base we use when we talk about logarithmic growth. This is because we can simply change the bases to anything using the change of base formula (as long as the base is not in the exponent).\nMore examples #  Asymptotic properties #  Common summations #  Mathematical induction #  Remember\n Find the base case In the inductive step, try to find the  \\( S(n) \\)  case inside the  \\( S(n\u0026#43;1) \\)  case.  "}),a.add({id:238,href:'/notes/CS140/CS140-lecture-20210913/',title:"CS140-lecture-20210913",section:"CS140",content:"Backtracking #  Recursive programming can be divided into two categories. One category creates the solution, and the other searches for the solution.\nWhen searching, we want to consider backtracking.\nWe can search these decision trees for our solution in the solution space. When looking for a solution, if we ever reach a subtree that doesn\u0026rsquo;t meet our criteria, we can backtrack.\nStrategies #  Examples #  Pretend that our maze is represented with 0 and 1, a 2D array where 0 is a wall and 1 is not, something like this:\nWe can make a choice, and explore until the end, then backtrack to unchoose and make a new choice.\nNote: Remember, the order doesn\u0026rsquo;t matter in a combination.  My solution in python def permute(s): \u0026#34;\u0026#34;\u0026#34; outputs all possible rearrangements of letters in string s \u0026#34;\u0026#34;\u0026#34; def _permute(s, chosen): if len(s) == 0: print(chosen) else: for i in range(len(s)): _permute(s.replace(s[i], \u0026#34;\u0026#34;), chosen + s[i]) _permute(s, \u0026#34;\u0026#34;) def combinations(n, k): \u0026#34;\u0026#34;\u0026#34; outputs all k combinations of the first n positive integers \u0026#34;\u0026#34;\u0026#34; nums = [i for i in range(1, n + 1)] def _combinations(n, k, start, output): if len(output) == k: print(output) else: for i in range(start, len(nums)): _combinations(n, k, i + 1, output + str(nums[i])) _combinations(n, k, 0, \u0026#34;\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;permute(\u0026#34;morty\u0026#34;)\u0026#39;) permute(\u0026#34;morty\u0026#34;) print(\u0026#34;combinations(6, 3)\u0026#34;) combinations(6, 3) Output\npermute(\u0026quot;morty\u0026quot;) morty moryt motry motyr moyrt moytr mroty mroyt mrtoy mrtyo mryot mryto mtory mtoyr mtroy mtryo mtyor mtyro myort myotr myrot myrto mytor mytro omrty omryt omtry omtyr omyrt omytr ormty ormyt ortmy ortym orymt orytm otmry otmyr otrmy otrym otymr otyrm oymrt oymtr oyrmt oyrtm oytmr oytrm rmoty rmoyt rmtoy rmtyo rmyot rmyto romty romyt rotmy rotym roymt roytm rtmoy rtmyo rtomy rtoym rtymo rtyom rymot rymto ryomt ryotm rytmo rytom tmory tmoyr tmroy tmryo tmyor tmyro tomry tomyr tormy torym toymr toyrm trmoy trmyo tromy troym trymo tryom tymor tymro tyomr tyorm tyrmo tyrom ymort ymotr ymrot ymrto ymtor ymtro yomrt yomtr yormt yortm yotmr yotrm yrmot yrmto yromt yrotm yrtmo yrtom ytmor ytmro ytomr ytorm ytrmo ytrom combinations(6, 3) 123 124 125 126 134 135 136 145 146 156 234 235 236 245 246 256 345 346 356 456    8 queens problem #  Given an 8 x 8 chessboard, place 8 queens so they can not attack each other.\nNote: This can be written for   \\( n \\)  queens in a  \\( n \\times n \\)  chess board.  This results in a terrible complexity of  \\( O((n^2)!) \\)  For really small  \\( n \\)  this will work, (somewhere around  \\( n \u0026lt; 15 \\)  ), despite the complexity being  \\( O(n!) \\)  .\nMy solution in python # Place n queens on a nxn chess board, where no queen can attack another def make_board(n): return [[0 for i in range(n)] for i in range(n)] def print_board(board): for row in board: for col in row: print(str(col) + \u0026#34; \u0026#34;, end=\u0026#34;\u0026#34;) print() def place_queens(board): n = len(board) cols = [i for i in range(n)] def placeable(row, col): # check row for r in board[row]: if r == 1: return False # check col for c in board: if c[col] == 1: return False # check diags ## up left r, c = row - 1, col - 1 while r \u0026gt; -1 and c \u0026gt; -1: if board[r][c] == 1: return False else: r -= 1 c -= 1 ## up right r, c = row - 1, col + 1 while r \u0026gt; -1 and c \u0026lt; n: if board[r][c] == 1: return False else: r -= 1 c += 1 ## down left r, c = row + 1, col - 1 while r \u0026lt; n and c \u0026gt; -1: if board[r][c] == 1: return False else: r += 1 c -= 1 ## down right r, c = row + 1, col + 1 while r \u0026lt; n and c \u0026lt; n: if board[r][c] == 1: return False else: r += 1 c += 1 # valid return True def drop(l, item): new = l.copy() new.remove(item) return new def _place_queens(row, cols): if len(cols) == 0: print(\u0026#34;SOLUTION:\u0026#34;) print_board(board) exit(0) # remove to find ALL solutions else: for col in cols: if placeable(row, col): # choose board[row][col] = 1 # explore _place_queens(row + 1, drop(cols, col)) # unchoose board[row][col] = 0 _place_queens(0, cols) if __name__ == \u0026#39;__main__\u0026#39;: board = make_board(8) place_queens(board) Output\nSOLUTION: 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0    Sudoku #  My solution in Python # Sudoku puzzle solver def make_sudoku_board(): return [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9], ] def print_board(board): for row in board: for col in row: print(col, end=\u0026#34; \u0026#34;) print() def solve(board): def get_nums(row, col): nums = [i for i in range(1, 10)] # eliminate nums from row for r in board[row]: try: nums.remove(r) except: pass # eliminate nums from col for r in board: try: nums.remove(r[col]) except: pass # eliminate nums from matrix mat_row, mat_col = 0, 0 if row \u0026lt; 3: mat_row = 0 elif row \u0026lt; 6: mat_row = 3 else: mat_row = 6 if col \u0026lt; 3: mat_col = 0 elif col \u0026lt; 6: mat_col = 3 else: mat_col = 6 for i in range(mat_row, mat_row + 3): for j in range(mat_col, mat_col + 3): try: nums.remove(board[i][j]) except: pass return nums def _solve(row, col): if row == 8 and col == 8: print(\u0026#34;\\nSOLUTION:\u0026#34;) print_board(board) exit(0) if board[row][col] == 0: for t in get_nums(row, col): # choose board[row][col] = t # explore _solve(row if col \u0026lt; 8 else row + 1, (col + 1) % 9) # unchoose board[row][col] = 0 else: _solve(row if col \u0026lt; 8 else row + 1, (col + 1) % 9) _solve(0, 0) if __name__ == \u0026#39;__main__\u0026#39;: board = make_sudoku_board() print_board(board) solve(board) Output\n5 3 0 0 7 0 0 0 0 6 0 0 1 9 5 0 0 0 0 9 8 0 0 0 0 6 0 8 0 0 0 6 0 0 0 3 4 0 0 8 0 3 0 0 1 7 0 0 0 2 0 0 0 6 0 6 0 0 0 0 2 8 0 0 0 0 4 1 9 0 0 5 0 0 0 0 8 0 0 7 9 SOLUTION: 5 3 4 6 7 8 9 1 2 6 7 2 1 9 5 3 4 8 1 9 8 3 4 2 5 6 7 8 5 9 7 6 1 4 2 3 4 2 6 8 5 3 7 9 1 7 1 3 9 2 4 8 5 6 9 6 1 5 3 7 2 8 4 2 8 7 4 1 9 6 3 5 3 4 5 2 8 6 1 7 9    "}),a.add({id:239,href:'/notes/CS140/CS140-lecture-20210915/',title:"CS140-lecture-20210915",section:"CS140",content:"Recursion #  Recursive tracing #  m(648) m(72) m(9) return 9 My trace\nm(348) a = m(34) a = m(3) return 33 a = 33 b = m(4) return 44 b = 44 return 3344 a = 3344 b = m(8) return 88 b = 88 return 334488 pow example #  My solution\npow(b, e): if e == 0: return 1 return b * pow(b, e - 1) Trace\npow(3, 4) 3 * pow(3, 3) 3 * pow(3, 2) 3 * pow(3, 1) 3 * pow(3, 0) return 1 3 * 1 return 3 3 * 3 return 9 3 * 9 return 27 3 * 27 return 81 81 The runtime of this is   \\( T(n) = T(n - 1) \u0026#43; 1 \\)  , so this is  \\( \\Theta (n) \\)  .\nThe runtime of the optimized verion is  \\[\\begin{aligned} T(2n) \u0026amp;= T(n) \u0026#43; 1 \\\\ T(2n \u0026#43; 1) \u0026amp;= T(2n) \u0026#43; 1 \\end{aligned}\\]  which results in a runtime complexity of  \\( \\Theta (\\lg n) \\)  pow(m, n): if n == 0 return 1 else if n % 2 == 0 tmp = pow(m, n/2) return tmp * tmp else return m * pow(m, n - 1) printBinary example #  My solution in Python def print_binary(n): def _print_binary(n, out): if n == 0: print(out) return elif n % 2 == 0: out = \u0026#34;0\u0026#34; + out else: out = \u0026#34;1\u0026#34; + out _print_binary(n // 2, out) _print_binary(n, \u0026#34;\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: print_binary(42) Output\n101010    isPalindrome exercise #  My solution in Python def isPalindrome(s): if len(s) == 0 or len(s) == 1: return True elif s[0] == s[-1]: return isPalindrome(s[1:-1]) else: return False if __name__ == \u0026#39;__main__\u0026#39;: print(isPalindrome(\u0026#34;madam\u0026#34;)) print(isPalindrome(\u0026#34;racecar\u0026#34;)) print(isPalindrome(\u0026#34;step on no pets\u0026#34;)) print(isPalindrome(\u0026#34;able was I ere I saw elba\u0026#34;)) print(isPalindrome(\u0026#34;Java\u0026#34;)) print(isPalindrome(\u0026#34;rotater\u0026#34;)) print(isPalindrome(\u0026#34;byebye\u0026#34;)) Output\nTrue True True True False False False    Public/private pairs #  "}),a.add({id:240,href:'/notes/CS140/CS140-lecture-20210927/',title:"CS140-lecture-20210927",section:"CS140",content:"Divide and conquer #    \\[\\begin{aligned} T(n) \u0026amp;= 2T \\left( \\frac{n}{2} \\right) \u0026#43; \\Theta (n) \\\\ \u0026amp;= \\Theta(n\\log n) \u0026amp;\\text{divide and conquer}\\\\ T(n) \u0026amp;= T(n-1) \u0026#43; \\Theta(n) \\\\ \u0026amp;= \\Theta(n^2) \u0026amp;\\text{naive approach} \\end{aligned}\\]  A problem divided into any ratio, with the rest of the problem a complement of the original input, the overall complexity will still be  \\( \\Theta(n \\lg n) \\)  .\nMergesort #  Mergesort does not sort in place. During merge, it copies each subarray to a new array, then places them back into the original.\nMerge function #  Analyzing divide and conquer algorithms #  Advantages and disadvantages #  Sorting challenges #  The sorting problem is generally sorting the keys of records.\nWhile some algorithms time complexity, like selection/bubble/insertion, may have a runtime complexity of  \\( O(n^2) \\)  , the actual comparisons and swapping during the algorithm may happen more than that amount. However, since we are just comparing the keys, and not the huge records, we don\u0026rsquo;t have to take this into account.\nThis examples shows us that merely comparing the runtime complexity is not always the best way of comparing algorithms. For example, if we are swapping huge records, then the algorithm with the least amount of swaps will be best (even if it has a worse runtime complexity).\nIn this problem, since the number of elements is huge, we don\u0026rsquo;t want to choose the algorithm that has the last amount of swaps. The actual amount of comparisons will be a better way to choose our algorithm. In this case, we will choose mergesort.\nIf we have an array that is almost sorted, then insertion sort will do the best. Bubble sort will have to still do  \\( n^2 \\)  comparisons, even if only 1 element is out of order (the lowest at the end).\n"}),a.add({id:241,href:'/notes/CS140/CS140-lecture-20210929/',title:"CS140-lecture-20210929",section:"CS140",content:"Quicksort #  The way that the array is divided matters.\nPartitioning the array using Hoare\u0026rsquo;s partition #  i will move toward the right until it reaches a element that is bigger or equal to the pivot point. j will move to the right until it finds a element that is less thatn or equal to the pivot point. i and j will swap as long as the pointers haven\u0026rsquo;t crossed paths.\nWhen i and j cross each other, then the 2 subarrays are partially sorted.\nThe runtime for partition is   \\( \\Theta (n) \\)  .\nQuicksort algorithm #  We don\u0026rsquo;t actually have to explicitly combine the 2 arrays, because they are next to each other and they will be already sorted.\nSo the runtime for quicksort in general is  \\[\\begin{aligned} T(n) \u0026amp;= T(q) \u0026#43; T(n-q) \u0026#43; f(n) \\end{aligned}\\]  where  \\( f(n) \\)  depends on the partition function. However, we can\u0026rsquo;t be fully sure that the time complexity given the input (the value of  \\( q \\)  ). If partition divides the 2 subarrays into size 1 and everything else, then the worst case complexity happens. So, quicksort is really bad at sorting arrays that are already in order (or close to it).\nLomuto\u0026rsquo;s partition method #   The pivot is the last element in the array. i starts pointing to the blank space before the array. j moves to the right until it sees an element that is less than or equal to x. i then moves one to the right, and the pointers swap.  Once j reaches the pivot, the pivot is swapped into the element to the right of i.\nThe good thing about this approach is we don\u0026rsquo;t need to contain the pivot element in the recursive call. So we remove at least 1 from the total size of the sub problems.\nNote: The pivot point is not included in the subarrays.  Randomizing quicksort #  Quicksort performs at its worst when the array is already sorted (or close to it).\nThe pivot element can be chosen randomly, then swapped into either the first or the last element of the array, depending on which partition algorithm we\u0026rsquo;re using.\nExample problems #  This can be solved naievly like so\nfor i from 0 to n-1 for j from 1 to n compare a[i] and a[j] But this results in a  \\( \\Theta(n^2) \\)  time complexity. So the solution is to sort the array first, then we can check adjacent pairs.\n While we could use a binary search on the already sorted subarray, we would need to shift all the elements down to insert the new element into place.\n In this case, where all elements are the same, i and j will instantly stop and swap. So each element will actually have to be swapped. Once the pointers pass each other, then each sub array will also have to \u0026ldquo;sort\u0026rdquo;. So, the overall time complexity when quicksorting an array of identical elements using Hoare\u0026rsquo;s partition is  \\( \\Theta(n \\lg n) \\)  .\nWhen using Lomuto\u0026rsquo;s partition, the element will swap with itself. The index returned will be the last element, and then the subarrays will be of great unequal size. So quicksort using this partition method will give a time complexity of  \\( \\Theta(n^2) \\)  .\n"}),a.add({id:242,href:'/notes/CS140/CS140-lecture-20211006/',title:"CS140-lecture-20211006",section:"CS140",content:"Common divide and conquer problems #  Counting Inversions #  Inversions are the number of out of order pairs in an array of numbers. We can use the amount of inversions as a ranking for multiple arrays.\nIf we consider the first array as sorted (the indices), we can use the second array\u0026rsquo;s indices as a rank to compare.\nWhen we try and count inversions, we are given an array of   \\( n \\)  numbers.\nWe can use divide and conquer to count the number of inversions.\n split the array into 2 subarrays count the inversions in each subarray combine the answer  The problem with the combination step is that we have to count the number of inversions between the 2 subarrays now. So after each subarray is counted, we can loop over the first array and compare to each element of the second array. We can\u0026rsquo;t really do better than this. This means the combination step is  \\( \\Theta(n^2) \\)  .\n \\[\\begin{aligned} T(n) \u0026amp;= 2T \\left( \\frac{n}{2} \\right) \u0026#43; \\Theta(n^2) \\\\ \u0026amp;= \\Theta(n^2) \\end{aligned}\\]  This is no different than just looping over the entire original array and comparing the numbers.\nSo how can we do better? If we are never working with sorted arrays, we cannot do better. However, if we sort the array before we return the subarray result, we can do better.\nWhile we are mering the 2 subarrays, we can count the inversions. If the smaller value is coming from the second subarray, then we have an inversion. If we have  \\( m \\)  items in a subarray, and  \\( i \\)  points to the item in the first subarray, then we have  \\( m-i\u0026#43;1 \\)  inversions for the item in the second subarray.\nClosest pair of points #  If we are working with a 1D array, we can sort them and then loop thru once and find the adjacent pairs.\nWe can divide both the  \\( x \\)  and  \\( y \\)  axis in half:\nNote: Usually if we divide our problem into subproblems of the same size, we get better asymptotic complexity.  So how would we combine the result? Its not easy to do better than  \\( \\Theta(n^2) \\)  time. But, we want to do better.\nWhat if instead we just divide into 2 parts?\nThe problem is since we are comparing each point to each other point, we still end up with  \\( \\Theta(n^2) \\)  . We eliminate points that are bigger than the 2 subarray returns. We can take the min of the 2 subarray returns, and create a boundary on the left and right of the division and check those points only.\nHowever, the problem is we don\u0026rsquo;t know whether or not all points will fall in the center band.\nWe can also enforce the restriction in the  \\( y \\)  direction. So if we sort the numbers on the  \\( y \\)  coordinates, and the index is greater than or equal to the min number, then they will be at least that far away.\nIf 2 points fall inside one grid square, then the distance between them will be less than the min of the subarrays.\nSo we loop for each item 12 times, so we get a complexity of  \\( \\Theta(n) \\)  for combine.\nSo, this results in a  \\( \\Theta(n \\lg n) \\)  runtime complexity. However, this is no better than just sorting by the coordinates in the beginning. So how can we do better?\nWe can put the compute step outside of the recursion. We can also do the  \\( y \\)  coordinate sorting inside the recursion.\nSolving recurrences #  So how can we go from the recurrences to the solutions?\nBinary search recurrences #  If lo \u0026gt; hi or if we find the value we\u0026rsquo;re looking for, the complexity is  \\( \\Theta(1) \\)  . On the recursive call, we have a complexity of  \\[\\begin{aligned} T(n) \u0026amp;= T \\left( \\frac{n}{2} \\right) \u0026#43; \\Theta(1) \u0026#43; \\Theta(1) \u0026#43; \\Theta(1) \\\\ \u0026amp;= T \\left( \\frac{n}{2} \\right) \u0026#43; c \\\\ \u0026amp;= O(\\lg n) \\end{aligned}\\]  Methods for solving recurrences #  Iteration method #  Here  \\( k = \\lg n \\)  . So overall we get  \\[\\begin{aligned} \u0026amp;= c \\lg n \u0026#43; \\Theta(1) \\\\ \u0026amp;= \\Theta( \\lg n) \\end{aligned}\\]  What if  \\( n \\)  is not a power of 2? Asymptotically it will still be a linear complexity.\nSo since we complete  \\( n \\)  steps  \\( k \\)  times, plus  \\( 2^k \\)  constant times. Since  \\( k = \\lg n \\)  the entire thing equals  \\[\\begin{aligned} \u0026amp;= n \\lg n \u0026#43; n \\\\ \u0026amp;= \\Theta(n \\lg n) \\end{aligned}\\]  Substitution method #   Guess a solution Use induction to prove that the solution works   \\[\\begin{aligned} T(n) \u0026amp; = T \\left( \\frac{n}{2} \\right) \u0026#43; c \\leq d \\lg \\left( \\frac{n}{2} \\right) \u0026#43; c \\\\ \u0026amp; = d \\lg n - d \u0026#43; c \\leq d \\lg n \\end{aligned}\\]  If  \\( -d \u0026#43; c \\leq 0, d \\geq c \\)  .\n \\[\\begin{aligned} T(n) \u0026amp; = T(n-1) \u0026#43; n \\leq c(n-1)^2 \u0026#43; n \\\\ \u0026amp; = cn^2 - (2cn - c - n) \\leq cn^2 \\end{aligned}\\]  If  \\( 2cn - c - n \\geq 0 \\)  Changing variables #  Worse case analysis of quicksort #  "}),a.add({id:243,href:'/notes/CS140/CS140-lecture-20211014/',title:"CS140-lecture-20211014",section:"CS140",content:"Recurrences cont #  Recursion tree method #  Another method to solve recurrences is to draw a recursion tree, where each node gets a cost. The cost of each node is the additional work done on each recursive call (not recursive call itself).\nThe leaf nodes are the base cases. The idea is to identify a pattern, and use a known series to evaluate that pattern.\nThen, after identifying the sum of each level of the tree, you then sum all the level\u0026rsquo;s themselves (except the base level, the leaves). Notice that the height of this tree is   \\( \\lg n \\)  . We can sum all the levels up to the last one (notice that  \\( k \\)  goes to  \\( \\lg n \\)  ). Then, add the cost of the last level (there are  \\( 2^{\\lg n} = n \\)  leaf nodes). So we can describe this summation like this:\n \\[\\begin{aligned} \\sum_{k=1}^{\\lg n} \\frac{n^2}{2^k} \u0026#43; n W(1) \u0026amp;= \\frac{\\frac{1}{2}^{(\\lg n - 1) \u0026#43; 1} -1}{\\frac{1}{2} - 1} n^2 \u0026#43; \\Theta(n) \\\\ \u0026amp;= \\left( 2 - \\frac{2}{n} \\right) n^2 \u0026#43; \\Theta(n) \\\\ \u0026amp;= \\Theta(n^2) \\end{aligned}\\]  Its okay to also let  \\( n \\to \\infty \\)  and get an approximation:\nHowever, don\u0026rsquo;t make the approximation too loose.\n \\[\\begin{aligned} \\sum_{k=0}^{\\log_4 n - 1} 3^k c \\left( \\frac{n}{4^k} \\right)^2 \u0026#43; n^{\\log_3 4} T(1) \u0026amp;= cn^2 \\sum_{k=0}^{\\log_4 n - 1} \\left( \\frac{3}{4^2} \\right)^k \u0026#43; \\Theta(n^{\\log_3 4}) \\end{aligned}\\]  This gives an overall complexity of  \\( \\Theta(n^2) \\)  .\nLets solve this same problem using the substitution method.\nOnce this is setup, we can solve for  \\( d \\)  .\nNow, lets try an unbalanced tree:\nWhen we have an unbalanced tree, we need to find the height of the root to leaf nodes that reach the base case the fastest, and the height of the root to leaf nodes that reach the base case the slowest. When we start to sum each level, we can see each level costs  \\( n \\)  , until the tree becomes unbalanced. At this point, the cost is  \\( \\leq n \\)  .\nNote: If we assume the cost at each level is in fact  \\( n \\)  , then we will find an upper bound for the complexity. If we assume that the tree ends at the shortest path from root to leaf, then we will get the lower bound.  If we find the lower bound and upper bound, and they are the same, then we can say we found the exact bound. So, the lower bound is\nNow that we have found a lower bound, lets find the upper bound:\nNote: In the term  \\( n^{\\log_\\frac{3}{2} 2} \\)  , since the base in the log is less than the number, it means that the overall value is  \\( \u0026gt; 1 \\)  , so the polynomial term dominates the linearithmic term.  Since our lower and upper bounds are not equivalent, we cannot say we have an exact bound (big theta).\nWe can get a better assumption but not overestimating as much. If we assume that each level costs the same all the way down, then NOT include the leaf node costs, This would give our upper bound as  \\( O(n \\lg n) \\)  , which matches our lower bound. That means we have an overall complexity of  \\( \\Theta(n \\lg n) \\)  .\nQuicksort recurrence #  Master\u0026rsquo;s method #  Masters method can be used when recurrences are in this exact form:\nGenerally, we\u0026rsquo;ll have 3 cases:\nLets visualize the first case with a recursion tree:\nMergesort recurrence using Master\u0026rsquo;s method #  So first we identify our variables  \\( a,b,f(n) \\)  and go thru the cases.\nThe first case is false because  \\( \\Theta(n) \\not = O(n^{1-\\epsilon}) \\)  . So we check the second case, which is true because  \\( \\Theta(n) = \\Theta(n) \\)  .\nSo the Master\u0026rsquo;s method gives us a runtime complexity of  \\( \\Theta(n \\lg n) \\)  , which is the average case runtime of mergesort.\nSome more recurrence examples using Master\u0026rsquo;s method #  The third case works for this example, and you usually need to find a  \\( \\epsilon \\)  value between 0 and 1.\nIn this example, all 3 cases fail, so another method of solving recurrences it needed besides Master\u0026rsquo;s method.\n"}),a.add({id:244,href:'/notes/CS140/CS140-lecture-20211025/',title:"CS140-lecture-20211025",section:"CS140",content:"Graph basics #  In basic graphs, self loops and multiple edges between vertices are not considered. The number of edges are calculated by\n  \\[\\begin{aligned} |E| = \\binom{n}{2} = \\frac{n(n-1)}{2} = \\Theta(n^2) \\end{aligned}\\]  A directed graph is\n strongly connected if there is a path from any vertex to any other vertex in the direction of edges unilaterally connected if for any 2 vertices there is a directed path to and from each vertices weakly connected if there is a path from any vertex to any other vertex, but not in the direction of edges  Representing graphs #  Adjacency lists #  Note: The total length of linked lists for directed graph is less than the total length of linked lists for the undirected graph in this example.  The degree of a vertex  \\( u \\)  is the number of edges connected to  \\( u \\)  . In a directed graph: the out-degree is the number of edges leaving, and the in-degree is the number of edges arriving.\nAdjacency matrix #  In an undirected graph, the adjacency matrix is symmetric.\nNote: In a spare graph, the adjacency list has much better space complexity.  So, generally:\n if the graph is spares, you want to use an adjacency list if the graph is dense, you want to use an adjacency matrix  Some examples #  for v in vertices walk linked list and keep track of length return length This is has a runtime complexity of  \\( \\Theta(V\u0026#43;E) \\)  .\n For example the in_degree(4) is 3, because it appears in the adjacency list of 3 other vertices. To calculate a single in-degree of a vertice we could do something like\nin_degree(n): for v in vertices except n walk linked list if n appears in list, degree++ return degree++ However, if we want the in degree of all vertices, this will have a really bad runtime complexity:  \\( \\Theta(V(V\u0026#43;E)) \\)  .\nSo, it is better to calculate all of them at once.\nin_degree(list): n = length of list in_degree_array[n] initialized to 0s for v in vertices: for node in linked list: in_degree_array[node]++ return in_degree_array This returns an array of values corresponding to the in degree of each vertex. So, since we only have to loop over the entire adjacency list once, we have a runtime complexity of  \\( \\Theta(V \u0026#43; E) \\)  .\n For an adjacency list #  We can traverse the entire array of linked lists, and when we see a node in an adjacency list for vertex  \\( u \\)  , we can add  \\( u \\)  to the adjacency list for that node in the transposed graph.\nThis results in a time complexity of  \\( \\Theta(V\u0026#43;E) \\)  .\nFor an adjacency matrix #  While this looks like any 0 is simply flipped to a 1, it is actually not. It is actually a mirror across the diagonal line.\nThis gives a runtime complexity of  \\( \\Theta(V^2) \\)  .\nUniversal sink problem #  First lets answer some questions to help in the design of this algorithm:\n How many sinks could a graph have?  either 0 or 1   How can we determine whether a given vertex  \\( u \\)  is a universal sink?  the row must contains all 0s the column must contain all 1, except on the main diagonal   How long would it take to determine whether a given vertex  \\( u \\)  is a universal sink?   \\( O(n) \\)  , we check 1 row and 2 column, so  \\( 2n \\)  checks.    This will be  \\( O(v^2) \\)  complexity. So how can we make it better?\nWe can start at the top left of the matrix, and go to the right until we see a 1. If we see a 1, that means that the first row cannot be a universal sink, but that column with a 1 could be. So at this point we start checking down the column and make sure we keep seeing 1s. If we reach a 0 then we move to the right.\nWhen we reach  \\( v_5 \\)  , it shows that it may potentially be a universal sink.\nIf at any point we leave the bounds of the matrix, the vertices before that point cannot be universal sinks. Greedy algorithms #  Here, in a greedy algorithm, we choose  \\( w\u0026#39; \\)  as the first vertex in our shortest path, because it is locally optimal.\nProblems solvable via a greedy alrogithm\n exhibit optimal substructure, meaning that a substructure of a structure is also optimal (a segment of the shortest path is optimal for that segment). exhibit the greedy choice property, that is a globally optimal solution can be arrived at by making a locally optimal (greedy) choice.  Activity selection problem #  Note: This is the same as CPU scheduling.  First, lets look at the recursive solution:\nFor the greedy algorithm, we need to define what the greedy choice is. For example, if we say that the greedy choice is the next activity to start (the shortest time between now and activity start), then it may look like this:\nAs you can see, this choice does not return the maximium number of activities we can select. So what if our greedy choice is minimum duration?\nAs you can see with this counter example, that doesn\u0026rsquo;t always work either.\nSo, what if our greedy choice is to select by fastest finishing time?\nThis looks like it will work. Lets show the greedy choice property:\nWhen an activity is selected, it is selected because it finished faster than the other activities to select from. So, from this time on it will definitely be included in the optimal solution because of this property.\nThe knapsack problem #  Note: The 0-1 knapsack problem can be solved by dynamic programming.  "}),a.add({id:245,href:'/notes/CS140/CS140-lecture-20211027/',title:"CS140-lecture-20211027",section:"CS140",content:"Variable length encoding #  If we want to compress a file, we need to represent each symbol with a string of binary digits. If our strings are variable length, then that means the representation for any symbol should not be the prefix of the representation of another symbol.\nHuffman codes #  The value at each node is the frequency of symbols in the subtree. The leaves represent symbols, and each left or right child represents a 0 or 1. So, if we walk directly to a leaf, the values on each link represent the encoded symbol.\nSo, the above tree shows that e is represented as 1101.\nSo how can we optimize this tree using a greedy algorithm? First off, we want the lowest frequency symbols to as low as possible in the tree (lowest frequency items have longer encodings).\n    \\( n \\)  is the number of symbols creates a heap with frequencies each iteration extracts 2 nodes from heap, and inserts a new node that has the sum of frequencies  So how do we prove that this is the optimal binary tree? We need to prove\n the greedy choice property the optimal substructure property  At each point, we are always choosing the 2 lowest frequency symbols.\nIf during each swap, the subtree frequency does not change, then each tree is optimal.\nThe reason that it is  \\( \\geq 0 \\)  is because it will have either lower or the same frequency.\nBased on our assumption, we think that  \\( T\u0026#39; \\)  is optimal, whereas  \\( T\u0026#39;\u0026#39;\u0026#39; \\)  may not be optimal. That is why the cost of  \\( T\u0026#39;\u0026#39; \\)  is  \\( \\geq \\)  to  \\( C(T) \\)  .\nMinimum spanning trees #  Finding a minimum spanning tree in a graph is also a greedy algorithm.\n spanning means it covers every node in the graph tree means there is no cycles minimum means that the total cost of the tree is the lowest possible   \u0026ldquo;safe\u0026rdquo; means that when adding an edge to  \\( A \\)  , it is still a subset of the MST  So how do we find the safe edge? That leads to different algorithms.\n an edge that \u0026ldquo;crosses the cut\u0026rdquo;, means it has 1 endpoint in the first set, and 1 endpoint in the other.   there should be at least 1 edge that crosse the cut, for example  \\( (x,y) \\)  . if we remove that edge, and instead add the light edge  \\( (u,v) \\)  , that means that it is the smallest edge that crosses the cut this leaves us with another tree, with a total weight that is the same minus  \\( w(x,y) \u0026#43; w(u,v) \\)     \u0026ldquo;CC\u0026rdquo; = connected component  MST algorithms #   the algorithm starts by assuming all nodes in the graph are individual connected components (nothing is connected to each other, no nodes in the MST yet)    \\( \\pi[r] \\)  represents the \u0026ldquo;parent of node  \\( r \\)  \u0026rdquo; extract-min in a binary heap has a runtime of  \\( O(\\lg n) \\)   decrease-key operation has a complexity of  \\( O(\\lg V) \\)   the amount of edges in a connected graph is  \\( E = V-1 \\)  , or  \\( \\Omega(V) \\)   overall runtime complexity of Prim\u0026rsquo;s is  \\( O(E \\lg V) \\)    Example of Prim\u0026rsquo;s #  Note: This is not a directed graph, the arrows just show what nodes are directly being updated when a new node is added.  Example of Kruskal\u0026rsquo;s #  In comparison, Kruskal\u0026rsquo;s starts with all nodes being their own connected components. It chooses the minimum edge between any 2 connected components:\nNote: Disregard the  \\( \\infty \\)  signs in each node here, we're just reusing the graph from the Prim's example to show Kruskal's.  "}),a.add({id:246,href:'/notes/CS140/CS140-lecture-20211101/',title:"CS140-lecture-20211101",section:"CS140",content:"Dynamic programming #  Dynamic programming is an algorithm design technique. In dynamic programming, you solve the problem bottom-up (as opposed to top-down in divide and conquer).\nAnother trait of dynamic programming is that when a sub problem is solved, it is only solved once (which may not be the case in divide and conquer).\n Notice that multiple sub problems are solved multipled times  Assembly line scheduling problem #      \\( e_n \\)  is the arrival time in assembly line  \\( n \\)    \\( a_{i,j} \\)  is the time it takes at station  \\( j \\)  in assembly line  \\( i \\)    \\( t_{i,j} \\)  is the transfer time  \\( x_n \\)  is the exit times for assembly line  \\( n \\)     the idea is that  \\( a_{1,j} \\)  has the optimal subproblem solution to  \\( a_{1,j-1} \\)  and the optimal subproblem solution to  \\( a_{2,j-1} \\)  in it  So in general\n \\[\\begin{aligned} f_1[j] \u0026amp;= \\text{min}(f_1[j-1] \u0026#43; a_{1,j}, f_2[j-1] \u0026#43; t_{2,j-1} \u0026#43; a_{1, j}) \\end{aligned}\\]  We want to solve this bottom up, which means we\u0026rsquo;ll start with the base cases.\nNote:  \\( 18^{[1]} \\)  indicates that the total time to exit the station is 18, coming from assembly 1.   each cell is the solution to some sub problems   you need an array big enough to fit the solution to each sub problem   time complexity here is  \\( \\Theta(n) \\)  .  line 1 station 5 line 1 station 4 line 1 station 3 line 2 station 2 line 1 station 1 "}),a.add({id:247,href:'/notes/CS140/CS140-lecture-20211108/',title:"CS140-lecture-20211108",section:"CS140",content:"Matrix-chain multiplication #   total time complexity of   \\( \\Theta(mnp) \\)    Optimal parenthesization #   this results in exponential complexity  So let\u0026rsquo;s use dynamic programming:\n make sure to start with the base case, when i = j, the main diagonal of the array   then, we can start to fill in the spaces to the top right of each base case. note that the bottom left diagonal of the array will not be used, because i \u0026gt; j   start with the base cases loop over rows and columns solve sub problems in each level  So how do we find the optimal solution once we\u0026rsquo;ve filled in the entire matrix? We can store the  \\( k \\)  value that gives the min value (this is the last line of the pseudo above).\nMy solution in Python  Output\n 0 50000 7500 -1 0 5000 -1 -1 0 -1 0 0 -1 -1 1 -1 -1 -1 ( A0 ( A1 A2 )) 7500 multiplications needed 0 6000 25000 90000 86000 86000 99200 -1 0 10000 60000 80000 82400 87200 -1 -1 0 100000 120000 96000 105600 -1 -1 -1 0 100000 84000 108000 -1 -1 -1 -1 0 24000 72000 -1 -1 -1 -1 -1 0 9600 -1 -1 -1 -1 -1 -1 0 -1 0 0 0 0 0 0 -1 -1 1 2 3 4 5 -1 -1 -1 2 2 2 5 -1 -1 -1 -1 3 3 5 -1 -1 -1 -1 -1 4 5 -1 -1 -1 -1 -1 -1 5 -1 -1 -1 -1 -1 -1 -1 ( A0 ((((( A1 A2 ) A3 ) A4 ) A5 ) A6 )) 99200 multiplications needed    "}),a.add({id:248,href:'/notes/CS140/CS140-lecture-20211110/',title:"CS140-lecture-20211110",section:"CS140",content:"Memoization #  Elements of dynamic programming #  Longest common subsequence #   base cases along left and top edge   see which subproblems are needed to solve current sub problem   our next level after base cases is the top left corner   nested loops   another order to solve   can also go by columns   overall runtime is   \\( \\Theta(n) \\)  where  \\( n = i \u0026#43; j \\)  , the sum of the 2 sequences  My solution in Python  Output\n 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 1 1 2 2 0 1 1 2 2 2 2 0 1 1 2 2 3 3 0 1 2 2 2 3 3 0 1 2 2 3 3 4 0 1 2 2 3 4 4 b c b a    Improving the space complexity #   we can overwrite the first 2 rows each pass thru  "}),a.add({id:249,href:'/notes/CS140/CS140-lecture-20211117/',title:"CS140-lecture-20211117",section:"CS140",content:"Some more dynamic programming examples #  Segmented least squares #   if we connected all points between each other, there would be zero error we want a trade off between accuracy and number of segments   imagine connecting the last 2 points, and then attaching it to the rest of the optimal solution or connecting the last 3 points and attaching it to the rest of the optimal solutions and so on\u0026hellip;  Weighted activity selection #      \\( O(n \\lg n) \\)  complexity (sort)  The knapsack problem revisited #  Automated memoization #  Flow network #   notation is \u0026ldquo;capacity / flow\u0026rdquo;  Max flow #  Ford-Fulkerson method #   can increase flow by 5   lower path is not an augmenting edge, flow cannot increase   there is no augmenting path left (can\u0026rsquo;t find path from source to sink), so the max flow of the previous graph is the answer   the max flow of the network will be less than or equal to a cut   the max flow is the min cut  Edmonds-Karp algorithm #  Multiple sources or sinks #  Bipartite matching #  "}),a.add({id:250,href:'/notes/CS140/CS140-lecture-20211129/',title:"CS140-lecture-20211129",section:"CS140",content:"NP-completeness #  Hamiltonian cycles #  An example of a problem that cannot be solved in polynomial time.\nP and NP #  Terminology #  Reduction #   should first show that   \\( P \\in NP \\)    NP-Hard #   NP-Hard problems are at least as hard as NP-Complete problems  Why prove NP-completeness? #  NP-Complete Examples #  Reduction examples #  Directed hamiltonian cycle to undirected hamiltonian cycle #  It is easier to go the other way (for any undirected edge, we just make it directed in both directions).\nSo how do we turn a directed graph into an undirected graph, such that they both either have or have not a hamiltonian cycle?\nFor each vertex in the directed graph, put 3 vertices in the undirected graph:\nThen, for edges in the directed graph, put an edge from the third vertex to the first in the undirected graph:\nNow, this particular example does not have a hamiltonian cycle, but lets pretend it does (with the darker color):\nNote that the undirected graph now has the entire perimeter filled in and we can see the hamiltonian cycle.\nThe (bold) edges that go from a third vertice to a first vertice represent a hamiltonian cycle in the directed graph.\nThe traveling salesman problem #  If we are trying to show that this problem is NP-Complete we need to:\n show that the solution is verifiable in polynomial time  with the TSP solution, we can simply sum all of the edges    We can reduce the Hamiltonian cycle problem to a TSP:\nIf we reduce all edge weights to 1, and the TSP gives a result  \\( \u0026lt; n \u0026#43; 1 \\)  , then we have a hamiltonian cycle.\n"}),a.add({id:251,href:'/notes/CS140/CS140-lecture-20211207/',title:"CS140-lecture-20211207",section:"CS140",content:'More reduction examples #  The SAT problem #  One of the first problems to be proved NP-Complete.\nBoth parts highlighted in red must be true. It is easy to make the right side false by setting   \\( x_2 \\)  to false.\nNote that the red circled part cannot be true, and since it is being OR\u0026rsquo;d we need to make sure that the left side is true.\nSo, it is satisfiable.\n \\( \\to \\)  means "if"  \\( \\leftrightarrow \\)  means \u0026ldquo;if and only if\u0026rdquo;\n Conjunctive normal form #   if each clause has 3 literals, we call it 3CNF similarly for 4  Consider a 1CNF:\n \\[\\begin{aligned} x_1 \\wedge x_2 \\wedge \\bar{x_1} \\end{aligned}\\]  We can find out if this is satisfiable or not by trying to make each clause true. Note that  \\( x_1 \\)  creates a contradiction. So, 1CNF expressions are not NP-Complete. Similarly for 2CNF.\n while we don\u0026rsquo;t show the proof here, we can now use the fact that 3CNF is NP-Complete to prove other problems are NP-Complete (by reducing 3CNF to the other problems).  The clique problem #  Lets reduce this instance of a 3CNF problem to an instance of a  \\( k \\)  -clique problem:\nWe can split each clause up into a group of 3 vertices. Connect vertices if they are the same boolean value in all clauses.\nSo how do we prove that this is a valid reduction?\n the creation of this graph was done in polynomial time we need to prove that the answer to the 2 problems are the same  if the 3CNF is satisfiable, then at least 1 literal from the clauses is true, which means we would have a  \\( k \\)  -clique in the graph if we have a  \\( k \\)  -clique in the graph, then the 3 vertices of the clique will be from 3 different clauses, and therefore the 3CNF will be satisfiable    Reducing the clique problem to the vertex cover problem #  Each edge has an endpoint in one of the 3 circled green vertices.\nWe can check if it has a 1 vertex cover, if no then we can increase the question. If the graph has 2 vertex cover, then the minimum number is 2 for vertex cover. At most, we can have  \\( n \\)  vertex cover.\nSo how can we reduce the clique problem to the vertex cover problem?\n the complement of a clique has no edges so, any other edge in the graph can be covered by the other vertices not among the clique (there are  \\( n - k \\)  of them).  General reduction comments #  '}),a.add({id:252,href:'/notes/CS152/CS152-lecture-20210601/',title:"CS152-lecture-20210601",section:"CS152",content:"Course orientation #  Syllabus #  152-syllabus.pdf  Notes during orientation #   Programming will be required in each module, programming intensive Brush up on probability of simple events, simple conditional events Shallow introduction into groups and fields Class is only 5 weeks and 2 days long, so extremely accelerated, at least 20 hrs/week needed Hybrid class, half videos posted, and half live. Class will start at 1, and go until lecture finishes, then unrecorded open office hour 5 modules, starts on thursdays  Permutation functions and C programming Symmetric encryption Hashing and authentication Asymmetric cryptography and algorithms on large number Crytographic systems   Exams on week 3 and 5 Group quizzes on tuesdays, in breakout rooms on Zoom Last day is comprehensive final Take all assignments seriously, nothing is dropped  Brief introduction to cryptography #   Communication in the presence of adversaries\nRon Rivest\n If Alice and Bob want to communicate, the have some kind of medium (like a network connection, or any for of communication).\nIn the midst of the communication medium, there is Eve, the adversary. Eve can passively attack: reading all the messages that go back and forth. Our adversary can also do active attacks: modifying the messages, inserting messages, or delete messages.\nSo we must imagine that our adversary is very powerful. If you can secure your communications in the presence of a powerful adversary, then they will also be secure for the weaker.\nEve also has Kerckhoff\u0026rsquo;s law: the adversary knows everything except secret keys. We must assume Eve knows the algorithms being used in the cryptographic process.\nNote: Keys in cryptography refers to a random string of bits.  Two kinds of cryptography #  Symmetric:\n Alice and Bob share the same secret key Much faster (thousands of times faster)   Asymmetric:\n Alice and Bob each have their own secret key Scales better, easier to manage keys among large groups. Linear as opposed to symmetric\u0026rsquo;s exponential key count. More flexible, no trust needed to establish secure connection.    What happens in the real world: hybrid cryptography #  This is a combination of symmetric and asymmetric cryptography.\n Use asymmetric cryptography to start the communication Establish a shared secret Switch to symmetric for the rest of the communication  Two main goals #  Secrecy\n Adversary should not extract any information Verb used: encrypt/decrypt   Authentication\n Receiver is able to verify the data is unaltered and from the sender Verb used: authenticate, sometimes called MACing (message authentication code) In asymmetric: signature In symmetric: MAC    Review of older topics #  Functions and permutations #  Cryptography is largely based on invertible functions. We also need to understand some probability distributions used in cryptography.\nFor example:\n\u0026ldquo;Let   \\( f:Z_5 \\to Z_4 \\)  be a function \u0026hellip;\u0026rdquo;\nHere\n  \\( f \\)  is the name of the function  \\( Z_5 \\)  is the domain  \\( Z_4 \\)  is the codomain The fact that its a function means that every domain element is mapped to 1 codomain element.  Note: We will define \\( Z_n = \\{0,1,2,\\ldots,n-1\\} \\)  We will only consider discrete functions in this class.\nTwo ways to think of a discrete function #  Consider the function  \\( f: Z_5 \\to Z_4 \\)  Arrow diagrams  Every domain element has exactly 1 arrow to the codomain. A function is onto if each codomain element has at least 1 arrow to it. A function is 1-to-1 if each codomain element maps has less than or equal to 1 arrow to it. The inverse of the function is if you reverse the arrows. Only functions that are onto and 1-to-1 are invertible. If we reverse the arrows of the above function, we can tell the inverse is not a function (multiple arrows coming out of one element).   Tables\n   \\( x \\) \\( f(x) \\)     0 1   1 0   2 2   3 3   4 3    If this is a function:\n Each domain element appears exactly once in the first column and each element in the second column is in codomain For a function to be onto: each codomain element appears in the second column For a function to be 1-to-1: no repeats in the second column Invertible if both of the above are true: each codomain elements appears exactly once in the second column, we can see the function is not invertible because 3 appears twice in the second column    Definition: a function is invertible if and only if it is 1-to-1 and onto.  A invertible function\u0026rsquo;s domain and codomain will be sets of the same size.\nRandom functions #  A random function is one where each element of the codomain (second column) is chosen uniformly at random.\nSo if we say \u0026ldquo;let  \\( f: Z_5 \\to Z_4 \\)  be random \u0026hellip;\u0026rdquo;, imagine that we have a table defining  \\( f \\)  where the second column is randomly picked using a random probability (like a coin flip).\n    \\( x \\)    \\( f(x) \\)       0 3   1 3   2 2   3 2   4 3    Random functions are defined randomly, but are then fixed. So multiple calls to  \\( f(0) \\)  will always return  \\( 3 \\)  .\nSometimes its useful to be lazy when defining a random function, that is to generate the output only on the first call to the input.\nExamples #  What is the probability that  \\( \\left[ f(1) = 2 \\mid f(0) = 2 \\right] \\)  ?\nIf we are filling the table lazily, the probability is  \\( \\frac{1}{4} \\)  because the output has not been defined yet.\nWhat is the probabilty that  \\( \\left[ f(1) = 2 \\mid f(1) = 1 \\right] \\)  ?\nThis is  \\( 0 \\)  , because the output has already been defined.\nPermutations #  File: Permutations functions  A permutation function is an invertible function where the domain = codomain.  For example we might say \u0026ldquo;let  \\( p: Z_4 \\to Z_4 \\)  be a random permutation function \u0026hellip;\u0026rdquo;\n    \\( x \\)    \\( p(x) \\)       0 1   1 3   2 0   3 2    Note: the second column above cannot have any repeats because it is invertible.  The first output generated is uniformly distributed (because nothing is in the table at the beginning).\nProbability #  Let  \\( p: Z_4 \\to Z_4 \\)  be a random permutation function. We will use a lazy output table generation:\nWhat is  \\( P(p(1) = 2 \\mid p(0) = 1) \\)  ?\nAnswer:  \\( \\frac{1}{3} \\)  What is  \\( P(p(1) = 1 \\mid p(0) = 1) \\)  ?\nAnswer:  \\( 0 \\)  C memory models #  A allocated chunk of memory can be represented by a long rectangle, which could be filled by a network or a file read etc:\nLeft end is the address of the first byte (pointer). The span of the rectangle is the amount of memory allocated (the length).\nCryptographic functions will be given a buffer like this, and will manipulate the data in the buffer.\nA C programming interface #  Lets say we have\nvoid foo(void * p, int nbytes) We use a void pointer void * to avoid type warnings. It is a memory address with no associated type.\nAnother interface may be:\n#include \u0026lt;stdint.h\u0026gt;void foo(uint8_t * p, int nbytes); uintN_t, where N is either 8, 16, 32, or 64, each being N bits, can be used to specify the size needed. uint8_t is the exact same as char, both being the smallest addressable unit (1 byte).\nAccessing memory in C #  We can access memory randomly via array subscript notation:\n p[i] being the ith element. We cannot do this on a void *, because it doesn\u0026rsquo;t know the size of each element. p + i is the address of p[i] element, this is pointer arithmetic.  XOR buffer example #  Lets write a function that takes a buffer as input, and returns the XOR of all the bytes.\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt; uint8_t xor_buf(uint8_t * p, int nbytes) { uint8_t acc = 0; for (int i = 0; i \u0026lt; nbytes; i++) acc = acc ^ p[i]; return acc; } int main() { uint8_t buf[4] = {1, 2, 3, 4}; // at this point memory looks like this in hex:  // 01 02 03 04  uint8_t result = xor_buf(buf, 4); printf(\u0026#34;%x\\n\u0026#34;, result); return 0; } When we run this we get the output:\n4 which is the expected output.\n"}),a.add({id:253,href:'/notes/CS152/CS152-lecture-20210603/',title:"CS152-lecture-20210603",section:"CS152",content:'Data programming #  File: Topics in C programming useful for cryptography  Count the number of even chars #  in C #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdint.h\u0026gt; int num_even(void * p, int nbytes) { uint32_t * p32 = (uint32_t *) p; int nitems = nbytes / 4; int acc = 0; for (int i = 0; i \u0026lt; nitems; i++) if (p32[i] % 2 == 0) acc = acc + 1; return acc; } int main() { uint8_t buf[] = {0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00}; printf(\u0026#34;%d\\n\u0026#34;, num_even(buf, 8)); return 0; } Depending on the endian, the output is either 0 or 2.\nWe can not depend on the endianness of the CPU by using a helper function to load in the bytes little endian always:\nuint32_t load_uint32_little(void * p) { uint8_t * p8 = (uint8_t *) p; // extract bytes  uint32_t a = p8[0]; uint32_t b = p8[1]; uint32_t c = p8[2]; uint32_t d = p8[3]; // reassmble  return (d \u0026lt;\u0026lt; 24) | (c \u0026lt;\u0026lt; 16) | (b \u0026lt;\u0026lt; 8) | a; } Good compilers will optimize this on an x86 machine to\n_load_uint32_little: movl (%rdi), %eax ret So we can polish our num_even function to handle the different endianness of CPUs:\nint num_even(void * p, int nbytes) { uint32_t * p32 = (uint32_t *) p; int nitems = nbytes / 4; int acc = 0; for (int i = 0; i \u0026lt; nitems; i++) { uint32_t tmp = load_uint32_little(p32 + i); if (tmp % 2 == 0) acc = acc + 1; } return acc; } and now we get 0 for output both times.\nin Java #  public class Lect2 { static int load_uint32_little(byte[] p, int offset) { // extract bytes  int a = p[0 + offset]; int b = p[1 + offset]; int c = p[2 + offset]; int d = p[3 + offset]; // reassmble  return (d \u0026lt;\u0026lt; 24) | (c \u0026lt;\u0026lt; 16) | (b \u0026lt;\u0026lt; 8) | a; } static int num_even(byte[] p) { int nitems = p.length / 4; int acc = 0; for (int i = 0; i \u0026lt; nitems; i++) { int tmp = load_uint32_little(p, i * 4); if (tmp % 2 == 0) acc = acc + 1; } return acc; } public static void main(String[] args) { byte[] buf = {-1, 0x00, -1, 0x00, -1, 0x00, -1, 0x00}; System.out.printf(\u0026#34;%d\\n\u0026#34;, num_even(buf)); } } This can be done in a much nicer way using Java\u0026rsquo;s library, replacing the load_uint32_little method. We can do this using ByteBuffer.\nimport java.nio.*; // for ByteBuffer // no longer need the load_uint32_little method static int num_even(byte[] p) { ByteBuffer bb = ByteBuffer.wrap(p); bb.order(ByteOrder.LITTLE_ENDIAN); IntBuffer ib = bb.asIntBuffer(); int nitems = p.length / 4; int acc = 0; for (int i = 0; i \u0026lt; nitems; i++) { int tmp = ib.get(i); if (tmp % 2 == 0) acc = acc + 1; } return acc; } Note: We need to change the endianness of ByteBuffer because in Java it defaults to big.  Big vs little endian #  If we\u0026rsquo;re loading\nFF 00 FF 00 FF 00 FF 00 from memory, the byte are transferred from memory to a register.\nIf our register is 32 bits long, and we read using a big endian computer, our register will look like:\nFF 00 FF 00 FF 00 FF 00 The bytes are read in from the big side first.\nOn a little endian computer, our register will look like this:\n00 FF 00 FF 00 FF 00 FF The bytes are read in from the little side first.\nRotation #  A lot of cryptography is built upon three operations:\n add xor rotate.  As long as you alternate between these 3 instructions, they will never compose. So they turn out to be a common building block for writing cryptographic functions.\nEach of these 3 instructions has a single assembly instruction. Both add and xor are operators in C, but for rotate we have to write our own function. The compiler will recognize the rotate function and turn it into the assembly instruction.\nLets say we want to rotate this register to the left 4\nbefore 1111 0000 1100 0011 rotl 4 0000 1100 0011 1111 We can piece this operation together using bitwise operations\nrotl(x, n): return (x \u0026lt;\u0026lt; n) | (x \u0026gt;\u0026gt; (16 - n)) Data flow #  If we have an input to a Feistal function, it will be split in half and processed to an output.\nIf we have a 16 bit register, it is cut into two 8 byte pieces,   \\( a \\)  and  \\( b \\)   mermaid.initialize({ "flowchart": { "useMaxWidth":true }, "theme": "default" } ) sequenceDiagram participant a participant b b-a: f Note left of a: a\' = f(b) XOR a a-b: g Note right of b: b\' = g(a\') XOR b So the function  \\( f \\)  and  \\( g \\)  go from 8 bytes to 8 bytes.\nSo if we know  \\( a \\)  and  \\( b \\)  :\n \\( a\u0026#39; = f(b) \\oplus a \\\\ b\u0026#39; = g(a\u0026#39;) \\oplus b\\)  We can also figure out the inverses\n \\( b = g(a\u0026#39;) \\oplus b\u0026#39; \\\\ a = f(b) \\oplus a\u0026#39;\\)  SipHash diagram #  This is the flow diagram for SipHash.\n \\( v_0, v_1, v_2, v_3 \\)  are each 64 bits each.\nTo turn this into code, note all the areas where operations have known operators.\nSo the areas with check marks are known operations.\nOn the notation:\n  \\( \u0026lt;\u0026lt;\u0026lt; \\)  is rotate  \\( \\oplus \\)  is xor  \\( \\boxplus \\)  is add  So follow the flow of the diagram from left to right and whenever there is data ready to go, that can be implemented as a line of code. You have to find the combination of instructions to perform to get through the diagram.\nLooking at this diagram, can we tell of this is an invertible function?\nWe could work from the output side towards the input side to see if its invertible (reverse the arrows).\n'}),a.add({id:254,href:'/notes/CS152/CS152-lecture-20210604/',title:"CS152-lecture-20210604",section:"CS152",content:"Bitwise manipulations #  File: Slides  Data is a sequence of bytes in memory, whether we receive it from a file or network. We will use unsigned int types to avoid sign extension. These manipulations are powerful in cryptography.\nWe can also move the bits back and forth using left/right shifts. Bits that shift off the end are gone for good, and 0s are added on the opposite end (in unsigned types).\nCommon uses #  Correction: we are clearing bit position 7 in the above slide.\nx = x \u0026amp; ~(1 \u0026lt;\u0026lt; 7);   Correction: above slide should shift right 7.\nx = 1 \u0026amp; (x \u0026gt;\u0026gt; 7);   Rotations are very common in encryption.\nHere, (x \u0026amp; 0x000000FF) is called a mask. It masks everything except the last 8 bits.\nOn Intel CPUs, the return value is left in %eax.\nArray allocation #  File: Slides  Auto allocated memory only exists in scope, you can\u0026rsquo;t have long lived memory this way.\nRemember, malloc takes the number of bytes you want, not the number of elements. If malloc is unsuccessful, it will return 0 (NULL).\nReverse array example #  This could crash if you have less than 400B on the stack available.\nThis uses   \\( O(n) \\)  space complexity.\nObtaining memory addresses #  Inverse techniques in C #  AXR – add, XOR, rotate #  We can write an invertible functions using these 3 operations.\n add xor rotation  Consider something like\nx = x + y; This can be \u0026ldquo;undone\u0026rdquo; via\nx = x - y; These work with the other operations, i.e.\nx = x ^ y; x = x ^ y; // xor is its own inverse Note: XOR is associative:\n(x ^ y) ^ y = x ^ (y ^ y)   Rotation (we\u0026rsquo;ll use \u0026lt;\u0026lt;\u0026lt; to indicate left rotate):\nx = x \u0026lt;\u0026lt;\u0026lt; y; x = x \u0026gt;\u0026gt;\u0026gt; y; // or x = x \u0026lt;\u0026lt;\u0026lt; (32 - y) Note: You can either rotate back, or continue to rotate the entire width. Here we are assuming that x is a 32 bit value  We can compose these 3 operators to scramble bits (and is invertible):\nuint32_t scramble(uint32_t x) { x = x ^ 0x1AFE9B3A; // xor by random constant  x = x \u0026lt;\u0026lt; 12; x = x + 0x2783AFBC; // add random constant  return x; } We could easily write the invertible function to undo these operations:\nuint32_t unscramble(uint32_t x) { x = x - 0x2783AFBC; // sub random constant  x = x \u0026gt;\u0026gt; 12; x = x ^ 0x1AFE9B3A; // xor by random constant  return x; } The operations just have to happen in the opposite order of scramble.\nFeistel #  Another way to write an invertible function in C is to use a Feistel construction. The idea is that the construction itself is invertible, and not the components.\nWe can take an input and break it into 2 pieces, and use one half to cause a scrambling of the other half.\nAn abstract example in C, (here f doesn\u0026rsquo;t exist).\n// x points to an array of two uint32_t void fscramble(uint32_t * x) { x[0] = x[0] ^ f(x[1]) // f returns random looking uint32_t  x[1] = x[1] ^ f(x[0]) // f returns random looking uint32_t } Note: Here, f is some kind of scrambling function.  To undo these operations, we just need to do the original operations in reverse order:\n// x points to an array of two uint32_t void funscramble(uint32_t * x) { x[1] = x[1] ^ f(x[0]) // f returns random looking uint32_t  x[0] = x[0] ^ f(x[1]) // f returns random looking uint32_t } What is interesting about these Feistel structures, is that f itself does NOT need to be invertible.\nA concrete example:\n// x points to an array of two uint32_t void fscramble(uint32_t * x) { x[0] = x[0] ^ (x[1] * x[1] + x[1]) // square and add  x[1] = x[1] ^ (x[0] * x[0] + x[0]) // square and add } // x points to an array of two uint32_t void funscramble(uint32_t * x) { x[1] = x[1] ^ (x[0] * x[0] + x[0]) // square and add  x[0] = x[0] ^ (x[1] * x[1] + x[1]) // square and add } Composing simple ciphers #  We will make a simple function that is invertible, but simple to create. Historically, cryptography uses permutations the most for ciphers.\nCaesar cipher #  One of the oldest uses of cryptography was used in Roman times, the Caesar cipher. They selected a number to be used as a fixed key. So long as the key wasn\u0026rsquo;t leaked, it provided adequate privacy.\nIt is a simple shift of the alphabet, so  \\( A \\to D, B \\to E \\)  , etc. At the end you wrap around,  \\( Z \\to C \\)  .\nSo if we are encrypting the word BAD, and are shifting by 3:\nB A D E D G add 3 B A D sub 3 to get original This is known as a shift cipher.\nshift(x): ciphertext = x + 3 mod 26 We can make this more flexible and more secure by using the key and the character:\nshift(x, k): ciphertext = x + k mod 26 So we can get the plaintext by doing the opposite:\nplaintext = y - k mod 26 // or = y + (26 - k) mod 26 This is working in the field  \\( Z_{26} \\)  , meaning we use mod 26.\nThe goal of this is to have the ciphertext and the function to look very random.\nSo if we encrypt using a key of k, and are in the field  \\( Z_5 \\)  .\nk = 3 encrypt(k, x) = x + k mod 5 This is a permutation function, and all it does is add 3 to each of its inputs.\nThis doesn\u0026rsquo;t \u0026ldquo;look random\u0026rdquo;, as it seems that all of the arrows are parallel. However, it is secure as long as k is picked at random, and we only encrypt a single x. Each of the outputs are equally likely, therefore the ciphertext is secure.\nNormally however, we don\u0026rsquo;t usually encrypt a single character. We want our permutation that we are going to use to be more random so we can encrypt more than 1 char at a time.\nMultiplicative cipher #  Here instead of using addition (like the shift cipher), we will use multiplication.\nSo if we are in  \\( Z_{26} \\)  .\n \\[\\begin{aligned} e(k,x) \u0026amp;= xk \\mod 26 \\\\ d(k,y) \u0026amp;= y k^{-1} \\mod 26 \\end{aligned}\\]  This only works if the multiplicative inverse  \\( k^{-1} \\)  exists in  \\( Z_{26} \\)  . The inverse of  \\( k \\)  has to be an element in  \\( Z_{26} \\)  , normally people think of fractions as inverses.\nNote that not all values in  \\( Z_{26} \\)  have an inverse.\n \\( k^{-1} \\)  exists iff  \\( gcd(k,26) = 1 \\)  .\nIf  \\( k \\)  and  \\( 26 \\)  share no factors, then it has a multiplicative inverse.\nThe easiest way to find candidates for  \\( k \\)  is:\n Go through all of the numbers in  \\( Z_{26} \\)  and throw out the prime factors that have 26.  So 26 has two prime factors:  \\( 26 = 2 * 13 \\)  .\nSo we throw out all the ones that have a multiple of 2 or 13, whats left is the numbers that have a multiplicative inverse, i.e.\n \\[ k = 1,3,5,7,9,11,15,17,19,21 \\]  So lets see how random the multiplicative cipher looks compared to the shift cipher:\nIf  \\( k = 3 \\)  and  \\( Z_5 \\to Z_5 \\)  :\n \\( E(k,x) = kx \\mod 5 \\)     x E(3,x)     0 0   1 3   2 1   3 4   4 2    This looks a lot more random than the shift cipher. However, it looks like 0 will always map to 0 in a multiplicative cipher. Also, even though the arrows aren\u0026rsquo;t parallel, they still have some regularity to them. So we can do better.\nComposing ciphers #  Principle: Composing simple ciphers of different structures yields a more random looking cipher.  If we compose 2 invertible functions, the composition will still be invertible.\nFor example, if we start with a shift cipher, and then use a multiplicative cipher:\nCorrection: On right, 2 goes to 2, and 4 goes to 3.  You need to alternate between different ciphers to add security. (Composing 2 shifts wouldn\u0026rsquo;t add any additional security than 1).\nExample of a non-linear simple cipher #  An example of a non-linear cipher is a transposition cipher.\nIt considers the data to be in chunks, it doesn\u0026rsquo;t scramble the characters, but rearranges them:\nIt is a simple cipher (because it is reversible), and it is a permutation (domain and codomain are same). It is non-linear because it cannot be represented by the sum of product terms.\nConnection to AXR operations:\n add is a shift cipher in \\( Z_{2^n} \\) xor is a shift cipher in \\( Z_2 \\), for example \\(a \\oplus b = a + b \\mod 2\\) rotate is a transposition.   We usually don\u0026rsquo;t use multiplication because it is more computationally expensive.\n"}),a.add({id:255,href:'/notes/CS152/CS152-lecture-20210607/',title:"CS152-lecture-20210607",section:"CS152",content:"Distinguishing games #  File: Distinguishing.pdf  Cryptography used to be based on both the pedigree of the creator, and the amount of time it takes until someone can crack it. With modern cryptography, crytographers can prove that their algorithms work. The attack can be skipped if its proven that there are no weaknesses.\nWhen we encrypt a plaintext, we want the ciphertext to look like random bits.\nHow do we know that the cipher is a good cipher? If an adversary can\u0026rsquo;t tell the difference between the cipher and complete random bits, then it is indistinguishable from random.\nRandomness has no information in it.\nTo tell if the cipher is truly random looking, we can use distinguishing games:\n The distinguisher (could be adversary) is given a black box, with   \\( A \\)  or  \\( B \\)  in it (equally likely). The distinguisher follows an algorithm and guesses  \\( A \\)  or  \\( B \\)  .   \\[\\begin{aligned} \\text{advantage} \u0026amp;= P(\\text{ guess is right }) - P(\\text{ guess is wrong} ) \\\\ \u0026amp;= P(\\text{guess } A \\mid \\text{box is } A) - P(\\text{ guess } A \\mid \\text{box is } B) \\end{aligned}\\]  If our strategy was to always guess  \\( A \\)  , then  \\( \\text{advantage} = 1 - 1 = 0 \\)  .\nIf our strategy was to flip a coin and guess based on the coin, then  \\( \\text{advantage} = \\frac{1}{2} - \\frac{1}{2} = 0 \\)  .\nSo our distinguishing algorithm must be intelligent, it can\u0026rsquo;t simply guess.\nA concrete example #  Let  \\( f \\)  be a black box with either one 12-sided die, or two 6-sided dice.\nImagine that  \\( f \\)  has a button on the side, and when we press it the die/dice are rolled, and the total is displayed to us. (We can\u0026rsquo;t tell what black box we have by looking/listening to it, we can only see the outcome.)\nAlso, let  \\( f \\)  be used only once,  \\( q = 1 \\)  .\nTo tackle this:\n Give an algorithm using  \\( f \\)  .  x = f() if x == 1: // if we ever see a 1, it must be the single die guess \u0026quot;1 x 12\u0026quot; else: guess \u0026quot;2 x 6\u0026quot; Calculate the advantage   \\[\\begin{aligned} \\text{advantage} \u0026amp;= P (\\text{guess 1x12} \\mid f \\text{ is 1x12}) - P(\\text{guess 1x12} \\mid f \\text{ is 2x6}) \\\\ \u0026amp;= \\frac{1}{12} - 0 \\\\ \u0026amp;= \\frac{1}{12} \\end{aligned}\\]  Since this is greater than 0, it is distinguishing better than just randomly guessing. We can do better however, just because we have some advantage it doesn\u0026rsquo;t necessarily mean that it is a good distinguishing algorithm.\nThe distribution of the outcomes for a pair of dice is:\nWith no possibility of getting a 1.\nWith a 12 sided die, all outcomes are equally likely. If we overlay that on top of the pair of dice distribution:\nThe area above the line shows that there is a better probability that the box contains 2 dice. On the ends, there is a better probability it is a single die.\nSo we can adjust our algorithm:\nx = f() if x in [1, 2, 3, 11, 12]: guess \u0026quot;1 x 12\u0026quot; else: guess \u0026quot;2 x 6\u0026quot; Note: We are leaving off the values that are the same probability for each box, ie 4 and 10.  So the new advantage is\n \\[\\begin{aligned} \\text{advantage} \u0026amp;= P (\\text{guess 1x12} \\mid f \\text{ is 1x12}) - P(\\text{guess 1x12} \\mid f \\text{ is 2x6}) \\\\ \u0026amp;= \\frac{5}{12} - \\frac{2}{12} \\\\ \u0026amp;= \\frac{1}{4} \\end{aligned}\\]  Another example #  Let  \\( f : Z_{100} \\to Z_{100} \\)  be either a random function or a random permutation.\nThe random function is fixed, and the random permutation doesn\u0026rsquo;t allow any repetition.\nLet  \\( f \\)  be used only one time,  \\( q = 1 \\)  .\nSo what is a distinguishing algorithm? Remember the first time we invoke the random function, it will be equally likely to be any value. If its a random permutation, it\u0026rsquo;ll also give us an equally likely value (because its the first call to  \\( f \\)  ). So there is no way to distinguish them from each other, so lets set  \\( q = 2 \\)  (we can use the box twice).\nIf we give  \\( f \\)  2 different inputs, and we get the same output, then it must be a random function (because permutations don\u0026rsquo;t allow repetition).\nx = f(0) y = f(1) if x == y: guess \u0026quot;function\u0026quot; else: guess \u0026quot;permutation\u0026quot;  \\[\\begin{aligned} \\text{advantage} \u0026amp;= P (\\text{guess func} \\mid f \\text{ is func}) - P(\\text{guess func} \\mid f \\text{ is perm}) \\\\ \u0026amp;= \\frac{1}{100} - 0 \\\\ \u0026amp;= \\frac{1}{100} \\end{aligned}\\]  Lets say we can use the black box  \\( q \\)  times.\nOur distinguishing algorithm scales with  \\( q \\)  .\nfor i from 0 to q: x = f(i) for j from i to q: y = f(j) if x == y: guess \u0026quot;function\u0026quot; else: guess \u0026quot;permutation\u0026quot;  \\[\\begin{aligned} \\text{advantage} \u0026amp;= P (\\text{guess func} \\mid f \\text{ is func}) - P(\\text{guess func} \\mid f \\text{ is perm}) \\\\ \u0026amp;= \\frac{q^2}{100} - 0 \\\\ \u0026amp;= \\frac{q^2}{100} \\end{aligned}\\]  Note: Sometime around the 10th (square root of \\(q\\)) use of the black box, we should see repetition if the box is a function (the birthday problem).  The birthday bound #  If  \\( q \\)  balls are thrown randomly into  \\( n \\)  bins, then the probability that some bin has at least two balls is roughly\n \\[\\begin{aligned} \\frac{q^2}{n} \\end{aligned}\\]  This is a \u0026ldquo;cryptographer\u0026rsquo;s approximation\u0026rdquo;, it breaks down when  \\( q \\)  is large. We know that probabilities can\u0026rsquo;t be greater than 1. So this only works for small  \\( q \\)  , but it at least tells us when our probability is getting close to 1.\nIn cryptography, we want to keep our probabilities very close to 0, so this approximation is good enough for us, because:  \\( q^2 \\)  should never get close to  \\( n \\)  .\nThis is a good rough approximation for the probability that you have collisions amongst  \\( q \\)  random values coming from the codomain of size  \\( n \\)  .\n"}),a.add({id:256,href:'/notes/CS152/CS152-lecture-20210608/',title:"CS152-lecture-20210608",section:"CS152",content:"How are permutations made? #  To create a permutation we will\n Compose simple steps, each with a different mathematical structure, providing confusion and diffusion.  we can use add, because it is in   \\( Z_{2^{32}} \\)   xor, because it is in  \\( Z_{2} \\)   and rotate, because it is non-linear (not represented by a linear equation)    Adding on its own makes a predictable structure, but if we xor after and then rotate we can get a much more confusing structure. By composing these 3 instructions, we can achieve confusion and diffusion.\nThe composition of multiple instructions can make the output look a lot more random.\nConfusion #  An operation has confusion if it has a complex input-output behavior. Hard to model mathmatically and looks somewhat random.  Some cryptanalysis can try to approximate the function using a mathematical function. So the more confusion that a function has, the harder it is to approximate.\nDiffusion #  An operation has diffusion if changing an input bit changes output bits in other locations.  For example, if\n0101 -\u0026gt; f -\u0026gt; 1111 0111 -\u0026gt; f -\u0026gt; 1001 Changing 1 input bit caused 2 output bits to change.\nThe diffusion of the simple operations:\nadd x = 5 0101 1 0001 x + 1 0110 // 2 bits changed, little diffusion When using add, carry bits provide a little diffusion.\nxor x = 0 0000 5 0101 x ^ 5 0101 // no diffusion No diffusion is provided using xor.\nrotate x = 3 0011 x rotl 2 1100 // good diffusion! x = 2 0010 x rotl 2 1000 // however not a huge change in // diffusion between different values Note: Using rotate on different values doesn\u0026rsquo;t have a huge relative diffusion, however good diffusion can be achieve when changing the input if you also change the rotation amount.  Ideally, if we change 1 bit in our input, we\u0026rsquo;d like at least half of the output bits to change.\nAdd/rotate have a little local diffusion. Local diffusion refers to the word being altered.\nThe characteristics of an algorithm #  Asymmetric cryptoalgorithm #  Usually has\n Composed simple steps, provides local confusion and diffusion Rearrangement of parts of the data, to spread the confusion and diffusion Loop many times to amplify the confusion and diffusion  perm384 #  A permutation that scrambles 384 bits. Since its a permutation, its both 1-to-1 and onto, so every 384 bit string maps to another 384 bit string.\nIt takes 48 bytes, and scrambles them over 24 iterations (which we call rounds).\nHeres the pseudo:\nperm384(p): for round = 0 to 23 scramble(p32+0, p32+4, p32+8) scramble(p32+1, p32+5, p32+9) scramble(p32+2, p32+6, p32+10) scramble(p32+3, p32+7, p32+11) if (round mod 4 == 0) // ie, when round is 0, 4, 8, 12, 16, 20 swap uint32_t values at p32+0 and p32+1 swap uint32_t values at p32+2 and p32+3 xor uint32_t value at p32+0 with (0x79379E00 xor round) if (round mod 4 == 2) // ie, when round is 2, 6, 10, 14, 18, 22 swap uint32_t values at p32+0 and p32+2 swap uint32_t values at p32+1 and p32+3 Lets visualize the first 4 scrambles:\nSince we are working with 48 bytes, we have 12 uint32s. This gives us good diffusion among the 3 being scrambled. (If we change a bit in 0, it will change bits in 4 and 8, but nowhere else.) This is the reason why we swap and rotate every once in a while.\nThis creates a lot more diffusion throughout the 48 bytes. When 0 and 1 are swapped, it propagates and also affects 4,5,8,9.\nscramble #  Heres the pseudo for scramble:\nscramble(a, b, c): x = ROTL(a, 24) y = ROTL(b, 9) z = c a = z xor y xor ((x and y) \u0026lt;\u0026lt; 3) b = y xor x xor ((x or z) \u0026lt;\u0026lt; 1) c = x xor (z \u0026lt;\u0026lt; 1) xor ((y and z) \u0026lt;\u0026lt; 2) Heres a diagram of scramble where  \\( f,g,h \\)  are 3-4 bitwise operators:\nAnalyzing perm384 #  It ends up that perm384 very closely resembles a random function. Due to Kerckoff\u0026rsquo;s law, we need to assume that everyone knows the algorithm that perm384 uses.\nWe want Alice and Bob to be able to send messages back and forth, without Eve extracting any information (or tamper with it). So how do we do this if everyone knows the details of perm384?\nWe can answer this question using distinguishing games.\nLets demonstrate that perm384 by itself, is not usable as a random function.\nSo if we have a black box  \\( f \\)  , with\n the first world being perm384 the second world being a function  \\( g: \\{0,1\\}^{384} \\to \\{0,1\\}^{384} \\)  (a random function with with the same signature as perm384).  So our algorithm would be:\ny = f(\u0026lt;0\u0026gt;_384) x = perm384(\u0026lt;0\u0026gt;_384) if x == y: output \u0026quot;perm384\u0026quot; else: output \u0026quot;random permutation\u0026quot; Note on notation: \u0026lt;0\u0026gt;_384 means 0 represented in 384 bits. \u0026lt;x\u0026gt;_n means x represented in n bits.   \\[\\begin{aligned} \\text{advantage} \u0026amp;= P(\\text{ guess perm384 } \\mid \\text{ is perm384 }) - P(\\text{ guess perm384 } \\mid \\text{ is } g) \\\\ \u0026amp;= 1 - \\frac{1}{2^{384}} \\\\ \u0026amp;\\approx 1 \\end{aligned}\\]  With an advantage of effectively 1, the distinguisher wins. So perm384 is not a good permutation for encryption on its own.\n So how do we do better?\nLets choose 2 new worlds and this time we\u0026rsquo;ll use a key  \\( k \\)  :\n world 1:  let  \\( k \\)  be a random 256 bits  \\( f(x) = \\text{perm 384}(x \\oplus ( k || \u0026lt;0\u0026gt;_{128})) \\)     world 2:  same as previous    Note on notation: The two vertical bars \\(||\\) indicate concatenation.  So our algorithm is\ny0 = perm384(\u0026lt;0\u0026gt;_384) y1 = perm384(\u0026lt;1\u0026gt;_384) x0 = f^-1(y0) x1 = f^-1(y1) if (x0 xor x1) == \u0026lt;1\u0026gt;_384: output \u0026quot;perm384\u0026quot; else: output \u0026quot;random permutation\u0026quot; Note: This is only possible if \\(f^{-1}\\) is available.  This attack only works in a \u0026ldquo;chosen ciphertext model\u0026rdquo;, meaning we have the inverse function available.\nIn this construction\n \\[\\begin{aligned} \\text{advantage} \\approx 1 \\end{aligned}\\]   One last time:\nIf we have 2 worlds\n world 1  let  \\( k \\)  be a random 256 bits  \\( f(x) = (k || \u0026lt;0\u0026gt;_{128}) \\oplus \\text{ perm384 }(x \\oplus (k || \u0026lt;0\u0026gt;_{128})) \\)     world 2  same as previous    So we\u0026rsquo;re xoring the output with the key  \\( k \\)  to protect the inverse.\nIn this construction\n \\[\\begin{aligned} \\text{advantage} \\approx 0 \\end{aligned}\\]  "}),a.add({id:257,href:'/notes/CS152/CS152-lecture-20210610/',title:"CS152-lecture-20210610",section:"CS152",content:"Symmetric encryption #  Files:\n Intro to SSE programming https://www.crypto-textbook.com/download/Understanding-Cryptography-Chapter4.pdf   Recall that encryption is to be used for private communication. Before a message is encrypted its called a plaintext, and after its been encrypted its called a ciphertext. The ciphertext is then decrypted to get the plaintext.\nRecall that we defined\nperm384bc(k, x) = perm384(k xor x) xor k Remember, perm384 is a public random permutation, so its not enough for secrecy. So we xor before and after with a key. That way, even if the adversary knows whats going in or out, the adversary does not know the actual value going into the known algorithm because of the xor with the key.\nThis is a block cipher (hence the bc in the name perm384bc). All hardware has specific circuits for block ciphers. The standardized block cipher is called AES. It is so standardized that chip builders have specific hardware and assembly instructions to make AES as efficient as possible.\nBlock ciphers #  A block cipher is defined as\n  \\[\\begin{aligned} F: \\underbrace{\\{0,1\\}^k}_{\\text{key}} \\to \\left( \\underbrace{\\{0,1\\}^b \\to \\{0,1\\}^b}_{\\text{permutation}} \\right) \\end{aligned}\\]  Property: a block cipher with a random key is indistinguishable from a random permutation.  Block cipher modes of operation #  There are multiple modes that we will study.\nConsider  \\( P: \\{0,1\\}^b \\to \\{0,1\\}^b \\)  where  \\( b = 128 \\)  (blocksize).\nECB (electronic codebook)\n Let our plaintext be  \\( x \\)  , and divided into  \\( b \\)  bit size chunks. Each chunk will be fed through  \\( p \\)    CBC (cipher block chaining)\n Very similar looking to ECB, but addresses some of ECB\u0026rsquo;s flaws, eg  We want repeated encryption on ciphertexts to be different, so as to not leak information   Xor an initialization vector  \\( IV \\)  , before the block cipher, where  \\( IV \\)  is a random  \\( b \\)  bits, per encryption.   \\( IV \\)  and the ciphertext  \\( Y \\)  are sent to the recipient ( \\( IV \\)  is only used to decrypt the very first block) CBC is serial during encryption (blocks are encrypted in order because the second block needs the first and so on) However, decryption can be done in parallel  CTR (counter)\n Counter mode behaves differently than the last 2 Let  \\( N \\)  be a nonce (a value used once) We build a  \\( b \\)  bit block where the first part is  \\( N \\)  and the second part is the number 1 encoded into binary (its traditional to have the first block split in half). The next block will have the nonce and the number 2 (in binary) as the second part of the block,  What comes out of this process is the key stream, The distribution of the key stream is very close to uniform. We then take our plaintext  \\( X \\)  and xor it with the key stream,  \\[\\begin{aligned} Y = X \\oplus \\text{ key stream} \\end{aligned}\\]   The nonce and the ciphertext are sent to the recipient This is now the most popular mode The counter should be incremented in an endian-neutral manner  OFB (output feedback)\n Each output from  \\( P \\)  is fed into the next input for each block, and this creates a key stream We send  \\( IV \\)  and the ciphertext  \\( Y \\)    Note: Our next programming assignment will be to implement the block cipher perm384bc and use the CTR mode to encrypt.  multiple messages in a row, diff nonce, same key for perm384bc?\nSecurity model for encryption #  Cryptographers often come up with models that quantify how secure something is.\nReal encryption should be indistinguishable from random. If the adversary cannot distinguish a ciphertext from random, then we consider that secure.\nWe can quantify this using distinguishing games, consider\n Real world  Init of black box: let  \\( k \\)  be a random key on  \\( f(x) \\)  encrypt  \\( x \\)  with  \\( k \\)     Random world  Init of black box: let  \\( k \\)  be a random key on  \\( f(x) \\)  encrypt  \\( x \\)  with  \\( k \\)  , then send back same number of random bits    If the distinguisher can\u0026rsquo;t tell the difference between these 2 worlds (ie the advantage is close to 0), then the encryption is good. Note that the adversary has an easy goal, just distinguish if its random or not. They don\u0026rsquo;t have to attempt to recover the plaintext, not even the key.\nThis is called \u0026ldquo;real or random\u0026rdquo; security.\nDistinguishing algorithm for ECB mode #   Real world   \\( k \\)  is random on  \\( x \\)  : ECB encrypt  \\( x \\)     Random world   \\( k \\)  is random on  \\( x \\)  : ECB encrypt  \\( x \\)  , then send back random bits of same length as ciphertext    Distinguisher:\nx = \u0026lt;0\u0026gt;_b || \u0026lt;0\u0026gt;_b // 2 of the same blocks y = f(x) y1 || y2 = y // split y into 2 halfs if y1 == y2: output \u0026quot;real\u0026quot; else: output \u0026quot;random\u0026quot;  \\[\\begin{aligned} \\text{advantage} \u0026amp;= P(\\text{ guess real } \\mid \\text{ is real }) - P(\\text{ guess real } \\mid \\text{ is random }) \\\\ \u0026amp;= 1 - \\frac{1}{2^b} \\\\ \u0026amp;\\approx 1 \\end{aligned}\\]  Therefore, by itself ECB is not secure.\nDistinguishing algorithm for CTR mode #   Real world   \\( x,n \\)  is passed and the CTR encrypted ciphertext is returned   Random world  Random bits returned (the same length as real world)    If we press the box  \\( q \\)  times:\nfor i from 1 to q: y[i] = f(\u0026lt;0\u0026gt;_b, \u0026lt;i\u0026gt;_b/2) if any y[1]..y[q] are the same: output \u0026quot;rand\u0026quot; else: output \u0026quot;real\u0026quot;  \\[\\begin{aligned} \\text{advantage} \u0026amp;= P(\\text{ guess rand } \\mid \\text{ is rand }) - P(\\text{ guess rand } \\mid \\text{ is real }) \\\\ \u0026amp;= \\frac{q^2}{2^b} - 0 \\end{aligned}\\]  This is a good advantage if  \\( q \\)  is small and  \\( b \\)  is large.\nNote: In AES, \\(b = 128\\).  Bounds in security #  In upper bound security: the adversary can\u0026rsquo;t do better.\n Essentially a proof that the adversary can\u0026rsquo;t do better. Harder to prove!  In lower bound security: the adversary does at least this well.\n An attack that proves you can do at least this well.  Security reduction #  A distinguisher box with either a random function or a block cipher with a random key:\nblock_cipher_distinguisher(g): f = CTR(g) // let f be a CTR mode algorithm ans = real_or_random(f) // a function that tells what world we're in if ans == real output \u0026quot;block cipher\u0026quot; else: output \u0026quot;random\u0026quot; This is a security reduction. It shows how you could break 1 thing, if you had another function to break it (real_or_random).\n \\[\\begin{aligned} \\exist \\text{ real or rand } \u0026amp;\\to \\exist \\text{ block cipher distinguisher } \\\\ \\neg \\exists \\text{ block cipher distinguisher } \u0026amp;\\to \\neg \\exists \\text{ real or random } \\end{aligned}\\]  This establishes a upper bound of around the birthday bound as well. So since the upper and lower are almost the same, then they can make the claim of the actual security.\nGalois Fields #  A Galois Field, usually denoted as  \\( GF(2^n) \\)  where its elements are  \\( n \\)  -bit strings.\nSo in  \\( GF(2^5) = \\{00000, \\ldots, 11111\\}\\)  , where each of these elements represents a polynomial. So,\n \\[\\begin{aligned} 10101 \u0026amp;= x^4 \u0026#43; x^2 \u0026#43; x^0 \\\\ \u0026amp;\\text{or} \\\\ 11100 \u0026amp;= x^4 \u0026#43; x^3 \u0026#43; x^2 \\end{aligned}\\]  In order to call this a field, we have to define\n  addition: add polynomials and mod coefficients by 2, ie  \\[\\begin{aligned} 10101 \u0026#43; 11011 \u0026amp;= (x^4 \u0026#43; x^2 \u0026#43; x^0) \u0026#43; (x^4 \u0026#43; x^3 \u0026#43; x^1 \u0026#43; x^0) \\\\ \u0026amp;= 2x^4 \u0026#43; x^3 \u0026#43; x^2 \u0026#43; x^1 \u0026#43; 2x^0 \\\\ \u0026amp;\\,\\text{mod coeffecients by 2} \\\\ \u0026amp;= x^3 \u0026#43; x^2 \u0026#43; x^1 \\\\ \u0026amp;= 01110 \\end{aligned}\\]  Note that this entire process is simply the xor of the 2 inputs!  \\[\\begin{aligned} 10101 \\oplus 11011 \u0026amp;= 01110 \\end{aligned}\\]    multiplication: multiply the polynomials, mod by modulus, mod coefficients by 2  \\[\\begin{aligned} 10101 \u0026#43; 11011 \u0026amp;= (x^4 \u0026#43; x^2 \u0026#43; x^0)(x^4 \u0026#43; x^3 \u0026#43; x^1 \u0026#43; x^0) \\\\ \u0026amp;= x^8 \u0026#43; x^7 \u0026#43; x^6 \u0026#43; 2x^5 \u0026#43; 2x^4 \u0026#43; 2x^3 \u0026#43; x^2 \u0026#43; x^1 \u0026#43; x^0 \\\\ \u0026amp;\\text{ mod coeffecients by 2} \\\\ \u0026amp;= x^8 \u0026#43; x^7 \u0026#43; x^6 \u0026#43; x^2 \u0026#43; x^1 \u0026#43; x^0 \\\\ \u0026amp;\\text{ mod by irreducible polynomial} \\\\ \u0026amp;= x^8 \u0026#43; x^7 \u0026#43; x^6 \u0026#43; x^2 \u0026#43; x^1 \u0026#43; x^0 \\mod x^5 \u0026#43; x^2 \u0026#43; x^0 \\\\ \u0026amp;= x^4 \u0026#43; x^2 \\\\ \u0026amp;= 10100 \\end{aligned}\\]  Polynomial modulus work   Note: We use the irreducible polynomial: \\( x^5 + x^2 + x^0 \\) to mod by. This came from a lookup table for \\(GF(2^5)\\).    "}),a.add({id:258,href:'/notes/CS152/CS152-lecture-20210611/',title:"CS152-lecture-20210611",section:"CS152",content:"Fields #  A field is\n A collection of   \\( F \\)  objects Two binary operations  \\( \\times \\)  and  \\( \u0026#43; \\)  closed on  \\( F \\)  .  \\( F \\)  contains multiplicative identity 1 where  \\( (1 \\times y) = y \\)  for all  \\( y \\)  in  \\( F \\)  .  \\( F \\)  contains additive identity 0 where  \\( (0 \u0026#43; y) = y \\)  for all  \\( y \\)  in  \\( F \\)  . For each  \\( y \\)  in  \\( F \\)  , there exists a  \\( z \\)  in  \\( F \\)  such that  \\( (y \u0026#43; z) = 0 \\)  (additive inverse). For each  \\( y \\)  in  \\( F \\)  , except 0, there exists a  \\( z \\)  in  \\( F \\)  such that  \\( (y \\times z) = 1 \\)  (multiplicative inverse). Associative, commutative, distributive laws work as expected  Shorthands\n  \\( a^{-1} \\)  is  \\( a \\)  \u0026rsquo;s multiplicative inverse  \\( -a \\)  is  \\( a \\)  \u0026rsquo;s additive inverse  \\( a-b \\)  is short for  \\( a \u0026#43; - b \\)    \\( a / b \\)  is short for  \\( a \\times b^{-1} \\)    Field examples #    \\( \\mathbb{R} \\)  with standard addition and multiplication form a field (real numbers).  \\( \\mathbb{Q} \\)  with standard addition and multiplication form a field (rational numbers).  \\( \\mathbb{Z} \\)  with standard addition and multiplication doesn\u0026rsquo;t form a field (integers).   \\( a^{-1} \\)  doesn\u0026rsquo;t exist for most  \\( a \\)      \\( \\mathbb{Z}_p \\)  forms a field with  \\( p \\)  prime and addition and multiplication  \\( \\mod p \\)  .   \\( p \\)  must be prime to make sure every element has a multiplicative inverse.    Theorem: If \\( p \\) is prime, then there is a field of size \\( p^n \\) for each \\( n \u0026gt; 0 \\).   \\( \\mathbb{Z}_p \\)  is not convenient for high-speed processing:  \\( \\mod p \\)  is expensive and standard data type don\u0026rsquo;t hold a prime number of values.\nSince 2 is prime, there is a field of size  \\( 2^n \\)  for all  \\( n \u0026gt; 0 \\)  . This is promising because all data types can hold power-of-two different values.\nGalois Fields #   Evariste Galois died age 20 in a duel, 1821\n The set of all bit sequences of length  \\( n \\)  form a field called  \\( GF(2^n) \\)  . Because of the above theorem, there is a guarantee to have a field in a size of  \\( 2^n \\)  . We will use  \\( GF(256) \\)  for this class.\nGF(256) = {00000000, 00000001, 00000010, ..., 11111111} Addition\n Interpret the bits as coefficients of a degree 7 polynomial with variable  \\( x \\)   Add the two polynomlials to keep coefficients 0 or 1, mod each coefficient by 2 Concat the coefficients of the resulting degree 7 polynomial  Shortcut, xor\u0026rsquo;ing the two bytes produces the same result    Multiplication\n Interpret the bits as coefficients of a degree 7 polynomial with variable  \\( x \\)   Multiply the two polynomials, to keep coefficients 0 or 1, mod each coefficient by 2 Mod the result by  \\( x^8 \u0026#43; x^4 \u0026#43; x^3 \u0026#43; x^1 \u0026#43; x^0 \\)   Concat the coefficients of the resulting degree 7 polynomial  No shortcut, multiplication is expensive    GF(256) example #  Addition in  \\( GF(256) \\)  ,\n \\[\\begin{aligned} 00001001 \u0026#43; 10000001 \u0026amp;= x^3 \u0026#43; x^0 \u0026#43; x^7 \u0026#43; x^0 \\\\ \u0026amp;= x^7 \u0026#43; x^3 \u0026#43; 2x^0 \\\\ \u0026amp;\\text{mod coefficients by 2} \\\\ \u0026amp;= x^7 \u0026#43; x^3 \\\\ \u0026amp;= 10001000 \\end{aligned}\\]  Multiplication in  \\( GF(256) \\)  ,\n \\[\\begin{aligned} 00001001 \\times 10000001 \u0026amp;= (x^3 \u0026#43; x^0)(x^7 \u0026#43; x^0) \\mod x^8 \u0026#43; x^4 \u0026#43; x^3 \u0026#43; x^1 \u0026#43; x^0 \\\\ \u0026amp;= x^{10} \u0026#43; x^7 \u0026#43; x^3 \u0026#43; x^0 \\mod x^8 \u0026#43; x^4 \u0026#43; x^3 \u0026#43; x^1 \u0026#43; x^0 \\\\ \u0026amp;= x^7 \u0026#43; x^6 \u0026#43; x^5 \u0026#43; x^2 \u0026#43; x^0 \\\\ \u0026amp;= 11100101 \\end{aligned}\\]  Note: We are modding by the given polynomial above.  Padding #  Recall that our block cipher modes of operation use blocks of size  \\( b \\)  . The more common scenario ends with a block that is less than the size of  \\( b \\)  . So we can use padding to help the mode of operation.\nIn CTR mode, since its producing a key stream, they do not require padding. Stream ciphers do not require padding.\nIn the other modes, ECB and CBC, we need our input to be a multiple of  \\( b \\)  in order for it to work. In a non-stream cipher, to ensure a size that is a multiple of  \\( b \\)  , it has to go through a padding process.\nThese padding functions need\n unpad is the inverse of pad  \\( P\u0026#39; \\)  is a multiple of  \\( b \\)   efficiency  10* padding #   append a 1 bit, then append enough 0 to next multiple of  \\( b \\)    So if  \\( b = 16 \\)  ,\nb = 16 p = 1111 0000 1111 // needs padding to be 16 bits p' = 1111 0000 1111 1000 // padded So how do we distinguish between padded and not? We decide to always pad even if it already is a multiple of  \\( b \\)  .\nSo\nb = 16 p = 1111 0000 1111 0000 p' = 1111 0000 1111 0000 1000 0000 0000 0000 Note: Whenever we do ECB/CBC, we will always apply padding to avoid ambiguity with the receiver.  To unpad\n We will decrypt the ciphertext to get  \\( P\u0026#39; \\)   Remove all 0 and strip the rightmost 1  b = 16 p' = 1111 0000 1111 0000 1000 0000 0000 0000 // strip zeros from right of p' p' = 1111 0000 1111 0000 1 // strip 1 from right of p' to get p p = 1111 0000 1111 0000 If we\u0026rsquo;re at  \\( b - 1 \\)  bits,\np = 1111 1111 1111 111 // one away from 16 p' = 1111 1111 1111 1111 // adding the 1 made it a multiple of b // no 0s needed "}),a.add({id:259,href:'/notes/CS152/CS152-lecture-20210613/',title:"CS152-lecture-20210613",section:"CS152",content:"Block cipher encryption mode examples #  For these examples, consider\n    \\( E: \\{0,1\\}^6 \\to \\{0,1\\}^6 \\)    \\( E(x) = \\text{ROTL } (x,2) \\)   If needed   \\( \\text{nonce} = 101 \\)    \\( \\text{IV} = 110111 \\)   Counters start at \u0026lt;1\u0026gt; 10* padding    Encrypt the following\n0000 1111 0000 1111 ECB #  Since we are using block sizes of 6 bits, we are encrypting\nplaintext 000011 110000 11 So the first thing we have to do is pad the rightmost block.\npadded plaintext 000011 110000 111000 Then we can send each block through  \\( E \\)  ciphertext 001100 000011 100011 To decrypt, we have to use the inverse of  \\( E \\)  , ie rotate right by 2, then we depad\nCBC #  We also need to pad our plaintext for CBC mode, so\nplaintext 000011 110000 11 padded plaintext 000011 110000 111000 We will use  \\( IV = 110111 \\)  So the first operation is to xor the first padded plaintext with the  \\( IV \\)  , then put through  \\( E \\)  ,\nThat value is now the new xor for the next block, and the process continues\nNote when doing these types of problems on a quiz: Any error when calculating these xors will propagate through the rest of the ciphertext.  This gives us the ciphertext\nciphertext 010011 001110 011011 For decryption:\n We would receive the ciphertext, and The previous given variables/functions  We can reverse the arrows in our diagram to visualize it,\nNote: The arrows from block \\( n - 1 \\) that is xor\u0026rsquo;d with block \\( n \\)\u0026rsquo;s arrow is not inverted. The reason is because xor is its own inverse.  Also, note that\n  \\( E^{-1} = \\text{ROTR } (x, 2) \\)  , and We still need to know  \\( IV \\)    We can start with the first block\nand continue the process\nFinally, we unpad by\n Strippping trailing zeros, and strip rightmost one  Note on CBC: While encryption is done serially, decryption can be done in parallel. Some hardware allows for multiple invocations of the permutation at the same time.  CTR #  Recall that counter mode is a stream cipher. It generates a stream of bits that is xor\u0026rsquo;d with the plaintext to obtain cipher (and opposite for decrypt).\nIt does not need padding. The goal is to produce at least as many bits as the message to be encrypted. So we will generate 3 CTR blocks to be enough for our message length of 18 bits\nOur  \\( \\text{nonce} = 101 \\)  , and our counter starts at 1.\nSo our 3 blocks look like this, where each block is the nonce concatenated with the counter:\n101001 101010 101011 Every single block will be a different value, but we must never repeat a nonce for 2 different plaintexts.\nWe can then put our blocks through  \\( E \\)  to produce our key stream. Then we xor our key stream with our plaintext\n \\[\\begin{aligned} \\text{ciphertext} = \\text{plaintext } \\oplus \\text{ key stream} \\end{aligned}\\]  but we only use the amount of bits we need out of the key stream.\nNote: When we send a message using CTR mode, we send both the nonce and the ciphertext.  Decryption:\n \\[\\begin{aligned} \\text{plaintext} = \\text{ciphertext } \\oplus \\text{ key stream} \\end{aligned}\\]  A benefit to CTR is that decryption uses the same process as encryption. Generate the keystream again using the same process, then xor the ciphertext to obtain the plaintext.\nOFB #  Output feedback mode is also a stream cipher.\nRecall\n Our initialization vector  \\( \\text{IV} = 110111 \\)    This goes through permutation  \\( E \\)  and generates the first block of the key stream.\nThe output block is then fed back into the next block\nThis process continues until you have enough bits of key stream to xor with your plaintext\nBecause its a stream cipher,\n To encrypt we can xor plaintext with the key stream to obtain the ciphertext.  \\[\\begin{aligned} \\text{ciphertext} = \\text{plaintext } \\oplus \\text{ key stream} \\end{aligned}\\]   To decrypt we can xor the ciphertext with the key stream to obtain the plaintext.  \\[\\begin{aligned} \\text{plaintext} = \\text{ciphertext } \\oplus \\text{ key stream} \\end{aligned}\\]    AES #  AES is the standard block cipher used for symmetric encryption.\nRecall, a block cipher is intended to resemble a random permutation. If we have a distinguisher with 2 worlds,\n a random world a block cipher with a random key  it should be hard to distinguish between the two worlds (this is how cryptographer\u0026rsquo;s can prove the strength of a block cipher).\nFile: Ch 4 slides  Since one iteration doesn\u0026rsquo;t give enough security, there are at least 10 rounds (depending on key size) to acquire as much confusion and diffusion as possible. Each round could be thought of as a weak block cipher, as if 10 weak block ciphers are composed. As we compose more and more ciphers, they become more and more random looking.\nStructure #  ByteSubstitution #  ByteSubstitution can be thought of as a 1 byte random permutation. Also called a S-Box (substitution box). This is the non-linear step, which is important because of the strength acquired from alternating between different mathematical structures. This adds confusion.\nThe ByteSubstitution is a Galois Field  \\( GF(2^8) \\)  ,\n \\[\\begin{aligned} \\text{ByteSubstitution } (x) = x^{-1} \\cdot C_1 \u0026#43; C_2 \\end{aligned}\\]  This is implemented as a look-up table.\nShiftRows #  ShiftRows rearranges the order of the data elements. Each group of 4 bytes is scattered across the range of the next layer. They each maintain their respective position, but they are scattered. This adds diffusion.\nMixColumns #  MixColumns is another source of diffusion. It uses a cipher to scramble the 4 input bytes and which adds a smaller amount of local diffusion.\nThis is basically a system of equations.\nIf you had an input  \\( B = \\text{0x03} \\)   \\[\\begin{aligned} \\text{0x02} \\cdot B \u0026amp;= 00000010 \\cdot 00000011 \\\\ \u0026amp;= x (x \u0026#43; 1) \\\\ \u0026amp;= x^2 \u0026#43; x \\\\ \u0026amp;= 00000110 \\end{aligned}\\]  This leads to compact notation.\nIf we have 4 bytes coming into our MixColumns\nWe can find our output like by using the matrix multiplication,\nWe can use a  \\( GF(256) \\)  calculation to obtain the value\n \\[\\begin{aligned} w \u0026amp;= 2A \u0026#43; 3B \u0026#43; C \u0026#43; D \\\\ \u0026amp;= (x)(x^2 \u0026#43; 1) \u0026#43; (x \u0026#43; 1)(x^4) \u0026#43; (x^4 \u0026#43; 1) \u0026#43; (x^2 \u0026#43; x) \\\\ \u0026amp;= (x^3 \u0026#43; x) \u0026#43; (x^5 \u0026#43; x^4) \u0026#43; (x^4 \u0026#43; 1) \u0026#43; (x^2 \u0026#43; x) \\\\ \u0026amp;= x^5 \u0026#43; 2x^4 \u0026#43; x^3 \u0026#43; x^2 \u0026#43; 2x \u0026#43; x^0 \\\\ \u0026amp;\\text{mod coefficient by 2} \\\\ \u0026amp;= x^5 \u0026#43; x^3 \u0026#43; x^2 \u0026#43; x^0 \\\\ \u0026amp;= \\text{0b}00101101 \\\\ \u0026amp;= \\text{0x2D} \\end{aligned}\\]  Key addition layer #  Note that the first key is xor\u0026rsquo;d directly with the plaintext. After that, the round key is generated using the last key using a simple transformation.\n \\( g \\)  is defined in this slide,\nUsually, the 11 round keys are generated and kept in memory so its available each time the block cipher is used.\nDecryption #  Introduction to SSE programming #  File: Intro to SSE pdf  We will stick to the original 16 byte wide registers for these examples.\nmem 000102030405060708090a0b0c0d0e0f reg 0f0e0d0c0b0a09080706050403020100 // intel does little-endian SSE instructions can be told how to split up the register. For example if we split by 4\nreg 0f0e0d0c 0b0a0908 07060504 03020100 There are a bunch of instructions that you can use on these elements.\nTips when programming with SSE #  See intrinsics in above pdf\nWhen programming with SSE, we will be using compiler intrinsics. These intrinsic functions compile into 1 single assembly instruction.\nLink: Intrinsics documentation, use SSE2  Since we don\u0026rsquo;t have an intrinsic rotate instruction in SSE2, we need to do the split rotate and or the result to achieve the rotation.\nSome SSE example code #  Consider,\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;immintrin.h\u0026gt;#include \u0026lt;time.h\u0026gt; // accumulator function uint32_t sum(uint32_t * buf, int n) { uint32_t res = 0; for (int i = 0; i \u0026lt; n; i++) { res = res + buf[i]; } return res; } int main(int argc, char * argv[]) { // allocate 4 million bytes  uint32_t * buf = malloc(1000000 * 4); // read timer  clock_t t = clock(); // sum all elements  uint32_t total = sum(buf, 1000000); // get elapsed time  t = clock() - t; printf(\u0026#34;%u\\n\u0026#34;, (unsigned) t); } When this runs it outputs\n4790 which is different on each run, because it is measuring the amount of ticks it takes to complete the calculation. (They are averaging around 3000).\nLets see if we can do better using SSE instructions. Instead of reading each element individually, lets read them in groups of 4.\nWe can modify our sum function to use SSE instructions, we\u0026rsquo;ll call it sum_sse:\nuint32_t sum_sse(uint32_t * buf, int n) { uint32_t res_arr[4]; __m128i res = _mm_setzero_si128(); // 0 0 0 0  for (int i = 0; i + 4 \u0026lt; n; i = i + 4) { // load current element  __m128i temp = _mm_loadu_si128((__m128i *)(buf + i)); // add to sum  res = _mm_add_epi32(res, temp); } // store res into memory  _mm_storeu_si128((__m128i *) res_arr, res); // return sum of 4 elements  return res_arr[0] + res_arr[1] + res_arr[2] + res_arr[3]; } When we run this we get an average output time of around 1500, so while this was harder to write, it is a lot faster.\nNote: To sum the 4 values in our res value, we could do something like this:\n1 2 3 4 0 1 2 3 shift right 1 3 5 7 sum last 2 0 0 1 3 shift right twice 1 3 6 10 sum last 2 10 our answer However, we just write res back to memory and then sum the result of that.\n Introduction to SSL programming #  While SSL was introduced for securing network connections, we aren\u0026rsquo;t going to use it in that way. We will be using the open source toolkit because it contains implementations of almost everything we\u0026rsquo;re learning in the class.\nTo tell what version of openssl we\u0026rsquo;re on:\nopenssl version  Docs: OpenSSL documentation Wiki: OpenSSL wiki Source: OpenSSL crypto source code   We will be using the EVP authenticated encryption and decryption.\nWe will be using the evp.h header file.\nSo lets write something using some openssl code to make sure our environment is working, in a file called test.c:\n#include \u0026lt;openssl/evp.h\u0026gt; int main() { // make a call to some kind of openssl function  EVP_aes_128_ctr(); return 0; } We can compile with, linking the crypto lib\ngcc -lcrypto test.c An OpenSSL encryption example #  Lets encrypt something, note\n OpenSSL uses contexts, whatever the encryption mode needs is in the context. We allocate them in the stack, ie EVP_CIPHER_CTX *ctx;  init this with EVP_CIPHER_CTX_new()   We aren\u0026rsquo;t handling errors robustly here, for brevity In order to stay in our cryptographic model, our key should be random bytes. However for brevity we are using a simple key. To specify what block cipher and mode of operation, we call EVP_EncryptInit_ex and pass it  a pointer to our context specifier for what block cipher / mode an ENGINE *, we will always put NULL. This value is if you have a special implementation of your mode of operation. a pointer to the key, 16 bytes long a pointer to the initialization vector, we\u0026rsquo;ll use our nonce when we create iv   EVP_EncryptUpdate\u0026rsquo;s name including the word \u0026ldquo;update\u0026rdquo; indicates that it does not encrypt all the data at once. EVP_EncryptFinal is called to finalize the encryption  if there is anything in the buffer, it would pad/encrypt/write, needs a pointer to where to continue writing bytes should there be any in the buffer   EVP_CIPHER_CTX_free is used to clean up allocated memory  securely releases memory    #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;openssl/evp.h\u0026gt; int main() { /* ENCRYPTION */ // plaintext  char pt[44] = \u0026#34;The quick brown fox jumps over the lazy dog\u0026#34;; char pt2[44]; // ciphertext  char ct[44]; // key (should be random)  unsigned char key[16] = {1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6}; // nonce || counter  unsigned char iv[16] = {1,2,3,4,5,6,7,8,0,0,0,0,0,0,0,1}; // our cipher context  EVP_CIPHER_CTX * ctx; ctx = EVP_CPHER_CTX_new(); EVP_EncryptInit_ex(ctx, EVP_aes_128_ctr(), NULL, key, iv); // do the encryption  int len; // how many bytes written  int ciphertext_len; EVP_EncryptUpdate(ctx, ct, \u0026amp;len, pt, 44); ciphertext_len = ciphertext_len + len; // finalize, then free context  EVP_EncryptFinal(ctx, ct + ciphertext_len, \u0026amp;len); ciphertext_len = ciphertext_len + len; EVP_CIPHER_CTX_free(ctx); /* DECRYPTION */ // reset counter block  iv[15] = 1; // reinit context  EVP_DecryptInit_ex(ctx, EVP_aes_128_ctr(), NULL, key, iv); // do the decryption  len = 0; int plaintext_len; EVP_DecryptUpdate(ctx, pt2, \u0026amp;len, ct, 44); plaintext_len = plaintext_len + len; // finalize, then free context  EVP_DecryptFinal_ex(ctx, pt2 + plaintext_len, \u0026amp;len); plaintext_len = plaintext_len + len; EVP_CIPHER_CTX_free(ctx); // lets check if it worked  printf(\u0026#34;%s\\n\u0026#34;, pt2); } gcc -lcrypto test.c ./a.out The quick brown fox jumps over the lazy dog "}),a.add({id:260,href:'/notes/CS152/CS152-lecture-20210615/',title:"CS152-lecture-20210615",section:"CS152",content:"Stream ciphers #  A stream cipher is a function that takes\n a key   \\( k \\)   a nonce  \\( n \\)     \\[\\begin{aligned} \\underbrace{\\{0,1\\}^k}_\\text{key} \\times \\underbrace{\\{0,1\\}^n}_\\text{nonce} \\to \\underbrace{\\{0,1\\}^*}_\\text{key stream} \\end{aligned}\\]  Note on notation: a set raised to an asterisk  ( * )  the strings 0 or more length that can be made from the set items.  Our ciphertext is acquired via\n \\[\\begin{aligned} \\text{ciphertext} = \\text{plaintext } \\oplus \\text{ key stream} \\end{aligned}\\]  and plaintext (when decrypting) is obtained via\n \\[\\begin{aligned} \\text{plaintext} = \\text{ciphertext } \\oplus \\text{ key stream} \\end{aligned}\\]  CHACHA20 #  The most popular stream cipher.\nOpenSSL ciphersuites  Note that the top 3 used ciphersuites are either AES or CHACHA20\nCHACHA20 is a stream cipher (AES is a block cipher).\nThe CHACHA permutation takes in 64 bytes and produces 64 bytes.\nThe 64 byte block is the concatentation of\n16B constant || 32B key || 8B nonce || 8B counter The entire block is added to the output of the permutation. The counter will continue to increment on each iteration of 64 bytes. The constant is added so that a 0 input doesn\u0026rsquo;t lead to a 0 output.\nNote, CTR and OFB are stream ciphers\nSIMD – single instruction multiple data #  Recall that our perm384 takes 12 uint32_ts,\nIf we think of the 12 values as a matrix, we scramble them columnwise\nEach column being scrambled are only being scrambled with themselves, so they can be done in parallel. This is where SIMD comes in, we can have a single wide register and think of it as our partitioned data. Then we can do the entire scramble in 1 instruction.\nIntel intrinsics documentation  If we consider add_epi16(a, b):\nscramble using SSE instructions #  Lets change this so that it scrambles all 4 values at once.\n#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;immintrin.h\u0026gt; void scramble(__m128i *a, __m128i *b, __m128i *c) { // read  __m128i ssex = _mm_loadu_si128(a); __m128i ssey = _mm_loadu_si128(b); __m128i ssez = _mm_loadu_si128(c); // rotate  ssex = _mm_or_si128(_mm_slli_epi32(ssex, 24), _mm_srli_epi32(ssex, 8)); ssey = _mm_or_si128(_mm_slli_epi32(ssey, 9), _mm_srli_epi32(ssey, 23)); // scramble  // *a = z ^ y ^ ((x \u0026amp; y) \u0026lt;\u0026lt; 3);  _mm_storeu_si128(_mm_or_si128(ssez, _mm_xor_si128(ssey, _mm_slli_epi32(_mm_and_si128(sses, ssez))))); // left to reader...  // *b = y ^ x ^ ((x | z) \u0026lt;\u0026lt; 1);  // *c = x ^ (z \u0026lt;\u0026lt; 1) ^ ((y \u0026amp; z) \u0026lt;\u0026lt; 2); } While the amount of instructions isn\u0026rsquo;t less when using SSE (its actually a few more), it is doing the entire scramble process in parallel.\nFile reading/writing in C recap #  Recap on reading/writing files in C\nA useful pattern:\n"}),a.add({id:261,href:'/notes/CS152/CS152-lecture-20210617/',title:"CS152-lecture-20210617",section:"CS152",content:"OpenSSL example from previous lecture, finished #  cbc_encrypt.c #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;openssl/evp.h\u0026gt; #define BLK_LEN 16 #define BUF_LEN 512  // NOTE!! For clarity\u0026#39;s sake, this example has no error checking. // In real code you need to test for errors and handle them.  int main(int argc, const char* argv[]) { int len, bytes_read; char passphrase[256]; unsigned char key[32]; // Receive SHA-2-256 hash of user pass phrase  unsigned char iv[BLK_LEN]; unsigned char in_buf[BUF_LEN]; unsigned char out_buf[BUF_LEN+BLK_LEN]; EVP_MD_CTX *mdctx; if (argc != 3) { printf(\u0026#34;Error: Need two arguments, src and dst files\\n\u0026#34;); return EXIT_FAILURE; } // Open files to read and write  FILE *src = fopen(argv[1], \u0026#34;r\u0026#34;); FILE *dst = fopen(argv[2], \u0026#34;w\u0026#34;); if (src==NULL || dst==NULL) { printf(\u0026#34;Error: could not open file(s)\\n\u0026#34;); return EXIT_FAILURE; } // Get passphrase for encryption  printf(\u0026#34;Enter passphrase up to 255 characters: \u0026#34;); fgets(passphrase, 256, stdin); // Hash passphrase, put 256 bit result in \u0026#34;key\u0026#34;  mdctx = EVP_MD_CTX_create(); EVP_DigestInit_ex(mdctx, EVP_sha256(), NULL); EVP_DigestUpdate(mdctx, passphrase, strlen(passphrase)); EVP_DigestFinal_ex(mdctx, key, NULL); EVP_MD_CTX_destroy(mdctx); // Write a random IV to dst  FILE *rand = fopen(\u0026#34;/dev/urandom\u0026#34;, \u0026#34;r\u0026#34;); fread(iv, 1, BLK_LEN, rand); fwrite(iv, 1, BLK_LEN, dst); fclose(rand); // Set up context with alg, key and iv  EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new(); EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, key, iv); bytes_read = fread(in_buf, 1, BUF_LEN, src); while (bytes_read \u0026gt; 0) { EVP_EncryptUpdate(ctx, out_buf, \u0026amp;len, in_buf, bytes_read); fwrite(out_buf, 1, len, dst); bytes_read = fread(in_buf, 1, BUF_LEN, src); } EVP_EncryptFinal_ex(ctx, out_buf, \u0026amp;len); fwrite(out_buf, 1, len, dst); // Free memory, zero sensitive stack elements  EVP_CIPHER_CTX_free(ctx); OPENSSL_cleanse(key, sizeof(key)); OPENSSL_cleanse(in_buf, sizeof(in_buf)); OPENSSL_cleanse(passphrase, sizeof(passphrase)); fclose(src); fclose(dst); return EXIT_SUCCESS; }  key comes from a hash iv come from /dev/urandom.    Hashing #  File: Hash notes  Hash functions are algorithms that map a large domain into a small codomain. Cryptographers can use hash functions to authenticate their messages. The message is hashed to a smaller piece of data, and that is used to authenticate the original data.\nIn order for it to be secure, adversaries should not be able to create the hashes themselves, without having the original data.\nThere are 2 kinds of hash in cryptography:\nCryptographic hash\n Algorithms like  MD5 (now deprecated) SHA (the standard, \u0026ldquo;secure hash algorithm\u0026rdquo;)   slower no one can find two inputs that map to the same output no key   Universal hash\n faster randomized (does have a key) weaker guarantees    Universal hash example – Polynomial evaluation hash #  Note: These polynomials are not related to Galois fields  Let   \\( p \\)  be prime.\nGood prime numbers to use are something like\n \\(2^{127} - 2 \\), a Mersenne prime \\(2^{130} + 5 \\), the prime used in POLY1305  Init: choose  \\( k \\in Z_p \\)  at random.\nWhen we hash something, we require to be given a vector of values  \\( (a_1, a_2, \\ldots, a_n) \\)  each in  \\( Z_p \\)  .\nThe hash value is defined as\n \\[ (a_1k^n \u0026#43; a_2k^{n-1} \u0026#43; \\cdots \u0026#43; a_nk^1) \\mod p\\]  Concrete polynomial hash evaluation example #   Our prime number will be  \\( 2^{19} - 1 \\)   Pick  \\( k \\)  at random to be  \\( 1234 \\)    The data we want to hash is\n0001 0203 0405 chunked into 16 bit quantities. We can think of these as integers\n1 515 1029 Our hash result is going to be\n \\[\\begin{aligned} \\text{hash} \u0026amp;= \\left( (1)(1234)^3 \u0026#43; (515)(1234)^2 \u0026#43; (1029)(1234)^1 \\right) \\mod 2^{19} - 1\\\\ \\end{aligned}\\]  A theorem about polynomial hashing #  Theorem: Let \\(p\\) be prime, and \\((a_1, a_2, \\ldots, a_n) \\neq (a'_1, a'_2, \\ldots, a'_n)\\) with each \\(a_i\\) and \\(a'_i \\in Z_p\\).\nThen,\n\\[P(a_1 k^n + a_2 k^{n-1} + \\cdots + a_n k^1 \\mod p = a'_1 k^n + a'_2 k^{n-2} + \\cdots + a'_n k^1 \\mod p) \\\\ \\leq \\frac{n}{p} \\]\nThe probability that those 2 vectors are equal is very small if \\(n\\) is small and \\(p\\) is large.\n This theorem is fairly easy to prove.\nIf we define the hashes to be\n  \\( \\text{hash1} = a_1 k^n \u0026#43; a_2 k^{n-1} \u0026#43; \\cdots \u0026#43; a_n k^1 \\mod p \\)    \\( \\text{hash2} = a\u0026#39;_1 k^n \u0026#43; a\u0026#39;_2 k^{n-2} \u0026#43; \\cdots \u0026#43; a\u0026#39;_n k^1 \\mod p \\)     \\[\\begin{aligned} P(\\text{hash1 = hash2}) \u0026amp;\\leq \\frac{n}{p} \\\\ P(\\text{hash1 } - \\text{ hash2} = 0) \u0026amp;\\leq \\frac{n}{p} \\end{aligned}\\]  Where\n  \\( n \\)  is the number of possible zeros (solutions) and  \\( p \\)  is the number of candidates for  \\( k \\)    Note: A polynomial in a field \\(Z_p\\) has the same fundamentals as normal.  Horner\u0026rsquo;s rule – faster polynomial evaluation #  Horner\u0026rsquo;s rule is an algorithm for computing polynomial evaluations.\nWe\u0026rsquo;ll start with the identity 0, and start by adding it to our coefficient and multiply by our key\n \\[\\begin{aligned} (0 \u0026#43; a_1) k \\end{aligned}\\]  which evaluates to  \\( a_1 k \\)  We then repeat\n \\[\\begin{aligned} ((0 \u0026#43; a_1) k \u0026#43; a_2) k \\end{aligned}\\]  which evaluates to  \\( a_1k^2 \u0026#43; a_2 k \\)  This continues\n \\[\\begin{aligned} (((0 \u0026#43; a_1) k \u0026#43; a_2) k \u0026#43; a_3) k \\end{aligned}\\]  So as long as we have terms to process, we just\n add the coefficient multiply by  \\( k \\)    This is good for streaming data!\nHere is Horner\u0026rsquo;s rule as pseudo code\nacc = 0 for i from 1 to n acc = acc + a[i] acc = (acc * k) mod p return acc Divisionless mod #  The most expensive instruction in a CPU is division, so our mod in Horner\u0026rsquo;s rule can be improved.\nIf we are calculating\n \\[\\begin{aligned} x \\mod y \\end{aligned}\\]  Instead of solving that directly, we\u0026rsquo;ll look at  \\( y \\)  as\n \\[\\begin{aligned} x \\mod (2^a - b) \\end{aligned}\\]  Note: Any number can be written as a power of 2 minus a constant.  Lets break  \\( x \\)  into 2 parts, high and low bits.\nThe low part  \\( x_\\text{lo} \\)  will be  \\( a \\)  bits long.\nIf we want to think of decimal numbers:\n \\[\\begin{aligned} 12345 \u0026amp;= 12(x) \u0026#43; 345 \\\\ \u0026amp;= 12(10^3) \u0026#43; 345 \\\\ \u0026amp;= 12345 \\end{aligned}\\]  So lets do the same thing but with bits\n \\[\\begin{aligned} x \u0026amp;= x_\\text{hi} (2^a) \u0026#43; x_\\text{lo} \\end{aligned}\\]  So we can rewrite our original\n \\[\\begin{aligned} x \\mod y \u0026amp;= (x_\\text{hi}) (2^a) \u0026#43; x_\\text{lo} \\mod 2^a - b \\end{aligned}\\]  Note that\n \\[\\begin{aligned} 2^a \\mod (2^a - b) = b \\end{aligned}\\]  And we can mod at any time, so lets mod the  \\( 2^a \\)  .\nSo\n \\[\\begin{aligned} x \\mod y \u0026amp;= (x_\\text{hi}) (b) \u0026#43; x_\\text{lo} \\end{aligned}\\]  We can defer the mod to the last step in order to speed up our previous algorithm. So to better our acc pseudo earlier, we can do a divisionless mod.\nacc = 0 for i from 1 to n acc = acc + a[i] acc = acc * k divisionless mod return acc mod p For example,\nIf we want to calculate\n \\[\\begin{aligned} 100 \\mod 14 \\end{aligned}\\]  So  \\( 14 = 2^4 - 2 \\)  We can break the binary up to the bottom  \\( a \\)  bits,\n \\[\\begin{aligned} \u0026amp;= (110)(2) \u0026#43; (0100) \u0026amp;\\text{in binary} \\\\ \u0026amp;=(6)(2) \u0026#43; 4 \u0026amp;\\text{in decimal} \\\\ \u0026amp;= 16 \\end{aligned}\\]  Note that 16 is greater than 2 (the actual answer), but this intermediate result is congruent. So a final mod at the very end of the algorithm is needed to get the actual result.\nFile: Hash tricks pdf  "}),a.add({id:262,href:'/notes/CS152/CS152-lecture-20210621/',title:"CS152-lecture-20210621",section:"CS152",content:"Cryptographic hash functions #  Hashing takes a very large domain and maps it to a smaller codomain. For this to scale nicely,\n the hash function must be fast the outputs must be fairly random in distribution  A hash function can be defined as   \\( H : \\{0,1\\}^* \\to \\{0,1\\}^b \\)  , where  \\( b \\)  is the output block length.\nRecall: a set raised to an asterisk means the set of all strings made from that set.  We insist a cryptographic hash function has these properties:\n Preimage resistance: it should be non invertible. If we know an output, we shouldn\u0026rsquo;t be able to find an input that produces that output. Given  \\( y \\)  , it is hard to find any  \\( x \\)  such such that  \\( H(x) = y \\)  . This should just be really hard to find (near impossible). Note that since we have an infinite input, there definitely are multiple values that map to the same output value, but it should be near impossible to find them. Second preimage resistance: if we have another value, it should be hard to find another value that map to the same output. Given  \\( x_1 \\)  , it is hard to find  \\( x_2 \\neq x_1 \\)  such that  \\( H(x_1) = H(x_2) \\)   Collision resistance: it is hard to find any pair that cause the same output. It is hard to find  \\( x_2 \\neq x_1 \\)  such that  \\( H(x_1) = H(x_2) \\)   A nice to have property: behave like a public random function (random oracle).  Since hash algorithms aren\u0026rsquo;t invertible, they are useful for\n fingerprints message authenticity, if two the sender\u0026rsquo;s and receiver\u0026rsquo;s copy of the message being sent both hash to the same value, it can be considered authentic some file systems use hash functions to determine if a file has been changed  Some history for hash functions #  MD5\n Invented in the 90s block size of  \\( b = 128 \\)  bits MD5 is now broken, as pairs of input which produce the same output can be found rather easily now.  SHA-1\n Invented in the 90s block size of  \\( b = 160 \\)  bits broken, deprecated  SHA-2\n a fixed version of SHA-1, considered secure also called SHA-256, SHA-512 block size can be  \\( b = 256 \\)  or  \\( 512 \\)  , respectively.  SHA-3\n competition to find next best hash algorithm Same style contest as AES, winner was Keccak block size  \\( b = 256 \\)  or  \\( 512 \\)   considered secure  Telephone coin flipping #  Imagine a friend flipping a coin on the other end of a phone call. Your friend may think that you may cheat and have no way of knowing. In fact, you could cheat and your friend wouldn\u0026rsquo;t know.\nHow could they use a hash function to ensure no one is lying?\n let person  \\( A \\)  pick a random  \\( x \\)  , 128 bits  \\( A \\)  tells  \\( B \\)  the hash value  \\( H(x) \\)    \\( B \\)  chooses 0 or 1, and tells  \\( A \\)    \\( A \\)  tells  \\( B \\)  the value  \\( x \\)   consider the last bit of  \\( x \\)  to be the answer to the coin flip,  \\( 0 \\)  = heads and  \\( 1 \\)  = tails.  \\( B \\)  wins if last bit of  \\( x \\)  matches guess  By sending  \\( H(x) \\)  ,  \\( A \\)  is commiting to the input  \\( x \\)  . It is hard for  \\( B \\)  to find the input  \\( x \\)  when they only know the hash value  \\( H(x) \\)  , so it is hard for  \\( A \\)  or  \\( B \\)  to cheat.\nHash constructions #  Recall the signature of a cryptographic hash function,\n \\[ H : \\{0,1\\}^* \\to \\{0,1\\}^b \\]  where  \\( b \\)  is the block size.\nMerkle–Damgård construction #  Merkle–Damgård wikipedia  Since this function doesn\u0026rsquo;t take any key, you just feed it data and it returns the result of the hash function.\nThere are some initial constants that are concatenated with a chunk of the input, and that is fed into a compression function.\nThe output of this function is fed into the next compression function,\nThe last block must be padded to a multiple of the block size, in this case  \\( b = 512 \\)  . We will use our 10* padding algorithm for the last block - 64 bits. The length is concatenated onto the end\nThe output of the last call to the compression function  \\( f \\)  is the hash output, and we can think of  \\( f \\)  as a public random function.\nSo,  \\( f \\)  should be\n collision resistant preimage/second preimage resistant  Compression functions like  \\( f \\)  usually have\n lots of rounds mostly bitwise operation  Read more about the compression function in SHA-1 here.  MD5, SHA-1,2 use this same basic construction. Since these hash functions are considered broken.\nAlso, since the output is the last call to the hash function, it opens up the function to length extension attacks.\nKeccak (SHA-3) – sponge construction #  Read about the SHA-3 algorithm here.  The padding at the last block of the data is a 10*1 algorithm. The data must be a multiple of  \\( r \\)  bits.\nHow it works:\n starts by creating a block of  \\( r \\)  bits and  \\( c \\)  bits, where  \\( r \\)  is rate and  \\( c \\)  is capacity, initialized to 0  split data into multiples of  \\( r \\)   take the first block and xor it with current block This leaves the low  \\( c \\)  bits alone. the output of this goes through a permutation function  \\( P \\)   \\( P \\)  should be thought of as a public random permutation. the output of this is xor\u0026rsquo;d with the next  \\( r \\)  bits of the data, processed through  \\( P \\)  , and this continues This continues until the data is exhausted. The output is fed through  \\( P \\)  one last time, and the result is the high  \\( r \\)  bits of output.  Since the side of  \\( c \\)  bits is never touched, nobody has access to manipulating those  \\( c \\)  bits. The only way to manipulate the function is to change the bits in  \\( r \\)  , which is changing the data.\nIf our permutation doesn\u0026rsquo;t output  \\( r \\)  bits, it can be called a couple of times until we have  \\( r \\)  bits to return.\n The hash function\u0026rsquo;s speed is effected by how big  \\( r \\)  is (which is why we define  \\( r \\)  as rate). Each invocation of  \\( P \\)  consumes  \\( r \\)  bits.  \\( c \\)  sets the security. An attack will try to cause the  \\( c \\)  bits of the block to collide. A secure hash function must have a large enough  \\( c \\)  side to make collisions very unlikely. To be secure nowadays,  \\( c \\geq 256 \\)  .  Consider the last block,\n students often copy the entire data into a buffer that can hold the original data plus the buffered data  this is extremely inefficient, imagine a buffer that is 10GB.   we\u0026rsquo;ll never have to copy the first multiple of  \\( r \\)  bit  instead we\u0026rsquo;ll xor the first  \\( r \\)  bits into our chaining value, until we get to the last block for the tail, we\u0026rsquo;ll use a temporary buffer that is allocated on the stack, and copy the bytes from data then do the 10*1 padding. that way we don\u0026rsquo;t have to make a copy of the entire data    Later on, when we do a perm384 sponge construction, we will use values of\n  \\( r = 128 \\)  bits  \\( c = 256 \\)  bits  If we want our output to be  \\( b = 256 \\)  bits, we will have to call our permutation at the end twice (since our perm384 outputs 16 bytes at a time).\nSponge construction example #  Let  \\( P : \\{0,1\\}^6 \\to \\{0,1\\}^6 \\)  and our permutation function as  \\( P(x) = \\text{ROTL(x,1)} \\)  Lets define our rate and capacity as  \\( r = c = 3 \\)  .\nRecall that the sponge starts as all 0s, split into  \\( r \\)  and  \\( c \\)  bits:\nIf we want to hash the value\n110011 0101 we\u0026rsquo;ll need to pad the last block using our 10*1 algorithm,\n110011 010111 Note: we always have to add the two 1s when we pad, the 0s are the only thing that is optional.  Next we xor the first 3 bits of our data and xor it with our sponge,\nThen we send the sponge through the permutation,\nThis continues onto the next block of  \\( r \\)  bits:\nThis is the end of the absorbing phase. Next is the squeezing phase, this takes the first  \\( r \\)  bits and outputs it as the hash output. So if we want our output to be 6 bits, we\u0026rsquo;ll outout as many of the  \\( r \\)  bits as necessary. So we can output the first  \\( 3 \\)  bits, and then send it through the permutation again.\nNote: This isn\u0026rsquo;t the best example because the output of ROTL(111111) is indistinguishable from the input.  Reductions #  If you can write an algorithm that uses a subroutine, like\nASolver(a_inst): b_inst = convert_a_to_b(a_inst) b_sol = BSolver(b_inst) a_sol = convert_b_to_a(b_sol) return a_sol This means that ASolver reduces to BSolver, which means that\n \\[\\begin{aligned} \\exists \\text{BSolver} \\to \\exists \\text{ASolver} \\end{aligned}\\]  \u0026ldquo;If BSolver exists, then ASolver exists\u0026rdquo;\nThese implications do not make any assumptions about the true/false of their existence, it just merely shows an assertion should it exist.\nIt sometimes happens that we are interested in the constrapositive:\n \\[\\begin{aligned} \\neg \\exists \\text{ASolver} \\to \\neg \\exists \\text{BSolver} \\end{aligned}\\]  \u0026ldquo;If ASolver does not exist, then BSolver does not exist\u0026rdquo;\nFindMedian reduction example #  // arr could be in any order FindMedian(arr): arr' = Sort(arr) ans = arr'[len(arr') / 2] // assumes odd length arr  \\[\\begin{aligned} \\exists \\text{Sort} \u0026amp;\\to \\exists \\text{FindMedian} \\\\ \\neg \\exists \\text{FindMedian} \u0026amp;\\to \\neg \\exists \\text{Sort} \\end{aligned}\\]  This shows that FindMedian reduces to Sort.\nNote: If we say FindMedian doesn\u0026rsquo;t exist, it means that it doesn\u0026rsquo;t exist for all input.  Reductions in cryptography #  Reductions are important in cryptography because\n one of the ways that cryptographic protocols are proven secure is using these reductions  Since we could use a specific block cipher in an encryption mode, the security of the mode reduces to the security of the block cipher.\nCollisionFinder reduction example #  // returns x1 != x2 such that H(x1) = H(x2) CollisionFinder(H): x1 = random string x2 = 2ndPreimageFinder(H, x1) return (x1, x2)  \\[\\begin{aligned} \\exists \\text{2ndPreimageFinder} \u0026amp;\\to \\exists \\text{CollisionFinder} \\\\ \\neg \\exists \\text{CollisionFinder} \u0026amp;\\to \\neg \\exists \\text{2ndPreimageFinder} \\end{aligned}\\]  The contrapositive is a more interesting statement: \u0026ldquo;Collision resistance implies 2nd preimage resistance.\u0026rdquo;\nThere should be an infinite number of  \\( x_1 \\)  that map to  \\( x_2 \\)  , if the permutation is truly random. But the hash function may not be a perfect permutation, so you could argue to wrap the 2 lines of code in CollisionFinder in a loop. This would change the string and attempt to find new matches.\nPreimageFinder example #  CollisionFinder(H): do: x1 = random string y = H(x1) x2 = PreimageFinder(H, y) // H(x) = y while x2 = NULL or x1 = x2 return (x1, x2)  \\[\\begin{aligned} \\exists \\text{PreimageFinder} \u0026amp;\\to \\exists \\text{CollisionFinder} \\\\ \\neg \\exists \\text{CollisionFinder} \u0026amp;\\to \\neg \\exists \\text{PreimageFinder} \\end{aligned}\\]  \u0026ldquo;Collision resistance implies preimage resistance.\u0026rdquo;\nSo this displays that the ultimate goal should be collision resistance, because it will also cover preimage/2nd preimage resistance.\nUniversal hashing #  Compared to cryptographic hashes, which are over engineered for security, universal hashes are a lot more efficient. We don\u0026rsquo;t always need collision resistance and random looking output. What we sometimes need is a bound on the probability that the adversary could find a pair of inputs that produce the same output.\nWe can optimize universal hash functions to meet the goals needed.\nIts good to note that universal hashes are\n fast, and provable to have a small probability to find collisions  This last point when compared to cryptographic hash functions: cryptographic hash functions are overengineered and have so many heuristics that its harder to prove the probability of collisions.\nUniversal hash functions do not have as much guarantee of the crypgoraphic hash functions, but if all we need is the probabilistic property, then they are the way to go.\nAbstract epsilon universal hash example #  Let  \\( H \\)  be a collection of hash functions  \\( A \\to B \\)  , (from some domain  \\( A \\)  to a codomain  \\( B \\)  ).  \\( H \\)  is  \\( \\epsilon \\)  -almost-universal if the probability of winning the following game is  \\( \\leq \\epsilon \\)  .\nThe game is described as\n Adversary chooses  \\( a \\)  and  \\( b \\)  , where  \\( a \\neq b \\in A\\)  .  \\( h \\in H \\)  is chosen randomly. (Note, the adversary knows the functions in  \\( H \\)  but doesn\u0026rsquo;t know which one has been picked.)   Adversary wins if   \\( h(a) = h(b) \\)      Concrete universal hash example #  Consider this mapping  \\( Z_6 \\to Z_4 \\)  :\nThis is a small enough sample of objects that we can calculate the probability of winning the game:\n  \\( (0,1) = \\frac{1}{4} \\)    \\( (0,2) = 0 \\)    \\( (0,3) = 0 \\)    \\( (0,4) = 0 \\)    \\( (0,5) = \\frac{1}{4} \\)    We can continue to go through these pairs until we find a probability that is better than  \\( \\frac{1}{4} \\)  , for example\n  \\( (1,3) = \\frac{1}{2} \\)    \\( (2,4) = \\frac{1}{2} \\)    Since we can win this game, no more than  \\( \\frac{1}{2} \\)  the time, we consider it to be  \\( \\epsilon \\)  -almost-universal for  \\( \\epsilon = \\frac{1}{2} \\)  .\nSo the smaller the epsilon  \\( \\epsilon \\)  , the less probability of a collision.\n"}),a.add({id:263,href:'/notes/CS152/CS152-lecture-20210622/',title:"CS152-lecture-20210622",section:"CS152",content:"Authentication #  We can authenticate our messages using hashing.\nRecall that there are two types of hashing\nCryptographic hashing\n more secure preimage/2nd preimage/collision resistance slower   Universal hashing\n no guarantees collision is probability based faster    There are authentication schemes that are built using each of these 2 types of hashing.\nThe idea behind authentication is\n If Bob receives a message from Alice, Bob would like to trust that the message is  truly from Alice hasn\u0026rsquo;t been tampered with   Alice will generate a tag   \\( t \\)  (sometimes called a MAC) using a tag generator  \\[ t = \\text{TagGen(k, m)} \\]   Alice sends the message and the tag to Bob Bob can verify that the tag was generated with the specific key  \\( k \\)  and message  \\( m \\)    This verifies that Alice knows the key  \\( k \\)  , which gives Bob trust (because we\u0026rsquo;re assuming that only Alice and Bob have that secret key. It also verifies that the message has not been changed. This requires that the tag  \\( t \\)  cannot be generated without the key  \\( k \\)  .\nSecurity model #  We can think of the security model as a game, with an adversary that is trying to win. A security model is often setup as a game where the adversary wins if they reach a goal.\nWe will say that the adversary knows legitimate sequence of message/tag pairs, ie  \\( (m_1, t_1), (m_2, t_2), \\ldots, (m_q, t_q) \\)  where each pair obeys  \\[\\begin{aligned} t_i = \\text{TagGen}(k, m_i) \\end{aligned}\\]  The adversary must guess a new message/tag pair.\nNote: The message can be a reused message if a new tag is found, or a new message that evaluates to an old tag.  The adversary wins if they can create a \u0026ldquo;forgery\u0026rdquo;.\n \\[\\begin{aligned} t = \\text{TagGen}(k, m) \\end{aligned}\\]  The MAC is  \\( \\epsilon \\)  -secure if  \\( P(t = \\text{TagGen} (k,m)) \\leq \\epsilon \\)  .\nBuilding a tag generator #  Consider a function defined as\n \\[\\begin{aligned} \\text{HashMac}(k, m) = H(k || m) \\end{aligned}\\]  Where our domains are defined as\n the key  \\( k \\)  is  \\( \\{0,1\\}^a \\)   the message  \\( m \\)  is  \\( \\{0,1\\}^* \\)   the hash value function is a public cryptographic hash  \\( H : \\{0,1\\}^* \\to \\{0,1\\}^b \\)    So we can theorize that  \\( \\text{HashMac} \\)  is  \\( \\epsilon \\)  -secure where  \\( \\epsilon = \\frac{1}{2^b} \u0026#43; \\frac{n}{2^a} \\)  (plus brute force term).\nNote: An adversary always has the ability to try to brute force.  Let  \\( k \\)  be random, and the adversary knows legitimate pairs  \\( (m_1, t_1), (m_2, t_2), \\ldots, (m_q, t_q) \\)  . The adversary then attempts to guess a new pair  \\( (m,t) \\)  .\nWe want to calculate the probability  \\( P(H(k||m) = t) \\)  .\nWe can break this into 2 cases:\nCase 1 The adversary is reusing a message from their known pairs.\n\\[m \\in \\{m_1, \\ldots, m_q\\} \\]\nThis is bad strategy through because if \\(m = m_i\\) then \\(t \\neq t_i\\) because \\((m, t)\\). So,\n\\[ P(H(k||m) = t) = P(t_i \\neq t) = 0\\]\nNo probability that the forgery will pass the test.\n Case 2 The adversary picks a new message \\(m\\) where\n\\[m \\not \\in \\{m_1, \\ldots, m_q\\} \\]\nSo \\(H(k||m)\\) is uniformly distributed (never been given to the black box). So our probability\n\\[ P(H(k||m) = t) = \\frac{1}{2^b} \\]\n  The \u0026ldquo;bruce force term\u0026rdquo; is something like\n// n = number of attempts for i from 1 to n check if t[1] = HashMac(i, m[1]) which gives a probability of\n \\[\\begin{aligned} P(\\text{finding a key}) = \\frac{n}{2^a} \\end{aligned}\\]  Wegman-Carter MAC – Another tag generator construction #  Wegman-Carter MACing uses universal hashes.\nA message authentication algorithm that the tag generator takes\n a key  \\( (h,f) \\)  (a pair of functions)   \\( h \\)  is an almost-universal hash  \\( h: \\{0,1\\}^* \\to Z_p \\)    \\( f \\)  is a random function  \\( f: \\{0,1\\}^a \\to Z_p \\)     a nonce  \\( n \\)   a message  \\( m \\)    defined as\n \\[\\begin{aligned} \\text{WCMac}((h,f),n,m) = h(m) \u0026#43; f(n) \\end{aligned}\\]  So\n  \\( h(m) \\)  is a small representation of  \\( m \\)  (which may be really large). We will hash our data into a tag and then use that represent the large piece of data.  \\( f(n) \\)  encrypts  \\( h(m) \\)  (basically a shift cipher).  When Alice sends a message to Bob she includes the message, nonce, and tag. It is very important that the nonce never repeats.\nWe can theorize that  \\( \\text{WCMac} \\)  is  \\( \\epsilon \\)  -secure where  \\( \\epsilon = \\)  The adversary sees  \\( (m_1, n_1, t_1), \\ldots, (m_q, n_q, t_q) \\)  and guesses a new  \\( (m, n, t) \\)  tuple (not matching any prior tuples).\nWe want to compute the probability\n \\[\\begin{aligned} P(h(m) \u0026#43; f(n) = t) \\end{aligned}\\]  We have 2 cases\nCase 1 The adversary uses a new nonce:\n\\[n \\not \\in \\{n_1, \\ldots, n_q\\}\\]\nThen \\(f(n)\\) is uniform, so the probability that the adversary wins is\n\\[P(h(m) + f(n) = t) = \\frac{1}{p} \\]\n Case 2 The adversary uses an old nonce:\n\\[ n \\in \\{n_1, \\ldots, n_q\\} \\]\nThen the messages will not match, \\(m \\neq m_i \\). Notice that \\( t_i = h(m_i) + f(n_i) \\), so\n\\[ f(n) = h(m_i) + t_i \\]\nSo our probability that the adversary wins is\n\\[ P(h(m) + h(m_i) = t + t_i) \\leq \\epsilon \\]\nThis is considered an \u0026ldquo;almost \\(\\Delta\\) universal\u0026rdquo;.\n  So the probability that the adversary wins is  \\[P(\\text{adversary wins}) = \\max \\left( \\frac{1}{p}, \\epsilon \\right) \u0026#43; \\frac{n}{\\text{number of keys} } \\]  The most popular Wegman-Carter tag generator construction is defined as:\n \\[\\begin{aligned} \\text{PolyHash}_{k_i} (m) \u0026#43; \\text{AES}_{k_i}(n) \\end{aligned}\\]  Authenticated encryption #  In the past we would encrypt the plaintext into the ciphertext\n \\[\\begin{aligned} c = \\text{encrypt}(p) \\end{aligned}\\]  and generate a MAC tag\n \\[\\begin{aligned} t = \\text{MAC}(c) \\end{aligned}\\]  and send the pair  \\( (c, t) \\)  to the recipient.\nHowever, we want the cryptographic to define the security, not leave anything to user error. So, cryptographers have been cutting down on the amount of errors that can happen during authentication/encryption.\nFor example, what if the user\n uses the same key in the encryption and the MAC  if the user uses the same key when using CBC encryption and CBC-MAC, it opens up the user for an attack   mismatches the order (ie MAC then encrypt)  if the user authenticates the plaintext instead of the cipher, then it will have to be decrypted until it can tell if the plaintext was tampered with   reads memory into the CPU twice (encrypt, then authenticate)  not really a user choice, but can lead to an attack    Around the early 2000s, encryption/authentication methods were bundled to eliminate these user made issues. A set of goals were drawn up,\n safely use a single key make efficient (interleave encryption and authentication) encourage use of both encryption and authentication  GCM – Galois counter mode #  The most popular authentication encryption scheme is called GCM (Galois counter mode).\nSome high level pseudo:\n// k key // n nonce (12 bytes) // p plaintext // c ciphertext // t tag GCMEncrypt(k, n, p): hashkey = AES(k, \u0026lt;0\u0026gt;_128) mask = AES(k, n || \u0026lt;1\u0026gt;_32) // start block at n || \u0026lt;2\u0026gt;_32 c = AES_CTR(k, p) t = PolyHash(hashkey, c) xor mask return (c, t) So long as the nonce  \\( n \\)  changes with each message, there is guaranteed no overlap because\n Hash key generation uses \u0026lt;0\u0026gt;_128 as input to AES WC mask generation uses n || \u0026lt;1\u0026gt;_32 CTR encryption uses n || \u0026lt;2+\u0026gt;_32  So it is safe to use AES(k .. for all parts of the algorithm.\nThis algorithm is efficient because of Horner\u0026rsquo;s rule.\nwhile looping block by block: // doing some encryption c[i] = AES xor p[i] // do some authentication also acc += c[i] acc *= hashkey "}),a.add({id:264,href:'/notes/CS152/CS152-lecture-20210624/',title:"CS152-lecture-20210624",section:"CS152",content:"Asymmetric encryption #  A very useful type of encryption where encryption and decryption is done using key pairs, one public and one private. This can solve the key exchange problem, and also can be used to digitally sign messages.\nNow most cryptography is symmetric, only a small amount of CPU cycles are spent on asymmetric cryptography.\nRSA #  A revolutionary cryptosystem designed by Rivest, Shamir, Adleman at MIT in the 1970s.\nRead more on RSA  It is called a \u0026ldquo;cryptosystem\u0026rdquo; because it is a collection of algorithms that work together to produce cryptographic services. It provides a permutation that is\n easy to compute, given a public key, and hard to invert without the key  RSA can be used for encryption,\n  \\[\\begin{aligned} \\text{RSA Encryption} (x) = x^e \\mod n \\end{aligned}\\]  where  \\( 0 \u0026lt; x \u0026lt; n \\)  where  \\( n \\)  is the upper bound.\nThe public key is the pair  \\( (e, n) \\)  .\n \\[\\begin{aligned} \\text{RSA Decryption} (y) = y^d \\mod n \\end{aligned}\\]  The private key is the pair  \\( (d, n) \\)  . (Note that we haven\u0026rsquo;t defined what  \\( e,d,n \\)  are.)\nNote: The parameter x is usually plaintext made up of chars, so it is considered as the bit sequence for each ASCII value.  The individual\u0026rsquo;s public key is published for all to see. So anyone can encrypt something, using anyone\u0026rsquo;s public key. Nobody can decrypt it without the private key. This is very different from symmetric cryptography.\nRSA key generation (the magic) #  Key generation follows these steps:\n Choose random distinct primes  \\( p,q \\)  where  \\( |p| \\approx |q| \\)  .  Let  \\( n = pq \\)  , and  \\( \\phi(n) = (p-1)(q-1) \\)  (the totient of  \\( n \\)  ).   Choose  \\( e \\)  so that  \\( 1 \u0026lt; e \u0026lt; \\phi(n) \\)  and  \\( \\text{gcd} (e, \\phi(n)) = 1 \\)  . Let  \\( d = e^{-1} \\mod \\phi(n) \\)     The public key is  \\( (e, n) \\)   The private key is  \\( (d, n) \\)    \\( e \\)  is usually picked to be something that is efficient, something like  \\( 2^{16} \u0026#43; 1 \\)  , (sometimes  \\( 3 \\)  ). Recall that  \\( x^{-1} \\mod n \\)  exists if and only if  \\( \\text{gcd} (x, n) = 1 \\)  .  Note: Security increases the larger that \\(p,q\\) are. These values are usually around 2000-8000 bits long, depending on the time needed for security.  The best attack on RSA is to factor  \\( n \\)  into  \\( p \\)  and  \\( q \\)  and generate  \\( d \\)  .\nKey gen and encryption example #  Key generation #   \\[\\begin{aligned} p \u0026amp;= 47 \u0026amp;\\text{step 1}\\\\ q \u0026amp;= 11 \\\\ n \u0026amp;= pq \\\\ \u0026amp;= 517 \\\\ \\phi(n) \u0026amp;= (p-1)(q-1) \\\\ \u0026amp;= 460 \\\\ e \u0026amp;= 3 \u0026amp;\\text{step 2} \\\\ d = e^{-1} \\mod \\phi(n) \u0026amp;= 307 \u0026amp;\\text{step 3} \\\\ \\end{aligned}\\]  Note\n So our public key is  \\( (e, n) = (3, 517) \\)   Our private key is  \\( (d, n) = (307, 517) \\)   When picking  \\( e \\)  , check  \\( \\text{gcd} (e, \\phi(n)) = 1 \\)  . To find the multiplicative inverse, we can use something like wolfram alpha: \u0026ldquo;inverse of 3 mod 460\u0026rdquo;, or you can use the egcd algorithm.  Encryption #  Lets encrypt the value  \\( 416 \\)  :\n \\[\\begin{aligned} 416^3 \\mod 517 = 80 \\end{aligned}\\]  Decryption #  To decrypt our ciphertext value  \\( 80 \\)  :\n \\[\\begin{aligned} 80^{307} \\mod 517 = 416 \\end{aligned}\\]  Why RSA works #  Euler\u0026rsquo;s theorem: When \\(\\text{gcd}(a, n) = 1 \\) then \\[a^{\\phi(n)} \\mod n = 1\\]  We want to show that if we have a cipher text  \\( y \\)  , and we raise it to the decryption power  \\( d \\)  (all  \\( \\mod n \\)  ) equals our original plaintext  \\( x \\)  .\n \\[\\begin{aligned} y^d \u0026amp;= (x^e)^d \\\\ \u0026amp;= x^{ed} \u0026amp;\u0026amp;\\text{aside } \\\\ \u0026amp;\u0026amp; ed \\mod \\phi(n) \u0026amp;= 1\\\\ \u0026amp;\u0026amp; ed \u0026amp;= 1 \u0026#43; k \\phi(n) \\\\ \u0026amp;= x^{1 \u0026#43; k \\phi(n)} \\\\ \u0026amp;= (x)(x)^{k \\phi(n)} \\\\ \u0026amp;= (x)(x^{\\phi(n)})^k \u0026amp;\u0026amp;\\text{use Euler\u0026#39;s theorem} \\\\ \u0026amp;= (x)(1)^k \\\\ \u0026amp;= x \\end{aligned}\\]  Practicality, algorithms on large numbers #  During key generation and encryption/decryption, we see a lot of exponentiation in the calculation. So a proper RSA implementation must use the most efficient algorithms.\nEfficient algorithms\n run in time proportional to length (number of bits used) rather than the value use basic operations: add, multiply, divide exponentiation, when implemented naively can be proportional to the value of the exponent. So that must be taken into consideration multiplicative inverse, when implemented naively can be proportional to the value of the modulus, rather than the length. finding primes, can be implemented poorly when testing to see if the number is indeed prime  Finding large primes #  Since finding large primes is the first step in RSA key generation, we need a way of picking large prime numbers.\nIt is fairly easy to prove that the number of primes is infinite.\nTheorem: Primes are infinite.  Small sketch proof:\n Assume that there are not an infinite number of primes (we\u0026rsquo;ll prove by contradiction) Let  \\( P_1, P_2, \\ldots, P_r \\)  be the list of all primes Let  \\( n = P_1 \\cdot P_2 \\cdot \\cdots \\cdot P_r \\)    \\( n \u0026#43; 1 \\)  is bigger than every prime number in the list, and so is not prime Let  \\( P \\)  be a prime divisor of  \\( n \u0026#43; 1 \\)    \\( n \\)  and  \\( n \u0026#43; 1 \\)  are both multiples of  \\( P \\)   this is impossible, so there is an infinite number of primes.  we can\u0026rsquo;t have 2 consecutive numbers be multiples of the same  \\( P \\)  , they must be at least  \\( P \\)  apart    So knowing this, we know that there are prime numbers still even when we\u0026rsquo;re up around 4000 bit long numbers. There actually is the fact that about  \\( \\frac{1}{n} \\)  of  \\( n \\)  -bit numbers are prime (Density of primes).\nHow to find them #  Number theory tells us that the probability\n \\[\\begin{aligned} P(x^{\\frac{P-1}{2}} \\mod P = 1 \\text{ or } P - 1 \\mid \\text{P is prime}) \u0026amp;= 1 \\\\ P(x^{\\frac{P-1}{2}} \\mod P = 1 \\text{ or } P - 1 \\mid \\text{P is composite}) \u0026amp;\\leq \\frac{1}{2} \\end{aligned}\\]  So for example, lets choose  \\( q \\)  random  \\( x \\)  in the range  \\( 0 \u0026lt; x \u0026lt; P \\)  , and calculate  \\( x^{\\frac{P-1}{2}} \\mod P \\)  for each.\n \\[\\begin{aligned} P(\\text{all are 1 or } P - 1 \\mid \\text{P is prime}) \u0026amp;= 1 \\\\ P(\\text{all are 1 or } P - 1 \\mid \\text{P is composite}) \u0026amp;= \\left( \\frac{1}{2} \\right)^q \\\\ \\end{aligned}\\]  This is a probabilistic algorithm, meaning that there is a probability that the algorithm is incorrect.\nGenerating prime number algorithm #  // b number of bits // c confidence level // returns b-bit prime with false positive rate of 1/2^c gen_prime(b, c): do: p = random odd number (b-bits long) while (!is_prime(p, c)) return p is_prime(p, c): for i from 1 to c: x = random where 0 \u0026lt; x \u0026lt; p if x^{(p-1)/2} mod p is not 1 or p - 1: return false return true (and saw at least 1 \u0026quot;P-1\u0026quot;) This algorithm fails when checking Carmichael numbers (because they pass this test but are composite). So the last return true is only really true if we\u0026rsquo;ve seen at least one  \\( P-1 \\)  value.\nThe line with the calculation of  \\( x^{\\frac{p-1}{2}} \\mod p \\)  is the most expensive computationally. The amount of times that calculation will happen is around  \\( \\frac{1}{n} \\)  where the numbers you\u0026rsquo;re checking are  \\( n \\)  -bits long. There is an expected of 2 iterations to that calculation on a failure. So, is_prime should be called about about  \\( 2n \\)  times. The actual exponent  \\( \\frac{P-1}{2} \\)  is about  \\( n \\)  bits long, and so there is about  \\( \\frac{3}{2}n \\)  multiplications.\nSo if we have a 4000 bit long prime we\u0026rsquo;re looking for,\n \\[\\begin{aligned} 8000 \\cdot 6000 = 48,000,000 \\text{ multiplications} \\end{aligned}\\]  where each of those multiplications is about 4000 bits long.\nOn the next programming assignment #  The last 2 assignments have been combined into 1, and will be spread over the next 2 weeks.\nSince the number one use of asymmetric cryptography is to establish a key to use in symmetric cryptography (the idea of hybrid cryptography), we will implement a key negotiation.\nWe will use\n perm384hash256, and BIGNUM a big number library part of OpenSSL  BIGNUM #   File: BIGNUM notes We will be using OpenSSL 1.1.1 https://www.openssl.org/docs/man1.1.1/man3/ https://commondatastorage.googleapis.com/chromium-boringssl-docs/bn.h.html   A BIGNUM example for calculating gcd:\n#include \u0026lt;openssl/bn.h\u0026gt;#include \u0026lt;stdio.h\u0026gt; void gcd(BIGNUM *r, BIGNUM *a, BIGNUM *b, BN_CTX *ctx) { // create BIGNUM pointers  BIGNUM * c = BN_new(); BIGNUM * d = BN_new(); BIGNUM * td = BN_new(); // can\u0026#39;t use assignment operator =, must use BN_copy  BN_copy(c, a); BN_copy(d, b); // while d isn\u0026#39;t 0  while (!BN_is_zero(d)) { BN_copy(td, d); // td = d  BN_mod(d, c, td, ctx); // d = c % td  BN_copy(c, td); // c = td  } // Copy results  BN_copy(r, c); // free allocated BIGNUMs  BN_free(c); BN_free(d); BN_free(td); } int main() { // BIGNUM context  BN_CTX *ctx = BN_CTX_new(); // two 800 bit numbers, a and b  unsigned char a[20] = {0xff,}; unsigned char b[20] = {0xee,}; // convert binary to BIGNUM  BIGNUM *bna = BN_bin2bn(a, sizeof(a), NULL); BIGNUM *bnb = BN_bin2bn(b, sizeof(b), NULL); // two BIGNUMs for comparison  BIGNUM *r_me = BN_new(); BIGNUM *r_ssl = BN_new(); // gcd(a, b)  gcd(r_me, bna, bnb, ctx); BN_gcd(r_ssl, bna, bnb, ctx); // check if they\u0026#39;re equal  if (BN_cmp(r_ssl, r_me) != 0) printf(\u0026#34;Not equal!\\n\u0026#34;); // convert BIGNUMs to strings  char *as = BN_bn2dec(bna); char *bs = BN_bn2dec(bnb); char *rs = BN_bn2dec(r_me); printf(\u0026#34;GCD of\\n%s\\nand\\n%s\\nis\\n%s\\n\u0026#34;,as,bs,rs); return 0; } Some example output:\nGCD of 1455792646560079078679451688838485039110401556480 and 1358739803456073806767488242915919369836374786048 is 97052843104005271911963445922565669274026770432 "}),a.add({id:265,href:'/notes/CS152/CS152-lecture-20210626/',title:"CS152-lecture-20210626",section:"CS152",content:"Intro to asymmetric encryption #  Until now, we\u0026rsquo;ve been using symmetric cryptography. This means that both Alice and Bob are sharing a secret key.\nIn asymmetric cryptography, Alice and Bob have their own secret keys. They also both have public keys.\nBoth public and private keys are created at the same time.\nWe want to provide these services using asymmetric cryptography:\nEncryption\n Alice encrypts a message to be sent to Bob using Bob\u0026rsquo;s public key    \\[\\begin{aligned} A \\to \\text{Encrypt}(B_\\text{pub}, x) \\to B \\end{aligned}\\]   Bob decrypts this message using his private key   Authentication\n Alice can authenticate the message being sent to Bob by signing it with her private key   \\[\\begin{aligned} A \\to \\text{Sign}(A_\\text{pub}, x) \\to B \\end{aligned}\\]   Only Alice\u0026rsquo;s public key can unlock it, so it can be verified to be from Alice (because Alice is the only person with her private key).    Pros/cons #  For asymmetric cryptography:\nPros\n \\(O(n)\\) key pairs needed  Cons\n computational cost, ~1000 times more costly   For symmetric cryptography:\nPros\n faster, less computationally expensive operations  Cons\n \\(O(n^2)\\) key pairs needed    In the real world, we first\n use asymmetric cryptography to establish a shared key use symmetric cryptography to encrypt the bulk of the data  This ends up getting the best of both worlds.\nDiscrete logarithm problem #  A logarithm using a modulus:\nGiven  \\( x,g, \\)  and prime number  \\( p \\)   \\[\\begin{aligned} x \u0026amp;= g^y \\mod p \\\\ \\end{aligned}\\]  This is asking \u0026ldquo; \\( g \\)  to what power  \\( \\mod p \\)  will give you  \\( x \\)  ?\n \\[\\begin{aligned} \\log x = y \\end{aligned}\\]  All of the calculation is done  \\( \\mod p \\)  , which makes the question a little harder than the normal logarithmic problem. Because for each time  \\( y \\)  is increased, the output is pretty much randomly distributed because it is wrapping around the ring when  \\( \\mod p\\)  is calculated.\nRSA problem #  Given  \\( x,e, \\)  and  \\( p \\)  , we need to find  \\( y \\)  :\n \\[\\begin{aligned} x \u0026amp;= y^e \\mod p \\end{aligned}\\]  Because of the  \\( \\mod p \\)  , this makes finding  \\( y \\)  really difficult.\nExponentiation #  Since we are working on algorithms that work on huge numbers, we need to have a way to efficiently handle large exponentiation calculations.\nFor example if we\u0026rsquo;re calculating  \\( x^y \\)  , we may naively write an algorithm like\nacc = 1 for i from 1 to y acc *= x This is sufficient for most applications, but it starts to break down on very large numbers. The loop occurs to an exponential number of times relative to the number of bits in  \\( y \\)  .\nIf  \\( y \\)  is 32 bits long, it may take a few minutes to calculate the result. If  \\( y \\)  is 64 bits long, it will takes years to calculate the result.\nWe are working with  \\( y \\)  values around 2000-8000 bits long, the universe hasn\u0026rsquo;t been around long enough to calculate that result.\nInstead, we should write our algorithm to be based on the length of the value, not based on the value itself.\nObserve,\n \\[\\begin{aligned} (x^y)^2 \u0026amp;= x^{2y} = x^{y || 0} \\end{aligned}\\]  If we use the binary representation of  \\( y \\)  , to multiply by 2 we simple to a left shift 1 (concatenate a 0 on the end).\n \\[\\begin{aligned} (x^y)^2 x \u0026amp;= x^{2y \u0026#43; 1} = x^{y || 1} \\end{aligned}\\]  Notice that if we want to multiply by 2 and add 1 we can simply concatenate a 1 onto the end of  \\( y \\)  (so left shift then flip rightmost bit). This gives us a way to programatically create an exponent.\nAt any point, if we want to append a 0 we just square the number, if we want to append a 1 square then multiply by the base. For example, if we are calculating  \\( 3^6 \\)  :\n \\[\\begin{aligned} 3^6 \u0026amp;= 3^\\text{0b0} \\\\ \u0026amp;= 3^{\\text{0b}01} \u0026amp;\\text{square and mult} \\\\ \u0026amp;= 3^{\\text{0b}011} \u0026amp;\\text{square and mult} \\\\ \u0026amp;= 3^{\\text{0b}0110} \u0026amp;\\text{square} \\end{aligned}\\]  This can be expressed as an algorithm,\n// calculate x^y pow(x, y) let y = y1, y2, ..., yn where yi in {0,1} acc = 1 for i from 1 to n // always square acc = acc * acc // if rightmost bit is on (odd) if yi == 1 acc = acc * x return acc This is a  \\( O(n) \\)  operation, where  \\( n \\)  is the bit length of our exponent. This is good because we are looping relative to how many bits the number is represented in.\nAn example #  Lets calculate  \\( (4)^{11} \\)  :\n first get the exponent in binary:  \\( 11 = \\text{0b} 1011 \\)   start at the multiplicative identity:  \\( 1 \\)   \\[\\begin{aligned} 4^0 = 4^{\\text{0b}0} = 1 \\end{aligned}\\]   when we insert the first  \\( 1 \\)  , we square then multiply by base  \\[\\begin{aligned} 4^{\\text{0b}01} = 1^2 \\cdot 4 \\end{aligned}\\]   we are now inserting a  \\( 0 \\)  , so we just square the accumulator  \\[\\begin{aligned} 4^{\\text{0b}010} \u0026amp;= (1^2 \\cdot 4)^2 \\end{aligned}\\]   insert a 1, so square and multiply by base  \\[\\begin{aligned} 4^{\\text{0b}0101} \u0026amp;= ((1^2 \\cdot 4)^2)^2 \\cdot 4 \\end{aligned}\\]   insert last 1, square and multiply  \\[\\begin{aligned} 4^{\\text{0b}01011} \u0026amp;= (((1^2 \\cdot 4)^2)^2 \\cdot 4)^2 \\cdot 4 \\end{aligned}\\]    GCD – greatest common divisor #  An algorithm developed by Euclid in 300 BC.\nWhen given a pair of integers, it returns the largest number that goes into both integers. For example,\n \\[\\begin{aligned} \\text{GCD}(10, 15) = 5 \\end{aligned}\\]  Note that\n \\[\\begin{aligned} \\text{GCD}(0, x) = x \\end{aligned}\\]  The basis of the algorithm:\n Let  \\( d \\)  be a divisor of  \\( x \\)  and  \\( y \\)   compute  \\( x \\mod y \\)   \\[\\begin{aligned} x \u0026amp;= yq \u0026#43; r \u0026amp;\u0026amp;\\text{where } 0 \\leq r \\leq y \\end{aligned}\\]   \\( x \\)  is a multiple of  \\( d \\)  , and  \\( yq \\)  is also a multiple of  \\( d \\)  . Since this is an equality,  \\( r \\)  must also be a multiple of  \\( d \\)  . So if  \\( d | x \\)  and  \\( d | y \\)  then,  \\( d | r \\)  .  The algorithm in its recursive form is defined as\n \\[\\begin{aligned} \\text{GCD}(x, y) = \\text{GCD}(y, x \\mod y) \\end{aligned}\\]  Our basecase for implementation will be the previously given  \\( \\text{GCD} (0, x) = x \\)  .\nIt can also be implemented using a loop:\ngcd(x, y): while y != 0: t = y y = x % y x = y return x Recall that we want our algorithms to run in a logarithmic time (time relative to the amount of bits to represent the number).\n Theorem:  \\( \\text{GCD} (x,y) \\)  is  \\( O(\\log(\\max(x,y))) \\)  .\n A lemma:\nIf  \\( a \u0026gt; b \\)  , then  \\( a \\mod b \u0026lt; \\frac{a}{2} \\)  .\nCase when \\(b \\leq \\frac{a}{2}\\): \\[ a \\mod b \u0026lt; b \\leq \\frac{a}{2} \\]  Case when \\(b \u0026gt; \\frac{a}{2}\\): \\[ a \\mod b \u0026lt; \\frac{a}{2} \\]   So on each mod, the numbers are swapped and the bigger number is cut in at least half. So we have a logarithmic number of iterations to reach the result.\nExamples #   \\[\\begin{aligned} \\text{GCD}(32,30) \u0026amp;= \\text{GCD}(30, 32 \\mod 30) \\\\ \u0026amp;= \\text{GCD}(30, 2) \\\\ \u0026amp;= \\text{GCD}(2, 30 \\mod 2) \\\\ \u0026amp;= \\text{GCD}(2, 0) \\\\ \u0026amp;= 2 \\end{aligned}\\]   \\[\\begin{aligned} \\text{GCD}(55, 33) \u0026amp;= \\text{GCD}(33, 55 \\mod 33) \\\\ \u0026amp;= \\text{GCD}(33, 22) \\\\ \u0026amp;= \\text{GCD}(22, 33 \\mod 22) \\\\ \u0026amp;= \\text{GCD}(22, 11) \\\\ \u0026amp;= \\text{GCD}(11, 22 \\mod 11) \\\\ \u0026amp;= \\text{GCD}(11, 0) \\\\ \u0026amp;= 11 \\end{aligned}\\]  Extended Euclidean algorithm #   \\[\\begin{aligned} \\text{EGCD}(x, y) \\to (a,b) \u0026amp;\u0026amp; \\text{where } ax \u0026#43; by = \\text{GCD}(x, y) \\end{aligned}\\]  For example\n \\[\\begin{aligned} \\text{EGCD}(55, 33) \u0026amp;= \\text{EGCD}(33, 55 \\mod 33) \\\\ \u0026amp;= \\text{EGCD}(33, 22 = 55 \\cdot 1 \u0026#43; 33 \\cdot -1) \\\\ \u0026amp;= \\text{EGCD}(22, 33 \\mod 22) \\\\ \u0026amp;= \\text{EGCD}(22, 11 = 33 \\cdot 1 \u0026#43; (55 \\cdot 1 \u0026#43; 33 \\cdot -1)) \\\\ \u0026amp;= \\text{EGCD}(22, 11 = 55 \\cdot -1 \u0026#43; 33 \\cdot 2) \\\\ \u0026amp;= \\text{EGCD}(11, 22 \\mod 11) \\\\ \u0026amp;= \\text{EGCD}(11, 0 = 22 \\cdot 1 \u0026#43; 11 \\cdot -2) \\\\ \u0026amp;= \\text{EGCD}(11, 0 = (55 \\cdot 1 \u0026#43; 33 \\cdot -1) \u0026#43; (55 \\cdot 1 \u0026#43; 33 \\cdot 2)\\cdot -2) \\\\ \u0026amp;= \\text{EGCD}(11, 0 = 55 \\cdot 3 \u0026#43; 33 \\cdot -5) \\\\ \u0026amp;= 11 \\\\ a \u0026amp;= -1 \\\\ b \u0026amp;= 2 \\end{aligned}\\]  Note that\n \\[\\begin{aligned} 55 \u0026amp;= 33 \\cdot 1 \u0026#43; 22 \\\\ 22 \u0026amp;= 55 \\cdot 1 \u0026#43; 33 \\cdot -1 \\\\ 11 \u0026amp;= 55 \\cdot -1 \u0026#43; 33 \\cdot 2 \\\\ 0 \u0026amp;= 55 \\cdot 3 \u0026#43; 33 \\cdot -5 \\end{aligned}\\]  Multiplicative inverses #  We can use our GCD algorithms from before to find the inverse of a value.\nLets say we\u0026rsquo;re looking for the inverse of  \\( 5 \\mod 31 \\)  , if use the extended GCD algorithm we\u0026rsquo;ll get back a linear combination.\n \\[\\begin{aligned} 5^{-1} \\mod 31 \u0026amp;= \\text{EGCD}(31, 5) \\\\ \u0026amp;= 31a \u0026#43; 5b = 1 \\\\ \u0026amp;= (31a \u0026#43; 5b) \\mod 31 = 1 \\mod 31 \\\\ \u0026amp;= 5b \\mod 31 = 1 \\end{aligned}\\]  So  \\( 5b \\mod 31 = 1 \\)  means  \\( b \\)  is the inverse of  \\( 5 \\mod 31 \\)  .\nNote that if  \\( b \u0026lt; 0 \\)  , we add  \\( 31 \\)  to it until positive.\nExample 1 #  Lets actually find the multiplicative inverse of  \\( 5 \\mod 31 \\)  :\n \\[\\begin{aligned} \\text{EGCD}(31, 5) \u0026amp;= \\text{EGCD}(5, 31 \\mod 5) \\\\ \u0026amp;= \\text{EGCD}(31, 1 = 1(31) \u0026#43; -6(5)) \\\\ \u0026amp;= \\text{EGCD}(1, 5 \\mod 1) \\\\ \u0026amp;= \\text{EGCD}(1, 0 = 1(5) \u0026#43; -5(1) \\end{aligned}\\]  So since  \\( b \\)  is negative, we add to it until its positive\n \\[\\begin{aligned} 1 \u0026amp;= 1(31) \u0026#43; -6(5) \\mod 31 \\\\ \u0026amp;= -6(5) \\mod 31 \\\\ \u0026amp;= 25(5) \\mod 31 \\end{aligned}\\]  So\n \\[\\begin{aligned} 5^{-1} \\mod 31 = 25 \\end{aligned}\\]  Example 2 #  Lets find the multiplicative inverse of  \\( 7 \\mod 31 \\)  :\n \\[\\begin{aligned} \\text{EGCD}(31, 7) \u0026amp;= \\text{EGCD}(7, 31 \\mod 7) \\\\ \u0026amp;= \\text{EGCD}(7, 3 = 1(31) \u0026#43; -4(7)) \\\\ \u0026amp;= \\text{EGCD}(3, 7 \\mod 3) \\\\ \u0026amp;= \\text{EGCD}(3, 1 = 1(7) \u0026#43; -2(3)) \\\\ \u0026amp;= \\text{EGCD}(3, 1 = 1(7) \u0026#43; -2(1(31) \u0026#43; -4(7))) \\\\ \u0026amp;= \\text{EGCD}(3, 1 = -2(31) \u0026#43; 9(7)) \\end{aligned}\\]  As soon as we have the number 1 as a linear combination of our original numbers, ie\n \\[\\begin{aligned} 1 = -2(31) \u0026#43; 9(7) \\end{aligned}\\]  we can find the inverse.\n \\[\\begin{aligned} 1 \u0026amp;= -2(31) \u0026#43; 9(7) \\mod 31 \\\\ \u0026amp;= 9(7) \\mod 31 \\end{aligned}\\]  So our multiplicative inverse of  \\( 7 \\mod 31 \\)  is  \\( 9 \\)  .\n"}),a.add({id:266,href:'/notes/CS152/CS152-lecture-20210627/',title:"CS152-lecture-20210627",section:"CS152",content:"Problems with RSA #  RSA has some problems, namely\n RSA can be distinguished easily  a black box is either a RSA encryption scheme or random bits it is easy to distinguish between these 2 worlds by sending a 0 bit (or a 1) to the box and see what comes back, and so in the RSA box   \\[ \\begin{aligned} 0^e = 0 \\end{aligned} \\]   if we restrict the numbers to large inputs then this becomes better   RSA leaks information  \\[\\begin{aligned} y_1 = \\text{RSA}(x_1) \\\\ y_2 = \\text{RSA}(x_2) \\end{aligned}\\]  If  \\( y_1 = y_2 \\)  then  \\( x_1 = x_2 \\)  . The information that is leaked is whether the plaintexts are the same. RSA is \u0026ldquo;malleable\u0026rdquo;. This means that changes to the ciphertext have predictable results on the plaintext.  \\[\\begin{aligned} y = x^e \\mod n \\end{aligned}\\]  If we multiply  \\( y \\)  by  \\( 2^e \\)  and decrypt (all  \\( \\mod n\\)  ):  \\[\\begin{aligned} (y \\cdot 2^e)^d \u0026amp;= (x^e 2^e)^d \\\\ \u0026amp;= ((2x)^e)^d \\\\ \u0026amp;= 2x \\end{aligned}\\]  This is ultimately fixed by authentication.  So, in summary the main problems are:\n There is no randomization in RSA. Encrypting the same plaintext twice should yield different ciphertexts. The ciphertext is the result of math applied directly on the plaintext.  OAEP #  So the solution to these problems is the OAEP (optimal asymmetric encryption padding) padding scheme.\nThe structure of this padding is a Feistel structure.\nStart by padding the rightside of the plaintext with 0s, then random bits:\nThis goes into a Feistel structure like so:\n Since this is a Feistel structure, it is invertible. The function  \\( H \\)  is a MGF (mask generation function). This is similar to the sponge construction with extended output (squeeze). The random portion is around 256 bits, likely something that has never been seen before (this fixes our main RSA problem). The 0 padding is around 64 bits  \\( x \\)  can be up to around 1700 bits The entire output should be indistinguishable from random  We can utilize this in our algorithm when encrypting using RSA\nencrypt(x): x' = OAEP(x) return (x')^e mod n When decrypting\n We decrypt using the textbook RSA, then de-pad using the inverse OAEP function  Authentication with RSA #  Authentication hashes when using asymmetric cryptography are called signatures.\nWhen Alice sends Bob an encrypted message, she sends both the data and the signature.\nTo sign the data, Alice locks it with her private key,\n \\[\\begin{aligned} \\text{sign}(x) := x^d \\mod n \\end{aligned}\\]  Bob receives the data and the signature, and verifies that the message is in fact from Alice by unlocking it with Alice\u0026rsquo;s public key,\n \\[\\begin{aligned} \\text{verify}(\\text{sig}) := \\text{sig}^e \\mod n == x \\end{aligned}\\]  Since the goal in the RSA problem is\n given  \\( x^e \\mod n, e, \\)  and  \\( n \\)  , it is hard to find  \\( x \\)   implies that  \\( x^d \\mod n \\)  is hard to find hard without  \\( d \\)    In order for the adversary to create a forgery, she would have to\n calculate  \\( x^d \\mod n \\)  without  \\( d \\)  , which is really hard or find a collision in the hash function used when signing  The problem here is that our data has to be less that  \\( n \\)  , so we will solve this by instead taking a hash of the data and signing that.\nSigning with a cryptographic hash #  Recall that a cryptographic hash is\n collision resistant preimage resistant 2nd preimage resistant  So we can use a hash function to hash our data, and then we will actually sign that.\n \\[\\begin{aligned} \\text{sign}(x) := H(x)^d \\mod n \\end{aligned}\\]  When we verify, we have to hash the data ourselves and check if its equal\n \\[\\begin{aligned} \\text{verify}(x, \\text{sig}) := \\text{sig}^e \\mod n == H(x) \\end{aligned}\\]  Diffie-Hellman key exchange #  Diffie-Hellman wiki entry  This solves the problem of actually getting the shared key to the other party. The Diffie-Hellman key exchange is setup in a way that even if the adversary is listening to the communication between Alice and Bob, they still have no way of calculating the actual shared key from the information divulged during eavesdropping.\nThis is based on the logarithm problem, for example when given  \\( 2 \\)  and  \\( 2^x \\)  , find  \\( x \\)  .\nWe can actually do this using a binary search technique. Since each time our search space is cut in half, it ends up being an algorithm to the order of  \\( O(\\log x) \\)  .\nIf we throw in a modulus on the logarithm, we cannot use this same binary search technique. This is called the discrete logarithm problem. This is what the Diffie-Hellman exchange is based on.\n Discrete logarithm problem:\nGiven  \\( g,n \\)  and  \\( g^x \\mod n \\)  , find  \\( x \\)  .\n If  \\( g^x \\)  is large enough it will wrap around the modulus ring multiple times, and there will be no way to hone in on the target like in our binary search technique before. The modulus  \\( n \\)  is usually thousands of bits long.\nHow the exchange works #  Our goal is to establish a secret in plain sight.\nWhat is known is\n a base  \\( g \\)   a modulus  \\( n \\)     Alice chooses a random value  \\( x \\)  in the range  \\( 0 \u0026lt; x \u0026lt; n \\)  . Alice sends  \\( g^x \\mod n \\)  to Bob Bob chooses a random value  \\( y \\)  in the range  \\( 0 \u0026lt; y \u0026lt; n \\)  . Bob sends  \\( g^y \\mod n \\)  to Alice  Alice knows\n \\(x\\), \\(g^y\\)   Eve knows\n \\(g^x,g^y\\)   Bob knows\n \\(y,g^x\\)    So the shared secret is  \\( g^{xy} \\mod n \\)  . Eve cannot compute this.\nAlice computes the secret by raising to her known \\(x\\) \\[ (g^y)^x = g^{xy} \\]  Bob computes the secret by raising to his known \\(y\\) \\[ (g^x)^y = g^{xy} \\]   This situation is safe against the passive adversary (just eavesdropping).\nMan in the middle attack on the key exchange #  Eve can manipulate the messages in the middle between Alice and Bob\u0026rsquo;s communication.\n Eve receieves  \\( g^x \\)  from Alice Eve sends  \\( g^{x\u0026#39;} \\)  to Bob, and receieves  \\( g^y \\)   Eve sends  \\( g^{y\u0026#39;} \\)  to Alice  Alice has now set up a key with Alice and a key with Bob. In this situation Eve is considered an active adversary.\nWe can solve this problem using authentication.\n"}),a.add({id:267,href:'/notes/CS152/CS152-lecture-20210629/',title:"CS152-lecture-20210629",section:"CS152",content:"Alternatives to RSA #  RSA was invented in the 1970s and patented it. Alternatives came about because of the licensing fees that RSA used to require.\nRecall that the RSA problem is\n Given   \\( x^e \\mod n \\)  ,  \\( e \\)  , and  \\( n \\)  , find  \\( x \\)  . This is hard, and thats why RSA is secure.  Recall the related problem, the discrete logarithm problem\n Given  \\( x^y \\mod n \\)  ,  \\( x \\)  , and  \\( n \\)  , find  \\( y \\)  . This is a similar problem, and it is also hard to find  \\( y \\)  .  In the 1980s cryptography started to be based on groups and discrete log. The discrete logarithm problem is defined over a group.\nThis is usually based on the multiplicative prime group  \\( Z^*_p \\)  , where\n the identity is the number 1 the operation is multiplication  \\( \\mod p \\)    Note: The prime number has increased because of security over time, where now \\(p\\) may be 2000-4000 bits long. In response to the larger and larger modulus, there is a group called an elliptic curve group, where the values are around 200-500 bits long.  How to encrypt using a group – ElGamal encryption #  ElGamal, a researcher from Stamford in the 80s, published a paper that defined a signature scheme and an encryption scheme based on the discrete logarithm problem. Read more.\nThe encryption scheme can be thought of as a Diffie-Hellman key exchange over time.\n Alice lets  \\( g^x \\)  be their public key, where  \\( x \\)  is private Later, Bob wants to encrypt something and send it to Alice, so he sends her  \\( g^y \\)  and also the encrypted message multiplied by the key,  \\( km \\)   The key is  \\( g^{xy} \\)     To decrypt,  \\( m = k^{-1}(km) \\mod p\\)    In summary\n Key generation phase  define  \\( g,p \\)   define secret exponent  \\( d \\)   public key is  \\( (g, p, g^d) \\)   private key is  \\( (g, p, d) \\)     To encrypt a value  \\( x \\)   define  \\( e \\)  randomly where  \\( 0 \u0026lt; e \u0026lt; p \\)   the encryption key is  \\( k = (g^d)^e = g^{de} \\)   ciphertext is  \\( y = (g^e, kx) \\)     To decrypt a value  \\( y \\)   we know  \\( d \\)   calculate the inverse key  \\( k^{-1} = (g^{ed})^{-1} \\)   calculate  \\( x = k^{-1} kx\\)      Note: One of the setbacks of this scheme is that the ciphertext is made up of a pair, and is twice as long as \\(p\\).  ElGamal signatures #  A signature scheme called the ElGamal signature scheme. This is harder to visualize (its number theory magic with the best attack being discrete logarithm).\nThe algorithm itself\n Key generation  define generator  \\( g \\)   define prime modulus  \\( p \\)   define cryptographic hash function  \\( H \\)   define secret  \\( x \\)  where  \\( 1 \u0026lt; x \u0026lt; p-1 \\)   public key is  \\( (g, p, H, g^x) \\)     To sign a message  \\( m \\)   define a key  \\( k \\)  where  \\( 1 \u0026lt; k \u0026lt; p-1 \\)  and  \\( \\text{GCD} (k, p-1) = 1 \\)   define  \\( r = g^k \\mod p \\)   define  \\( s = (H(m) - xr)k^{-1} \\mod (p-1) \\)    \\( H(m) = sk \u0026#43; xr \\mod (p-1)\\)     the signature is defined as  \\( (r,s) \\)     To verify a message  \\( m \\)  with signature  \\( (r,s) \\)   Check for equality on  \\( g^{H(m)} = = x^r \\cdot r^s \\)   This works because  \\( g^{H(m)} = g^{xr \u0026#43; sk} \\)        The DSA (digital signature algorithm) is similar to this scheme.\nOptimizing groups #  Our first priority is security, but our second concern is efficiency.\nTwo ways to attack a discrete logarithm problem\n Apply math, where we defend using a large modulus  \\( p \\)   Bruce force, given  \\( g^x = y \\)  you can attack over time  \\( g^i = y \\forall i\\)  . So if our  \\( p \\)  is 2000 bits long, it is overkill. It is necessary for thwarting attacks based on mathematics, but overkill for brute force.  We can\u0026rsquo;t lower the amount of  \\( p \\)  , because we need to defend against mathematical attacks. But we can lower the size of the group we work in, this gives us an avenue to optimize. Group sizes are recommended to be  \\( 2^{256} \\)  .\nSo\n Let  \\( g \\)  generate a sub group of size  \\( q \\)  , where  \\[\\begin{aligned} g^a = g^{a \\mod q} \\end{aligned}\\]  If  \\( p \\)  is around 2000 bits long, and  \\( q \\)  is around 200 bits long, then this results in a 10x speed up.  An example\n Let  \\( p = 101 \\)   The order of  \\( 5 \\mod 101 = 25 \\)  (order is how long the cycle around the modulus is, which is a subgroup of  \\( Z^*_p \\)  ).  \\[\\begin{aligned} 5^{25} \\mod 101 = 1 \\end{aligned}\\]   So lets find  \\( 5^{80} \\mod 101 \\)   \\[\\begin{aligned} 5^{80} \\mod 101 \u0026amp;= 5^{25} \\cdot 5^{25} \\cdot 5^{25} \\cdot 5^5 \\mod 101 \\\\ \u0026amp;= 1 \\cdot 1 \\cdot 1 \\cdot 5^5 \\mod 101 \\end{aligned}\\]    How to create a prime group with a subgroup #  Fact\n In a cyclic group, every element generates a cyclic subgroup and its size divides the size of the full group.  \\[\\begin{aligned} Z^*_7 = \\{1, 2, \\ldots, 6\\} \\end{aligned}\\]  The size of  \\( Z^*_p \\)  is  \\( p-1 \\)  . So the size of  \\( Z^*_7 \\)  is  \\( 6 \\)  , and the divisors of  \\( 6 \\)  are  \\( 1,2,3,6 \\)  . So the possible sizes of the sub groups are  \\( 1,2,3,6 \\)  . 1 generates a group of size 1,  \\( \\{1\\} \\)   2 generates a group of size 3,  \\( \\{2,4,1\\} \\)   3 generates a group of size 6,  \\( \\{3,2,6,4,5,1\\} \\)   4 generates a group of size 3,  \\( \\{4,2,1\\} \\)  , notice it is identical to the other subgroup of size 3 \u0026hellip; 6 generates a group of size 2,  \\( \\{6,1\\} \\)    Note: The last value in the group gives the subgroup of size 2.  Fact\n  Every divisor of a cyclic group\u0026rsquo;s size has a subgroup (just 1) of that size.\n  This gives us the idea to pick a large prime  \\( p \\)  where the size of the multiplicative prime group  \\( |Z^*_p| \\)  has a 256-bit prime factor  \\( q \\)  .  \\[\\begin{aligned} |Z^*_p| = p-1 \\end{aligned}\\]  So we need to find  \\( p-1 = nq \\)  for some  \\( n \\)  .\nAn algorithm to accomplish this\nq = 256 bit random prime do n = random (2000-256)-bit long even number p = nq + 1 while p not prime  This results in  \\( q \\)  is prime,  \\( p \\)  is prime, and  \\( q | (p-1) \\)      Fact\n If  \\( G \\)  is a cyclic group and  \\( a \\in G \\)  , then  \\( a^{|G|} = 1 \\)   So, if  \\( x \\in Z^*_p \\)  then  \\[\\begin{aligned} 1 \u0026amp;= x^{p-1} \\mod p \\\\ \u0026amp;= x^{nq} \\mod p \\\\ \u0026amp;= (x^n)^q \\mod p \\end{aligned}\\]  If  \\( x^n \\)  is not  \\( 1 \\)  , then  \\( g \\)  generates a size  \\( q \\)  subgroup. So this gives us an algorithm to find  \\( p,q \\)  , and  \\( g \\)  :  pick  \\( p \\)  and  \\( q \\)  , such that  \\( p = nq \u0026#43; 1 \\)  for some integer  \\( n \\)  . repeatedly pick  \\( x \\in Z^*_p \\)  . If  \\( x^n \\mod p \\neq 1 \\)  , then  \\( g = x^n \\mod p \\)  .    A subgroup example #  We will use\n  \\( n = 2 \\)    \\( q = 41 \\)    \\( p = 83 \\)     \\[\\begin{aligned} nq \u0026#43; 1 \u0026amp;= p \\\\ 2 \\cdot 41 \u0026#43; 1 \u0026amp;= 83 \\end{aligned}\\]  So our group is  \\( Z^*_{83} = \\{1, 2, \\ldots, 82\\} \\)  We can look for  \\( x \\)  where  \\( x^n \\mod p \\neq 1 \\)  .\n \\[\\begin{aligned} 2^2 \\mod 83 \u0026amp;= 4 \\\\ (2^2)^{41} \u0026amp;= 2^{82} = 1 \\\\ 4^{41} \u0026amp;= 1 \\end{aligned}\\]  So the order of  \\( 4 \\mod 83 \\)  is 41.\nSo we can use our optimization as  \\( 4^{x \\mod 41} \\mod p = 4^x \\mod p \\)  "}),a.add({id:268,href:'/notes/CS152/CS152-lecture-20210701/',title:"CS152-lecture-20210701",section:"CS152",content:"Groups #  Diffie-Hellman is secure against any passive adversary using groups where the discrete log problem is hard.\nA group is a simplification of a field, as it only has 1 operation (instead of 2).\nIn summary, a group\n is a set of objects (usually numbers)   \\( G \\)   has one operation (binary) that is closed,  \\( G \\times G \\to G \\)   this is usually addition or multiplication   has an identity  usually 0 in an additive group usually 1 in a multiplicative group   have invereses,  \\( \\forall x \\in G, \\exists y \\in G \\)  such that  \\( x \\text{ op } y = \\text{identity} \\)   is associative, and commutative  Some examples of infinite groups\n the integers and the addition operator:  \\( (\\mathbb{Z} , \u0026#43;) \\)   0 is identity subtraction is the inverse   the integers and multiplication is not a group, because 0 has no inverse:  \\( (\\mathbb{Z} , \\times) \\)   the rational numbers and multiplication is not a group, because 0 has no inverse:  \\( (\\mathbb{Q}, \\times) \\)   however its almost a group if it weren\u0026rsquo;t for 0, so if we remove 0 it is a group:  \\( (\\mathbb{Q} -\\{0\\}, \\times) \\)      A finite multiplicative group:  \\( (Z^*_n, \\times \\mod n) \\)  , where  \\( Z^*_n \\)  is the set of all  \\( x \\in Z_n \\)  and  \\( \\text{gcd} (x,n)=1 \\)  .\nTo find a group in  \\( Z^*_n \\)   Write all elements of  \\( Z_n \\)   For each prime factor  \\( x \\)  of  \\( n \\)  , cross out all multiples of  \\( x \\)  (including 0). What ever is left is in  \\( Z^*_n \\)    Finding a finite multiplicative group #  Lets find  \\( Z^*_{12} \\)  .\nWe know that  \\[\\begin{aligned} 12 = 2^2 \\cdot 3 \\end{aligned}\\]  So we can cross out all the multiples of 2 and 3 in our list of numbers:\nSo  \\[\\begin{aligned} Z^*_{12} = \\{1,5,7,11\\} \\end{aligned}\\]  which forms a multiplicative group  \\( \\mod 12 \\)  .\nSo if we select a pair of these elements and multiple them and take  \\( \\mod 12 \\)  , we get another items from the group. Each element happens to be its own inverse as well (this doesn\u0026rsquo;t always happen, but each element will have an inverse).\nWe are interested two finite groups that have a hard discrete log problem:\n  \\( Z^*_p \\)  where  \\( p \\)  is prime  \\[\\begin{aligned} Z^*_p = \\{1, 2, \\ldots, p-1\\} \\end{aligned}\\]  This is always guaranteed to be a group (0 is thrown out), and it is also a large group (no holes). The operations is  \\( \\times \\mod p \\)  . The additive elliptic curve group.  Elliptic curve groups #   https://wiki.crypto.rub.de/Buch/en/download/Understanding_Cryptography_Chptr_9---ECC.pdf    This group is related to geometry (suggested by the name elliptic curve). Defined by the equation  \\[\\begin{aligned} y^2 = x^3 \u0026#43; ax \u0026#43; b \\mod p \\end{aligned}\\]   The set of objects in the group is all the integer points on the curve. Not all of the points on the line are in the group, only those that have an integer for their  \\( (x,y) \\)  coordinates. The identity is  \\( 0 \\)   The inverse of  \\( (x,y) \\)  is  \\( (x,-y) \\)   The operation is defined as addition  \\[ \\begin{aligned} \\text{identity} = \\text{point} \u0026#43; \\text{inverse of point} \\end{aligned} \\]   To add a pair of points, define a secant line that goes through both points (which will be guaranteed to intersect the graph in exactly one other place) This new point is the reflection point, where the result is the inverse of that reflection  If we add a point to itself, define a tangent line that goes through the point, and take the inverse of the reflection point    Elliptic curve groups are good for efficient cryptography because the numbers only have to be 200-500 bits long.\nFacts about groups #   If  \\( G \\)  is a group, and  \\( x \\in G \\)  , then  \\( x^{|G|} = 1 \\)   Recall that  \\( x^i \\)  in a multiplicative group is defined as\n \\[\\begin{aligned} x^i = \\underbrace{1 \\cdot x \\cdot x \\cdot \\cdots \\cdot x}_{i \\text{ times}} \\end{aligned}\\]  and in an additive group it is defined as\n \\[\\begin{aligned} x^i = \\underbrace{0 \u0026#43; x \u0026#43; x \u0026#43; \\cdots \u0026#43; x}_{i \\text{ times}} \\end{aligned}\\]  So consider  \\( G = Z^*_7 = \\{1, 2, \\ldots, 6\\} \\)   We can raise an item from the group to the size of the group to demonstrate  \\[\\begin{aligned} 3^6 \\mod 7 = 1 \\end{aligned}\\]   If we list out the powers up to the size of the group power, we get some interesting patterns  \\[\\begin{aligned} 1^0 \u0026amp;= 1 \\\\ 2^0 \u0026amp;= 1, 2^1 = 2, 2^2 = 4, 2^3 = 1 \\\\ 3^0 \u0026amp;= 1, 3^1 = 3, 3^2 = 2, 3^3 = 6, 3^4 = 4, 3^5 = 5, 3^6 = 1 \\end{aligned}\\]  An element that goes through the entire group before returning to 1 is called a primitive (sometimes called a generator).   If  \\( G \\)  and  \\( H \\)  are groups that use the same operation, and  \\( H \\subseteq G \\)  , then  \\( H \\)  is a subgroup of  \\( G \\)  .\n Each of the sets generated in the above example is a sub group (where  \\( 3 \\)  generates the entire group).\nSo consider  \\( H = \\{1,2,4\\} \\)  , the set generated by  \\( 2 \\)  in  \\( G \\)  above,\n The same operation is defined in the subgroup:  \\( \\times \\mod 7 \\)    \\( 1 \\)  is the identity ( \\( 1 \\)  will always be in the subgroup) Inverses exist, ie  \\[\\begin{aligned} 2 \\times 4 \\mod 7 = 4 \\\\ 4 \\times 2 \\mod 7 = 2 \\end{aligned}\\]   Therefore,  \\( H \\)  is a subgroup of  \\( G \\)     The size of the subgroup that  \\( x \\)  generates is called  \\( x \\)  \u0026rsquo;s order.\n So, the order of a primitive element is the full size of the group. Also, every order divides the size of the group.\nSo since  \\( |Z^*_7| = 6 \\)  , and the order of 2 is 3, so  \\( 3 | 6 \\)  .\nDiffie-Hellman using elliptic curve groups #  If we\u0026rsquo;re doing a Diffie-Hellman key exchange, we can use groups and generators\n group  \\( G \\)   generator  \\( g \\)    Recall that the key exchange is as follows\n Alice chooses  \\( x \\)  where  \\( 0 \\leq x \u0026lt; \\text{order} (G) \\)   Alice sends  \\( g^x \\)  to Bob   \\( g^x \\)  means to apply the group operator  \\( x \\)  times, it may be additive or multiplcative   Bob chooses  \\( y \\)  where  \\( 0 \\leq y \u0026lt; \\text{order} (g) \\)   Bob sends  \\( g^y \\)  to Alice The shared secret is  \\( g^{xy} \\)    Since the base  \\( g \\)  is known, the secret is basically \u0026ldquo;how many times was the group operator applied?\u0026rdquo;\nUsing elliptic curves (since it is an additive group), the key exchange is as follows\n There is a known point  \\( P = (a,b) \\)   Alice chooses  \\( x \\)  where  \\( 0 \\leq x \u0026lt; \\text{order} (P) \\)  , and sends  \\( xP \\)   Bob chooses  \\( y \\)  where  \\( 0 \\leq y \u0026lt; \\text{order} (P) \\)  , and sends  \\( yP \\)   The secret is  \\( xyP \\)    So how do we multiply an integer and a point? Recall that we can do exponentiation based on the bit pattern of the exponent with a combination of adding and squaring. Multiplication can be done via a combination of doubling and adding (both defined in an elliptic curve group), based on the bit pattern of the values.\nmult(a,b): let b[1] ... b[n] = b in binary acc = 0 for i from 1 to n: acc = acc + acc if b[i] = 1 acc = acc + a return acc Cryptographic systems #  Random number generation #  Random number generation might be the number one use of cryptography. Random number generation is used a lot in\n Games Simulation  Simulations run with a lot of random inputs and get a lot of outputs.   Randomized algorithms  For something like quicksort, the worst case can be  \\( O(n^2) \\)  when the array is already sorted. We can pick pivot points randomly to solve the worst case.    All of these uses need a high quality random number generator. If there is any bias, then the outputs will be bias. So we want our random number generators to be indistinguishable from truly random.\nThe cryptographic security model provides this indistinguishability we need.\nFortuna (2003) #  Fortuna is a pseudo-random number generator (PRNG). Used in FreeBSD and Apple operating systems.\nFortuna is made up of 2 parts\nRandom generator\n produces random output   Entropy collector\n collects unpredictable data from things like:  key presses mouse clicks network activity memory contents time/date      The random generator\u0026rsquo;s algorithm has\n a state  \\( (k,c) \\)  where   \\( k \\)  is a 32 byte key  \\( c \\)  is a 16 byte counter   a block cipher  \\( E \\)  , we\u0026rsquo;ll use AES-256 a cryptographic hash function  \\( H \\)  , we\u0026rsquo;ll use SHA-256  GenRand(n): for i from 1 to ceiling(n/16): output E(k, c) c = c + 1 k = E(k, c) || E(k, c + 1) // key update c = c + 2  // key update line avoids birthday bound issues, and gives backward security, because this step is non-invertible The key is the start of the algorithm, so it must be random. So where the key come from?  The entropy collector\n// s is a string with some entropy Reseed(s): k = H(k || s) c = c + 1  The entropy of  \\( k || s \\)  is the sum of the entropy of  \\( k \\)  and the entropy of  \\( s \\)    \\( k \\)  \u0026rsquo;s entropy will be  \\( \\text{min} (\\text{entropy} (k||s), 256) \\)   Notice that the counter is incremented at the end of the entropy collection. The string  \\( s \\)  comes from something like mouse clicks or keyboard taps  \\( k \\)  is only as uncertain as  \\( k || s \\)   If  \\( k || s \\)  is as unpredictable as a random 256 bit string and  \\( H \\)  behaves like a public random function, then  \\( k \\)  is uniform.    Note: Entropy (unpredictable data) is additive.  So, a lot of entropy should be collected and  \\( H \\)  should be a good hash function. The string  \\( s \\)  is produced via unpredictable events like mouse clicks and keyboard taps.\nEntropy #  A measure of uncertainty.\nA process with  \\( t \\)  bits of entropy is as uncertain as a random  \\( t \\)  bit string.\nFor example\n A coin flip, can be heads or tails, has the same uncertainty of a 1 bit string:  \\( 0 \\)  or  \\( 1 \\)   1 bit of entropy   A sequence of 2 coin flips, HH HT TH TT, has an uncertainty of 2 bits A six sided die, can be 1 2 3 4 5 or 6, all equally likely. More uncertain than a 2 bit string, but less uncertain than a 3 bit string.  So, it has in between 2 and 3 bits of entropy If  \\( x \\)  is a random variable with  \\( k \\)  equally likely outcomes, then  \\( x \\)  has  \\( \\log_2 k \\)  bits of entropy. So,  \\( \\log_2 6 \\approx 2.6 \\)  bits of entropy    If we have 3 different groups of people that all want different snacks, with this probability:\nThere is less entropy if there is an outcome that is more likely. The most entropy possible is when each outcome\u0026rsquo;s chance is all the same.\n If all outcomes had  \\( \\frac{1}{2} \\)  probability, then there is 2 possible outcomes, so 1 bit of entropy If all outcomes had  \\( \\frac{1}{4} \\)  probability, then there is 2 bits of entropy Then take a weighted average,  \\( \\frac{1}{2} \u0026#43; \\frac{1}{4} \\cdot 2 \u0026#43; \\frac{1}{4} \\cdot 2 = \\frac{3}{2} \\)   So out snack scenario has the same entropy has a 1.5 bit string   Entropy is defined as  \\[\\begin{aligned} \\text{entropy} = - \\sum_{x \\in X} P(X=x) \\log_2 P(X=x) \\end{aligned}\\]   Entropy collection #  The second part of Fortuna requires that the key is seeded with a string with high entropy. The entropy collector is made up of\n A state, with pools  \\( P_0, \\ldots, P_{31} \\)  each empty (pools are strings). Sources,  \\( s_1, \\ldots, s_i \\)  , copy data from unpredictable sources, like mouse clicks and key presses, to pools in a round robin fashion. A reseed counter, starting at 0  These pools are being replenished via the sources as a background process, so when the random generator needs a key it is ready. The first thing that the random generator checks if a reseed is needed.\nif P[0] has enough data and last reseed \u0026gt; 100ms ago s = \u0026quot;\u0026quot; reseed counter += 1 for i from 0 to 31 if 2^i divides reseed counter s = s || p[i] p[i] = \u0026quot;\u0026quot; Reseed(s)  the check if 2^i divides reseed counter means that pool  \\( p_0 \\)  participates in every reseed, but pool  \\( p_1 \\)  participate every other reseed, pool  \\( p_2 \\)  will participate in reseeds 1,2 \u0026hellip;  This helps thwart an adversary to flood a system with events with low entropy.\nForward security comes from entropy. Entropy keeps the adversary from knowing the future.\n"}),a.add({id:269,href:'/notes/CS152/CS152-lecture-20210706/',title:"CS152-lecture-20210706",section:"CS152",content:"Tweakable block ciphers #  The idea is that our block cipher   \\( E \\)  will take our key, and a second input called a tweak.  \\[\\begin{aligned} \\tilde{E}:(\\text{key, tweak}) \\to \\left( \\{0,1\\}^b \\to \\{0,1\\}^b \\right) \\end{aligned}\\]  We notate that the block cipher is tweakable via the tilde notation,  \\( \\tilde{E} \\)  .\nThe key must be random and private, but the tweak is non-random and public.\nSo why use a tweak?\n Changing a key is expensive Changing a tweak is cheap  The layout of a tweakable block cipher may look like this:\n The tweak is hashed and xor\u0026rsquo;d before and after the block cipher. The hash function is an almost-universal hash function. Each time we change the tweak, different values are being xor\u0026rsquo;d before and after. Because a hash output is unpredictable, since the adversary doesn\u0026rsquo;t know the hash function or key, the adversary doesn\u0026rsquo;t know what is going into the block cipher.  Read more about tweakable block ciphers  OCB – Authenticated Encryption #  Note: This is a project that the Professor worked on.  A form of authenticated encryption. The block cipher here can be thought of as a tweakable block cipher.\nThe layout is as follows:\n plaintext is broken into blocks each block is fed through the tweakable block cipher, each block cipher\u0026rsquo;s tweak is incremented from the last the cipher text is the output blocks concatenated back together  Since we are using a different tweak each time, we can think of each column as an independent random permutation (each used one). So, all the cipher text blocks are uniform. Because of this, the advantage an adversary has to distinguish ciphertext from random is 0.\nSo where does the authentication come in?\nTo create the tag:\n Xor all plaintext blocks together, and send through  \\( \\tilde{E} \\)  , with a tweak of 0 (something that hasn\u0026rsquo;t been used before).  \\[\\begin{aligned} \\text{tag} = \\tilde{E}(P_1 \\oplus P_2 \\oplus \\cdots \\oplus P_i) \\end{aligned}\\]   This is really cheap!  To authenticate:\n Decrypt the ciphertext into its plaintext blocks, then xor plaintext blocks and send through the tweakable block cipher.  Optimizing sequential hashes #  Since we are using a hash of an incrementing counter, we can optimize the process.\nCan we go from the hash of the first tweak to the hash of the second tweak more efficiently than recalculating?\n If we start off with an intial value  \\( h_\\text{iv} \\)  , we can define the currently hashed tweak as  \\[\\begin{aligned} h_\\text{iv}(t) = (\\text{iv}) \\cdot 2^t \\end{aligned}\\]  This works especially well in  \\( GF(2^b) \\)  . The next hash is defined as can be reached by doubling the last value again  \\[\\begin{aligned} h_\\text{iv}(t \u0026#43; 1) = (\\text{iv}) \\cdot 2^{t \u0026#43; 1} \\end{aligned}\\]  Some pseudo to get the next hash  next_hash(x): if high bit of x == 1: x = (x \u0026lt;\u0026lt; 1) xor 135 // raise degree of all terms and xor else x = x \u0026lt;\u0026lt; 1 Note: We xor by 135 because that is the same bit pattern as the modulus.  Certificates #  Recall that public key (asymmetric) cryptography means that each party has a public key and a private key. This means that the number of keys needed is to the order of  \\( O(n) \\)  (whereas symmetric key cryptography needs  \\( O(n^2) \\)  keys.)\nWe use a hybrid of the 2 types to get the benefits of each.\n Establish a key with asymmetric cryptography,  Solves the key problem   Switch over to symmetric cryptography  Symmetric is faster    So certificates answer the question \u0026ldquo;how do you make everyone\u0026rsquo;s public key available?\u0026rdquo;\nA certificate is a text file with\n The owner of the certificate: name, company, other identifiers to who owns the certificate Who issued the certificate: certificate issuer\u0026rsquo;s id Usage information: valid date range Valid uses: certificates only have certain permissions Owner\u0026rsquo;s public key Issuer\u0026rsquo;s signature: all of the previous fields are hashed to create the signature  The goal of the certificate is to associate the owner with their public key.\nIf Alice wants to send Bob a file, and Bob wants to trust that the file is correct:\n Alice sends a file, signature (of file), and Alice\u0026rsquo;s certificate Bob uses Alice\u0026rsquo;s public key to verify the signature of the file  Note: While there are long living trusted certificates (distributed with operating systems), most certificates are sent with the data.  So why should Bob trust Alice\u0026rsquo;s certificate? In an adversarial environment, Bob should not trust it. Bob should check the issuer on Alice\u0026rsquo;s certificate to see if it is issued by a trusted certificate authority (CA).\nTo certify:\n Receive  \\( A \\)  \u0026rsquo;s certificate, signed by  \\( B \\)   Look for  \\( B \\)  \u0026rsquo;s certificate in the trusted bundle, if its there we trust it If we receive multiple certificates at once:  \\( A,B,C \\)  is a chain of trust Follow the chain of trust until we see a certificate that is in the trusted bundle  Certificate authorities are certificates that are from trusted companies, or the government. They issue their own certificates to operating systems and brownser manufacturers.\nTools to look at certificates #  We can use OpenSSL to look at certificates for websites, ie\nopenssl s_client -connect www.amazon.com:443 Note: If we run the command with the --showcerts flag, it shows the entire chain of trust.  which gives us this\n-----BEGIN CERTIFICATE----- MIIHoTCCBomgAwIBAgIQBgFdj+Nrd6vfZrmQSH7aQDANBgkqhkiG9w0BAQsFADBE MQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMR4wHAYDVQQDExVE aWdpQ2VydCBHbG9iYWwgQ0EgRzIwHhcNMjEwNDE5MDAwMDAwWhcNMjIwNDExMjM1 ... YlgYDFLnfNahdqfgLTLRyv06bOKVc1V6axvvZSs4F9i1FXtYtBe6IhZrS04zYL60 He5cSbVV4DSZAzvlc9P8d5LZSOYMV6oMyGBqb6wCpH2Mju/I0gLM8OcDN/v2eGkz s3KLTGnom5QuAnMw7rt/l+9Gr+y1EA3srdVH0de4vG/sO6gRGg== -----END CERTIFICATE----- Note: Part of the certificate ommited here for brevity.  We can parse this using another command\nopenssl x509 -noout -text which parses from stdin, so we can paste in our certificate and we get information like\nVersion: 3 (0x2) Serial Number: 06:01:5d:8f:e3:6b:77:ab:df:66:b9:90:48:7e:da:40 Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = DigiCert Inc, CN = DigiCert Global CA G2 Validity Not Before: Apr 19 00:00:00 2021 GMT Not After : Apr 11 23:59:59 2022 GMT Subject: CN = www.amazon.com Along with this information, it also gives us\n The owner\u0026rsquo;s public key Information about the usages, permissions A list of alternative names that this certificate also signs Actual signature of all prior data  So what does the actual trusted bundle (the distributed trusted certificates in operating systems) look like?\nThe file cacert.pem here shows us the trusted certificates.\n"}),a.add({id:270,href:'/notes/CS177/CS177-lecture-20220125/',title:"CS177-lecture-20220125",section:"CS177",content:"Data Mining #  Syllabus #  File: 177-syllabus.pdf  Notes during orientation #   Programming assignments will be in Python Most of the programming assignments are from past TAs Fundamental machine learning Slides are in files on canvas Book resources Lab attendance is required, .ipynb files on canvas  "}),a.add({id:271,href:'/notes/CS177/CS177-lecture-20220127/',title:"CS177-lecture-20220127",section:"CS177",content:"Exploring data #  Ultimately, any machine learning is just optimizing error in a graph, then deriving a function that fits to the data.\nRead more about John Tukey\nIris sample data set #   http://www.ics.uci.edu/~mlearn/MLRepository.html  Statistics definitions #   ordinal means that the data can be ordered continuous means that the values are floating point      \\( \\text{AAD} (x) \\)  is the absolute distance  \\( \\text{MAD} (x) \\)  is the median dependent value  Visualization #  "}),a.add({id:272,href:'/notes/CS177/CS177-lecture-20220202/',title:"CS177-lecture-20220202",section:"CS177",content:"Exploratory analysis cont. #  Representing data cont. #  Analyzing data #  Mining introduction #  Tasks #   anomaly detection is relatively new  Classification #  "}),a.add({id:273,href:'/notes/CS177/CS177-lecture-20220203/',title:"CS177-lecture-20220203",section:"CS177",content:"Data exploration cont. #  Classification cont. #  Regression #  Clustering #  Association #  Deviation / anomaly / change detection #  Challenges #   the concept of neural networks has been around for a long time, however only because of recent computational power has it become widely used  What is data? #  "}),a.add({id:274,href:'/notes/CS177/CS177-lecture-20220210/',title:"CS177-lecture-20220210",section:"CS177",content:"NumPy #  We can use NumPy with\nimport numpy as np We can create new arrays with\na = np.array([1, 5, 7]) We can specify number of dimensions or data types:\nb = np.array([1, 2, 3], ndim=2) c = np.array([1, 2, 3, 4], dtype=complex) We can see the shape of an array via\nprint(a) print(a.shape) You can set the shape of an array\nd = np.array([1, 2, 3], [4, 5, 6]) d.shape = (3, 2) To create an array in a range\na = np.arange(24) We can reshape this new array:\nIf we already have a Python list, we can create a NumPy array from it:\nx = [1, 2, 3] a = np.asarray(x) Pandas #   High performance data manipulation and data analysis DataFrame object, default and customized indexing High efficient merging and joining of data Columns from a data structure can be deleted or inserted Label based slicing, indexing of large datasets  Structures #   Series, 1D labeled homogenous array DataFrame, 2D labeled hetergenously typed columns Panel, 3D labeled, size mutable array  Plotting #  "}),a.add({id:275,href:'/notes/CS177/CS177-lecture-20220215/',title:"CS177-lecture-20220215",section:"CS177",content:"What is data? #  Attributes #  Difference between ratio and interval #  "}),a.add({id:276,href:'/notes/CS177/CS177-lecture-20220217/',title:"CS177-lecture-20220217",section:"CS177",content:"Data preprocessing cont. #  Attributes cont. #  Types of data sets #  Data quality #  "}),a.add({id:277,href:'/notes/CS177/CS177-lecture-20220222/',title:"CS177-lecture-20220222",section:"CS177",content:"Data quality cont. #  Distance #  Similarity #  Correlation #  Measures #  Density #  Preprocessing #  Sampling #  "}),a.add({id:278,href:'/notes/CS177/CS177-lecture-20220224/',title:"CS177-lecture-20220224",section:"CS177",content:"Common procedures for preprocessing #   Aggregation Dimension Reduction Standardization Missing values Bad data (noise reduction) Translation (log) Feature extraction Removing outliers  Classification #  Hunt\u0026rsquo;s algorithm #  "}),a.add({id:279,href:'/notes/CS177/CS177-lecture-20220301/',title:"CS177-lecture-20220301",section:"CS177",content:"To reduce dimensions #  Use PCA and SVD.\nClassification cont. #  Methods of splitting #  How to determine the best split #  "}),a.add({id:280,href:'/notes/CS177/CS177-lecture-20220303/',title:"CS177-lecture-20220303",section:"CS177",content:"Classification cont. #  Splitting cont. #  Decision tree based classification #  "}),a.add({id:281,href:'/notes/CS177/CS177-lecture-20220308/',title:"CS177-lecture-20220308",section:"CS177",content:"Linear regression #  Best practices #  "}),a.add({id:282,href:'/notes/CS190/CS190-lecture-20210830/',title:"CS190-lecture-20210830",section:"CS190",content:"Course orientation #  File: 190-syllabus.pdf  Notes during orientation #   Can chose your own team, students from either section  Introduction #  "}),a.add({id:283,href:'/notes/CS190/CS190-lecture-20210913/',title:"CS190-lecture-20210913",section:"CS190",content:"More information on project #  "}),a.add({id:284,href:'/notes/CS190/CS190-lecture-20210920/',title:"CS190-lecture-20210920",section:"CS190",content:"Sprint 00 #  Scoping the business problem #  Working backwards #  See article for template.  "}),a.add({id:285,href:'/notes/CS190/CS190-lecture-20210927/',title:"CS190-lecture-20210927",section:"CS190",content:"Sprint 1 notes #  Planning assignment\n Can be a screenshot of our Jira page instead of spread sheet  Execution report\n A retrospective of the end of the sprint  Client review meeting\n Submit some artifacts  Context diagram Business event table    Goals #  "}),a.add({id:286,href:'/notes/CS190/CS190-lecture-20211004/',title:"CS190-lecture-20211004",section:"CS190",content:"SCRUM #  "}),a.add({id:287,href:'/notes/CS190/CS190-lecture-20211011/',title:"CS190-lecture-20211011",section:"CS190",content:"Agile examples #  "}),a.add({id:288,href:'/notes/CS190/CS190-lecture-20211025/',title:"CS190-lecture-20211025",section:"CS190",content:"Prototyping #  "}),a.add({id:289,href:'/notes/CS190/CS190-lecture-20211101/',title:"CS190-lecture-20211101",section:"CS190",content:"Continuous integration #  "}),a.add({id:290,href:'/notes/CS190/CS190-lecture-20211108/',title:"CS190-lecture-20211108",section:"CS190",content:"Day to day in software #  "}),a.add({id:291,href:'/notes/CS190/CS190-lecture-20211115/',title:"CS190-lecture-20211115",section:"CS190",content:"Working as a software dev cont. #  "}),a.add({id:292,href:'/notes/CS191/CS191-lecture-20220126/',title:"CS191-lecture-20220126",section:"CS191",content:"Senior Project, Part 2 #  Syllabus #  File: 191-syllabus.pdf  Notes during orientation #   attend either Zoom lecture  "}),a.add({id:293,href:'/notes/CS191/CS191-lecture-20220202/',title:"CS191-lecture-20220202",section:"CS191",content:"Agile development #  SCRUM #  git #  "}),a.add({id:294,href:'/notes/CS191/CS191-lecture-20220216/',title:"CS191-lecture-20220216",section:"CS191",content:"Project showcase #  JIRA/Flying donut #  Assignments #  "}),a.add({id:295,href:'/notes/CS191/CS191-lecture-20220223/',title:"CS191-lecture-20220223",section:"CS191",content:"Testing #  "}),a.add({id:296,href:'/notes/CS191/CS191-lecture-20220302/',title:"CS191-lecture-20220302",section:"CS191",content:"Acceptance testing cont. #  Course updates #  Unit testing #  "}),a.add({id:297,href:'/notes/CS192/CS192-lecture-20210903/',title:"CS192-lecture-20210903",section:"CS192",content:"Course orientation #   12 seminars, on schedule  Must attend 10, and submit feedback 6 seminars are pure CS, 6 are leadership oriented   Evaluations are full or no points, attend and complete 10 to pass (no problem with attending/completing all 12). Typical 30-45 min run time, with Q\u0026amp;A at the end  "}),a.add({id:298,href:'/notes/CS192/CS192-seminar-20210910/',title:"CS192-seminar-20210910",section:"CS192",content:"Career Success Factors #  Speaker: Cameron Law\n"}),a.add({id:299,href:'/notes/CS192/CS192-seminar-20210924/',title:"CS192-seminar-20210924",section:"CS192",content:"Seeing the Big Picture: Preparing for Leadership in the Data Age #  Speaker: Professor Joseph Taylor\n"}),a.add({id:300,href:'/notes/CS192/CS192-seminar-20211001/',title:"CS192-seminar-20211001",section:"CS192",content:"Accenture Info Session #  Speaker: Jason Francis\n"}),a.add({id:301,href:'/notes/CS192/CS192-seminar-20211008/',title:"CS192-seminar-20211008",section:"CS192",content:"Introduction to Adaptive Leadership #  Speaker: Rabbil Green\n"}),a.add({id:302,href:'/notes/CS192/CS192-seminar-20211022/',title:"CS192-seminar-20211022",section:"CS192",content:"Leadership in a non-profit organization, when people, passion, and innovation make for good business #  Speaker: Tiffani Fink, Paratransit Inc.\n"}),a.add({id:303,href:'/notes/CS192/CS192-seminar-20211029/',title:"CS192-seminar-20211029",section:"CS192",content:"Career Planning #  Speaker: Greg Kiefer\n"}),a.add({id:304,href:'/notes/CS192/CS192-seminar-20211105/',title:"CS192-seminar-20211105",section:"CS192",content:"Change management #  Speaker: Jessica Bagger, PhD\n"}),a.add({id:305,href:'/notes/CS192/CS192-seminar-20211112/',title:"CS192-seminar-20211112",section:"CS192",content:"Cyber Security: Career Opportunities #  Speaker: Shoba Mallarapu and Srinivas Atluri, Anvaya Solutions Inc.\n"}),a.add({id:306,href:'/notes/CS192/CS192-seminar-20211119/',title:"CS192-seminar-20211119",section:"CS192",content:"Unleashing the Leadership Qualities Within You #  Speaker: Liana Bailey-Crimmins\n"}),a.add({id:307,href:'/notes/CS192/CS192-seminar-20211203/',title:"CS192-seminar-20211203",section:"CS192",content:"Conversational AI #  Speaker: Venky Krishnawamy\n can a virtual assistant resolve the customer\u0026rsquo;s problem?   can CSRs be assisted or trained so they can provide better service?  "}),a.add({id:308,href:'/notes/CS26/CS26-lecture-notes/',title:"CS26-lecture-notes",section:"CS26",content:"CS 26 Lecture Notes #  Jan 28, 2019 #  Introduction #  Discrete: Not \u0026ldquo;discreet\u0026rdquo;, opposite of continuous, goes in steps. The graphs we worked with can only be expanded in steps, you can\u0026rsquo;t add a half edge or half vertex.\nStructure: a set of related values and the operations on them. (integers, graphs).\nLike a venn diagram of math and computer science, discrete structures is the combination.\n Jan 30, 2019 #  Binary Numbers #  Spending method: 89 can be converted to decimal by \u0026ldquo;buying\u0026rdquo; the most expensive thing you can from the powers of two.\nRepeated division: 89 can be repeatedly divided by 2. the remainders in reverse order will be the binary number.\nHexadecimal - Base 16 Using higher bases means you can pack more information into a smaller space.\nBase 32 uses 1..9A..V Can be easily converted from binary by using groups of 5 bits.\nBase 64 uses 1..9A..Za..z+/ Can be easily converted from binary by using groups of 6 bits. Starts from the beginning of the file, grouping into 6 bits then padded with an equals sign (=) for each 2 bits left over.\nAll data is just numbers. How you \u0026ldquo;chunk it up\u0026rdquo; is just a way of representation the information.\n Feb 4, 2019 #  Signed Integers #   2\u0026rsquo;s complement  In 2\u0026rsquo;s complement subtracting and addition are the same operation. To subtract, add the negative version of the number. The result will be in 2\u0026rsquo;s complement, which needs context to be understood. Without context, there is no way to know which. The CPU does not know (and doesn\u0026rsquo;t care) whether we are using unsigned or 2s complement numbers.   Sign-magnitude  MSB is the sign bit, 1 means negative, 0 means positive.   Excess-n or Excess-k  Splits the numbers in but not in half. It is shifted down to accomodate however many negative numbers you need.    Pros\n Signed magnitude  Easy for humans Symmetric range LSB shows even/odd MSB is pos/neg   2s Complement  Easy arithmetic LSB is even/odd MSB is pos/neg   Excess-n  Easy negation (add or subtract) Definable range    Cons\n Signed magnitude  Two zeros difficult for computers   2s complement  Negation more difficult (than signed magnitude)   Excess-n   Feb 6, 2019 #  Non-integral numbers #  110.101 = 6.625\nThe places to the right of the radix are still powers of 2 (negative powers)\nCertain numbers cannot be broken down into base 2 (for instance 7.6, .6 cannot be broken down into powers of 2). When sending floating point numbers, the radix point cannot be shown in 1s and 0s. You can agree on where the radix point will go before hand, which is called fixed-point.\nFixed point #  ___.___, the radix point isn\u0026rsquo;t sent along, its just agreed upon where it will be. 0b1101 1100 would turn into 1101.1100)\nFloating point #  IEEE-754 is the standard for floating point numbers. Floating point numbers is essentially scientific notation but in binary.\n$-6.521 x 10^27$\nThe three parts you need to pay attention to are the sign, the mantissa (the number after the sign) and the exponent. Numbers must be normalized ($.0314).\nModified IEEE-754 (8 bits): Trade off between precision and range. Will use 1 bit for the sign (MSB), 4 bits for exponent, and 3 for mantissa.\n_ _ _ _ _ _ _ _\nSign\n 0 is pos 1 is neg  Exponent\n Represented in excess-n  Mantissa\n Fractional binary  The leftmost digit after normalized is always a 1, so that can be ommited when transfering to a floating point number. IEEE-754 says if you are using 4 bits for exponent, you should use excess-7. To find the number of bits to shift by you should use $n = 2^{b-1} - 1$ where $b$ is the number of bits used to express the exponent.\nRange of values\n Smallest positive value (in our modified 8 bit version, in the real version it says if all bits are 0 then the number is 0)  0b0000 0000 = $1.000 x 2^-7$ = $1/128$   Largest positive value  0b0111 1111 = $1.111 x 2^8$ = $480$   Next largest  0b1111 1110 = $1.110 x 2^8$ = $448$     Feb 11, 2019 #  Gates and Logic #  74163 - 4 bit counter 74138 - 3 to 8 bit decoder 7400 - NAND\nThese chips can be mounted on PCBs to make a computer.\nTwo circuits/expressions are equivalent if they have the same truth tables.\nNAND is a universal gate, meaning you can make any other gate out of just NANDs.\n Feb 13, 2019 #  Boolean Logic #  Boolean expressions are equivalent if they have the same truth table. To flip the output of a truth table over, not the result.\n Feb 20, 2019 #  Karnaugh Maps #  How to:\n Get expression into SoP (Sum of products) or DNF (Disjunctive normal form) Make grid, label axes, use grade code to fill out any multiple variable columns Dot boxes for each term Circle adjacent dots  As big as possible Dimensions of circle must be powers of 2 As few circles as possible to cover all dots Overlap circles in order to make them as big as possible   Each circle is a term in the minimized expression  Lab 3: Satisfiability #  pseudo:\nfor x from 0 to 1 for y from 0 to 1 for x from 0 to 1 if x == 0 or y == 1 and z == 1 or y == 0 print x, y, z  Feb 27, 2019 #  Modular Arithmetic and Cryptography #  Overview\n Shift cipher (Caesar) Linear cipher Vigenere cipher Hasing and passwords Symmetric key crypto Public key crypto  Encoding is just transforming from one form to another. There isn\u0026rsquo;t any secret information, you just need to know what algorithm is being used. Cryptography uses encoding with some secret information to make the algorithm harder to decode.\nModular arithmetic\n 18 + 35 mod 7 = 18 18 + 35 (mod 7) = 4\n These expressions are not the same. The first expression the mod is only applying to the 35, whereas the second expression mods the entire sum of whats on the left before mod. Congruent numbers are numbers that land on the same spot in the mod circle.\nRemainder vs modulo\nRemainders can be negative, and modulos is always positive.\nArithmetic properties\nSum\n 123456 + 7891011 (mod 79)) (a + b) mod n)\n To do this on the normal calculator, divide the numbers, minus the quotient, then multiply by the mod number.\nMultiplication\n Multiplication\n Exponents\n 456^789 mod 79 = 58 (456 mod 79)^789 = 58\n You can mod the base but not the exponent!\nPreview of RSA\n Plaintext  the message you want to encrypt   Ciphertext  the encrypted message This is basically the $c = p^{e} mod n$  c = cihper text p = plain text e) n \u0026gt; p (n can be as big as 400 digits long)       (40 digits)^(200 digits) mod (400 digits)\n  17^123 (mod 19) = 17^100 * 17^23 = 17^50 * 17^50 * 17^23\n  Mar 4, 2019 #  Test 1 #   Opens Friday 8a, closes Mon 8a You have 3 hours to finish once you start  Most people need about 1 hour   Covers  Binary Signed integers Gates and circuits Boolean logic K-maps Floating-point   Work on seperate sheet of paper. Turn in paper next class to get partial credit for problems.  Linear cipher #  Formula\n c)  n is size of alphabet c is cipher text p is plaintext m is multiplier    In python:\nlinear(p, m, k): return (p * m + k) % n The process looks like this, using m = 5 and k = 7\nC A T plaintext 02 00 19 coded 17 07 102 multiplied and shifted 17 07 24 mod 26 R H Y ciphertext To decipher\n Must know m and k, and reverse the process  What makes good numbers for m and k?\n m should be greater then 0 and less than n  If you multiply by anything over n it is the same as multiplying as numbers that are less then n. Multiplying by n is the same as multiplying by 0   k should be greater than or equal to 0 and less than n  Anything below 0 or above n is no point   m and n should have no common factors! (coprime, or relatively prime) This creates non-1:1 mappings!  An example in python, using m = 22 and k = 24:\nfor p in range(0, 26): c) % 26 print(p, c) This pattern creates repeating numbers that don\u0026rsquo;t map 1:1 anymore with numbers, so it isn\u0026rsquo;t a good choice for a multiplier and shift.\nField\n A set of values on which the following operations are defined:  Addition Multiplication Additive inverse Multiplicative inverse    Euler\u0026rsquo;s Totient Function\n How many numbers less the number are coprimes of the number. Properties  If n is prime  then φ(n) = n-1   If n = a * b, a and b are coprime and a ≠ b  then φ(n))   If n)  then φ(n))      Euler\u0026rsquo;s Theorem\n a^φ(n)), if a and n are coprime   Mar 6, 2019 #  Greatest Common Divisor #  gcd(15, 21) = 3 gcd(90, 60) = 30\nEuclidean Algorithm\n gcd(a, 0) = a gcd(a, b))  Example: gcd(90, 60)) = 30\ngcd(15, 270)) = 15\nIn a python function:\ndef gcd(a, b): if b == 0: return a else: return gcd(b, a % b) Extended Euclidean Algorithm\n ax + by)  You give it a and b, it returns x and y    Try:\na = 60\nb = 90\n60x + 90y)\n60x + 90y = 30\n2x + 3y = 1\nx = -1, y = 1\nx = 2, y = -1\nx = 5, y = -3\negcd(15, 21)\n15x + 21y)\n15x + 21 y = 3\n5x + 7y = 1\nx = 3, y = -2\nx = -4, y = 3\negcd(15, 26)\n15x + 26 y)\n15x + 26y = 1\nx = 7, y = -4\n15 * 7 (mod 26) = 1\nx is the multiplicative inverse of a mod b\nLab 5 #  Linear cipher\n To encrypt:  c = pm + k % n   To decrypt  c) m^-1 % n  m^-1 % n is the multiplicative inverse      To calculate multiplicative inverse use the Extended Euclidean Algorithm egcd(a, 0))\negcd(a, b))\n q equals to a//b r equals a mod b (s, t))  In python:\ndef egcd(a, b): if b == 0: return (1, 0) else: q = a // b r = a % b (s, t)) return (t, s - q * t)  Mar 11, 2019 #  Pseudo Random Number Generator (PRNG) #  In 1946, Von Neumann proposed a random number generator:\n Start with a 4 digit number Square it Extract the middle 4 digits Use this pseudo random number as the seed for the next  The PRNG gets a seed as input, which is then put through a calculation, and the output is your pseudo random number. The output can then be used as a seed for the next random number.\ndef vn(seed); sq = seed * seed # divide by 100 using integer division to remove the rightmost 2 digits, then mod by 10k to keep the rightmost 4 digits rnd = sq // 100 % 10000 return rnd s = 4321 for i in range(100): r) print(r) s = r Linear Congruential Generators (LCG) #  The formula: rand)\nJust like our linear cipher, the multiplier and mod number must be coprime. N is the length of the cycle. Any seed you pick will be one of the values in the cycle. This is useful for debugging programs that use a random number generator to see if they are working before letting them loose with random seeds. Inside the computer at a random place in memory, the OS keeps whats called a \u0026ldquo;Pool of entropy\u0026rdquo;, which stores random bits to be used as starting points for random seeds, this is replenished by random events such as network activity times or times between keypresses etc.\nConcerning domain and range:\n If every value in the domain has a 1:1 value in the range, this is called bijection (good for crypto). If If every value has a many:1 value in the range, this is called a surjection (not good for crypto). This can\u0026rsquo;t be reversed (its a one way function)  Checksums #  A small number calculated from data being sent that is used to verify the integrity of the data. Designed to be very fast to compute, can catch common problems, not to be used for encryption though.\nLuhn algorithm:\n4539 7043 5470 6391 double every other digit insert other digits sum up all the resulting single digits If sum is multiple of 10, it\u0026rsquo;s good! This is designed to catch common data entry errors.\n Transposing adjacent digits Mistyping one digit  Hash #  A checksum that is much harder to compute, and used to verify the integrity of a file\n   Hash Bits     MD5 128 bits   SHA256 256 bits   SHA512 512 bits   RipeMD-160 160 bits    These hash values has the same idea as a checksum, but are much bigger. This can be analogous with a coffee grinder. The grinder grinds up a bunch of beans, then a scoop is taken out (the hash). These can\u0026rsquo;t be reversed because only a portion of the \u0026ldquo;beans\u0026rdquo; were used as the hash. If working with a huge file (a bucket of beans), a scoop is taken, grinded, then a scoop of that is taken and added to another scoop of beans, where the process repeats. This gives an even representation of the file.\nBash:\necho -n \u0026#34;Hello\u0026#34; | md5 echo -n \u0026#34;Hola\u0026#34; | md5 These hashs work in a chain, and use the last \u0026ldquo;scoop\u0026rdquo; in the next so that the entire data structure is represented. The domain is almost infinity, and the range is 2^ number of bits in hash. The chances of 2 documents having the same checksum is 1 in 2^b where b is the number of bits\n Mar 13, 2019 #  More hashing #   MD5  Message digest version 5   SHA256  Secure hashing algorithm   SHA512 RipeMD-160  How many possible n-char passwords?\n 8 character password (only letters)  52^8 = 5.3e13   8 character with numbers  62^8 = 2.2e14   9 character only letters  52^9 = 2.7e15    What makes a good hashing algorithm?\n Should be computationally expensive, but not too expensive  MD5 used to be considered a good hash, now it is too easy (fast)   Outputs should be evenly distributed  Think plotting the on a histogram   Easy to go one way, hard to go the other Pre-image resistance  For a given hash (h) it should be hard to guess the original message (m), such that hash(m) = h   Second pre-image resistance  For a given message (m1), it\u0026rsquo;s hard to find another message (m2), such that hash(m1))   Collision resistance  Hard to find two messages (m1, m2) such that hash(m1))     Mar 18, 2019 #  Symmetric vs. Asymmetric encryption #  Symmetric:\n Both parties share a secret key Faster then asymmetric  Alice and Bob want to communicate, Eve is the eavesdropper. How do Alice and Bob keep Eve from obtaining the key?\nPublic Key Cryptosystems (asymmetric):\n This solves the \u0026ldquo;key-exchange\u0026rdquo; problem.  RSA #  R: Rivesst\nS: Shamir\nA: Adelman\n Pick two primes p \u0026amp; q  p = 13, q = 47   Calculate n)  n = 611   Calculate totient(n)  totient(611)) = 552   Find e, such that 1 \u0026lt; e \u0026lt; totient(n) and e \u0026amp; totient(n) are coprime  These can easily be found using our gcd() function 271   Find d such that e is the multiplicative inverse of e and totient(n)  e * d) 271 * d mod 552 = 1 d = 55   Throw away p, q, and totient(n)!  3 Ways to find multiplicative inverse\n Loop Extended GCD Euler\u0026rsquo;s Theorem  RSA Formulas:\n c = p^e mod n p = c^d mod n  (e, n) is one key\n(d, n) is another key, you choose which you want to keep private\nFor communication:\n Alice and bob want to communicate They both independently go through the RSA calculations Alice\u0026rsquo;s  public key Apub) private key Apriv (da, na)   Bob\u0026rsquo;s  public key Bpub) private key Bpriv)   Alice wants to send Bob a message such that only Bob can read it.  A: plain -\u0026gt; Bpub -\u0026gt; cipher B: cipher -\u0026gt; Bpriv -\u0026gt; plain    Let\u0026rsquo;s try:\nHi! Alice\u0026#39;s message H i ! 72 105 33 Ascii values Using Bob\u0026#39;s public key Alice can encrypt 474 248 266 e = 271, n = 611 72 105 33 Bob uses his private key to decrypt d = 55, n = 611 How can Eve decrypt the message?\n Eve has  both public keys  Composed of 2 pieces (e and n)   ciphertext Eve needs d to decrypt  However to calculate the totient of n Eve will need to factor n (it is composed of 2 large prime factors) She needs to factor n into p and q This is a hard problem       Quantum computers have Shor\u0026rsquo;s Algorithm that can factor a number quickly\n  Apr 20, 2019 #  Communicating using public-private key cryptography #  Alice and Bob both generate independent sets of keys.\n Alice  Apub Apriv   Bob  Bpub Bpriv    Alice wants to send Bob a message so that only Bob can read it.\n She needs to run her plaintext thru Bob\u0026rsquo;s public key to obtain ciphertext. A: p -\u0026gt; Bpub -\u0026gt; c B: c -\u0026gt; Bpriv -\u0026gt; p This gives us security  Alice wants to send Bob a message such that Bob knows it came from Alice:\n A: p -\u0026gt; Apriv -\u0026gt; cipher B: c -\u0026gt; Apub -\u0026gt; plain This gives us authenticity  Combining these gives both authenticity and security\n A: p -\u0026gt; Apriv -\u0026gt; Bpub -\u0026gt; cipher B: c -\u0026gt; Bpriv -\u0026gt; Apub -\u0026gt; plain This order matters! Otherwise Eve can unlock the outter \u0026ldquo;box\u0026rdquo; with Alice\u0026rsquo;s public key  Alice wants to send a message to Bob such that:\n Alice is the sender (authenticity) Bob is the recipient (security) Message has not been tampered with (integrity) A: p -\u0026gt; hash -\u0026gt; h  p + h -\u0026gt; Apriv -\u0026gt; Bpub -\u0026gt; cipher   B: c -\u0026gt; Bpriv -\u0026gt; Apub -\u0026gt; p + h  p -\u0026gt; hash -\u0026gt; h Compares hashes   This is called \u0026ldquo;signing\u0026rdquo; a document (computing hash, then locking with private key)  How do Alice and Bob know the public-keys are authentic?\n Public keys are embedded in a digital certificate  How can Eve decrypt the message?\n Eve knows Apub, Bpub, and ciphertext Both public keys are split into  e n   Eve needs d to decrypt e * d) To calculate phi Eve must factor into p and q, this is very hard  The Real RSA #  OpenSSL\nopenssl genrsa -out keyfile.pem 2048 openssl rsa -in keyfile.pem -pubout -out key.pub more key.pub openssl rsa -in keyfile.pem vi plaintext.txt openssl rsautl -pubin -inkey key.pub -endcrypt -in plaintext.txt -out ciphertext.txt  Apr 3, 2019 #  Spam filtering #  To a spam filter: a message is just a set of words.\n \u0026ldquo;Hello I will say Hello\u0026rdquo;  The filter splits the words up and compiles some information about them. It creates a dictionary.\n   Word Occurences     Hello 2   I 1   will 1   say 1    P(\u0026ldquo;Hello\u0026rdquo;) = 2/5\nP(\u0026ldquo;will\u0026rdquo;) = 1/5\nP(\u0026ldquo;today\u0026rdquo;) = 0\n Apr 10, 2019 #  Graphs #  Planar graph: any graph that can be drawn on flat paper without crossing edges\nThe graph coloring problem: also known as the cartographers problem. To find the minimum number of colors needed to color a map. Its proven to be no more then 4, but finding the minimum is known as a \u0026ldquo;intractable problem\u0026rdquo;.\nA lot of problems can be turned into graph problems.\n Shortest path Spanning tree  Connecting cable to a housing development using the least cable possible   Travelling salesmen CEO  Minimize a metric on a graph (cheapest, shortest, time-spent\u0026hellip;)    Terminology\n Vertex  point on the graph   Edge  Normal  Connects 2 vertex   Directed edge  Edge that goes one way   Weighted edge  Has a value associated with the edge (cost, distance\u0026hellip;)     Fully connected graph  Each vertice is connected to each other   Disconnected graph  Not all vertices are connected to each other    Trees #   A graph built down from a root with leaves Interior nodes are vertices that aren\u0026rsquo;t leaves Depth-first traversal  Search as deep as possible before exploring another branch Pre-order depth first traversal  As soon as you encounter a node, you record it (think binary search tree)   Post-order depth first traversal  As you encounter a vertex, you record it the second time you encounter it Could be used to turn high-level language into assembly This puts the operation in postfix!   In order depth first traversal  This puts the operation back to how it was This could be used to turn a high-level language into another high-level language (java \u0026lt;-\u0026gt; c)     Breadth-first travesal  Search all neighbors before going deeper     Apr 22, 2019 #  Minimal spanning tree #  How to\n Initialize the set of visited vertices with any vertext from the graph. Iniialize the set of unvisited vertices to be all but the starting vertex Consider each of the unvisited neighbors of the bisited set. Identify the neighbor with the lowest edge weight Add the neighbors to the visited set. Remove it from the unvisited set. If the unvisited set is empty, we are done. Otherwise go back to step 2.  Greedy algorithm: Looks at the information it has at the moment, doesn\u0026rsquo;t look ahead.\n Make a decision based on information you have and no more. Make best decision and don\u0026rsquo;t change your mind.   Apr 24, 2019 #  Finite State Machine #  There is a starting or initial state and one or more accepting states. Vertices are states, and edges are transitions. Strings describe pathes along the machine, and there are an infinte number of strings because of the looping nature of them. The set of all accepting strings is a language.\nHow a program gets compiled #  Scanning\n Goes thru program and finds and identifies tokens   Apr 29, 2019 #  Compilers continued #  grammar blub; program: (assignment | print)* ; assignment: IDENT ASSIGNOP expr SEMICOLON ; expr: expr (\u0026#39;*\u0026#39;|\u0026#39;/\u0026#39;) expr | expr (\u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;) expr | IDENT | INT ; print: \u0026#39;print\u0026#39; expr SEMICOLON ; IDENT: (\u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;|\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;|\u0026#39;_\u0026#39;)(\u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;|\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;|\u0026#39;0\u0026#39;..\u0026#39;9\u0026#39;|\u0026#39;_\u0026#39;)* ; ASSIGNOP: \u0026#39;=\u0026#39; ; SEMICOLON: \u0026#39;;\u0026#39; ; INT: (\u0026#39;+\u0026#39;|\u0026#39;-\u0026#39;|\u0026#39;0\u0026#39;..\u0026#39;9\u0026#39;)(\u0026#39;0\u0026#39;-\u0026#39;9\u0026#39;)* ; WS: (\u0026#39; \u0026#39;|\u0026#39;\\n\u0026#39;|\u0026#39;\\r\u0026#39;|\u0026#39;\\t\u0026#39;) -\u0026gt; skip ;  May 1, 2019 #  State machines cont. #  Deterministic state automaton\n Where each state only has one choice, no ambiguous choices.  Non-deterministic state automaton\n State machines that have multiple choices for each state (for example one state could have multiple routes labeled \u0026lsquo;x\u0026rsquo;) All NFAs can be converted to an equiavlent DFA   May 6, 2019 #  NFA with epsilon transition #  The epsilon transition is basically like a free door that doesn\u0026rsquo;t consume any letters.\nThompson\u0026rsquo;s constructions are a general (generic) way of converting a regex to NFA without a lot of analysis.\n May 8, 2019 #  Transform Regex into DFA\n Transform regex into NFA using Thompson\u0026rsquo;s constructions Transform into DFA  Transform NFA into table Transform NFA table into DFA table     May 13, 2019 #  Mealy and Moore Machines #  A state machine without a accepting state, it just outputs a stream.\nTakes a input of a string and outputs another string.\nMoore machine is a \u0026ldquo;dual\u0026rdquo; of a Mealy machine. (This means you can turn a Mealy into a Moore and vice versa)\nA Moore machine takes an input, but instead of the output on the transition, the states are the outputs. Moore machines always output something at the first state(the start). If this isn\u0026rsquo;t what you want, the solution is to add an initial state that doesn\u0026rsquo;t output anything.\n May 15, 2019 #  Data compression (text) #  Text compression should be lossless, in that none of the information is actually able to be put back after compressed.\nHuffman encoding\nTHE CAT IN THE HAT CAME BACK\nStart by creating a dictinonary for all the letters\nT H E C A I N M B K _ 4 3 3 3 4 1 1 1 1 1 6 Then order for frequency\n_ T A H E C I N M B K 6 4 4 3 3 3 1 1 1 1 1 Combine the 2 lowest items\n_6 T4 A4 H3 E3 C3 BK 2 N1 M1 _6 T4 A4 H3 E3 C3 NM2 BK2 I1 _6 T4 A4 H3 E3 C3 BKI3 NM2 _6 BKINM5 T4 A4 H3 E3 C3 EC6 _6 BKINM5 T4 A4 H3 AH7 EC6 _6 BKINM5 T4 BKINMT9 AH7 EC6 _6 EC_12 BKINMT9 AH7 BKINMTAH16 EC_12 BKINMTAHEC_28 Then build a tree out of the combinations of these and assign 0s and 1s to the branches to get the new bitcodes\n #  "}),a.add({id:309,href:'/notes/CS26/CS26-reading-notes/',title:"CS26-reading-notes",section:"CS26",content:"CS 26 Reading Notes #   Ch. 1 Number Representations  Ch. 1 Number Representations #  Theorem 1\nLet b be an integer greater than 1. Then if n is a positive integer, n can be expressed uniquely in the form\n  \\(n=a_k ·b^k \u0026#43;a_{k−1} ·b^{k−1} \u0026#43;···\u0026#43;a_1 ·b^1 \u0026#43;a_0 ·b^0 \\)  where  \\(k\\)  is a nonnegative integer,  \\(a0, a1, · · · , ak\\)  are nonnegative integers less than  \\(b\\)  and  \\(ak ≠ 0\\)  .\n The real utility and power of two’s complement is that one can add pairs of two’s complement numbers (whether positive or negative) in the usual way, and the result will be the correct answer, in two’s complement! In the following examples, superscripts in the binary addition represent carries.\n"}),a.add({id:310,href:'/notes/CS39/CS39-lecture-notes/',title:"CS39-lecture-notes",section:"CS39",content:"CS 39 Lecture notes #  Aug 21, 2018 #  Using ARM assembly language\nRISC - reduced instructions set computer\nARM is a British company that designs intellectual property, now owned by a japanese company (Softbank).\nLast year there was 14 billion ARM chips produced\nSoftware you need:\nKeil ARM MDK - software development kit for M-series microcontrollers\nwww.keil.com\n(Windows only)\n[X] Download Keil tool [2018-08-23]\n Aug 23, 2018 #  A diagram of almost everything\n World -\u0026gt; Sensors\nSensors -\u0026gt; Signal conditioning\nSignal conditioning -\u0026gt; Analog to digital\nAnalog to digital -\u0026gt; cpu\ncpu \u0026lt;-\u0026gt; memory\ncpu -\u0026gt; output\n Place value = ${base}^{position}$\nBYTE = BinarY TErm\nBIT = Binary digIT\nA byte is the smallest addressable unit of space in memory, typically 8 bits in microcomputers.\n Aug 28, 2018 #  Read numbers and codes\nTake numbers and codes quiz\nASCII (7-bit code, 0-127)\nUnicode (16 bit)\nCPU Instruction Cycle\n Fetch instruction Decode the instruction Execute Repeat  Inside CPU lives the General Purpose Registers Program Counter holes the next instruction to fetch\nMDK Instructions #  Put project in new folder\nChoose M0 Cortex chip\nChoose CMSIS core\nand Startup Code\nAREA |.text|, CODE, READONLY EXPORT __main __main MOVS R0, #1 MOVS R4, #3 ADDS R7, R0, R4 done B done END A simple program that adds 2 numbers, in this case the numbers 1 and 3 are stored in R0 and R4. Then it adds them and puts the result in R7​. To end the program and ensure it doesnt run through memory forever, you add a loop that calls back to itself, in this case done. Note that you must put an enter after the END.\nRemember in µVision: Debug using the simulator under the magic wand icon.\n Aug 30, 2018 #  Part number for the chip we’re using - NUCLEO-L432KC\nA directive is information for the tool itself. AREA is a directive, it doesn’t produce any machine code technically.\n.s files are just text files, not until they are assembled (by a program) is it then turned into a .o file (object code). These .o files are machine code.\nThe memory map of our chip (32 bit machine) starts at 0x00000000 and goes to 0xFFFFFFFF. In the low memory address is program memory (flash), 32kB. At 0x20000000​ RAM begins, 8kB. I/O and peripheral devices are below the RAM, such as timer/counters and USB.\nAREA |.text|, CODE, READONLY EXPORT __main __main ;Code goes here done B done END AREA |.text| directive tells the code to go to the .text area. CODE means it is in the code segment of the file. READONLY means it lives in the memory.\nEXPORT​ gives it an entry point to the label __main. A label is just a point of reference, a named memory location, labels turn into addresses. Labels go into lines that you need to refer to. done is the label of the loop to end it. B means unconditional branch, meaning you always go to this, never skip it. END means there is no more code to assemble, it always needs a carriage return after.\nEvery line of assembly #  ​label mnemonic operands; comments\n label must be against the left side mnemonic is our instructions operands are the parameters of the mnemonic comments come after the semicolon     Starting file    ending file     .s -\u0026gt; assembler -\u0026gt; .o (startup files)   .c -\u0026gt; c compiler -\u0026gt; .o (startup files)   .s -\u0026gt; assembler -\u0026gt; .o (our file)    All of those .o files are then put into a linker, which resolves external references. meaning it looks through all the .o modules and links the references. Generates the core image (the actual machine code file that has all the pieces assembled and put together). The core image is then burned into a chip, (or in our case simulated).\nExample variables for arithmetic:\n R0 : a\nR1 : b\nR2 : c\nR3 : d\na + b - c + 3\n ADDS R0, R0, R1; adds a + b SUBS R0, R0, R2; (a + b) - c ADDS R0, #3; (a + b - c) + 3  Sep 4, 2018 #  Expression evaluation #   R0 : a\nR1 : b\nR2 : c\nR3 : d\n To multiply a by 2, you can write ADDS R0, R0, R0\n a + b + c * 2\n ADDS R2, R2, R2; multiply c by 2 ADDS R0, R0, R1; adds a + b ADDS R0, R0, R2; adds (a + b) + (c * 2) This is a code fragment.\nTo write this as a complete program with:\n a = 5\nb = 2\nc = 7\n AREA |.text|, CODE, READONLY EXPORT __main __main MOVS R0, #5; a MOVS R1, #2; b MOVS R2, #7; c ADDS R2, R2, R2; multiply c by 2 ADDS R0, R0, R1; adds a + b ADDS R0, R0, R2; adds (a + b) + (c * 2) LDR R7,) STR R0, [R7]; store R0 in the location specified by R7 LDR R4, [R7]; loads R4 with variable at 0x2000 000 in RAM done B done END When you run out of registers, you can store variables in RAM (RAM starts at 20 million hex (0x2000 0000)). When storing something in RAM it takes 2 clock cycles. The chip we are using only supports indexed addressing. This means you need to specify the address you use to specify the address of the RAM (a pointer). Usually use R6 and R7. LDR is used to specify registers in RAM. STR can be used to store it in RAM. To load back into a register you can use LDR also. RAM can only use the LDR and STR instructions, if you need to perform arithmetic on a stored variable, you need to load (LDR) it into register to work on it.\n Sep 6, 2018 #  MOVS moves data and updates the flags. MOV doesn’t update the flags. Instructions with the S update flags.\nRAM space: 0x2000 0000 is the beginning of RAM space (32 bits wide) 0x2000 0004 is the next space\n32 bits = word 16 bits = half-word 8 bits = byte\nLDR and STR work with 32 bit numbers. On RISC machines you must use indexed addressing.\nTo use an offset:\nLDR R5, [R7,#4] uses an offset of 4 to point to the address at 0x2000 0004 (After specifying the address of the first slot in memory with LDR R7,=0x20000000​)\nExample of C++ code to turn on and off LED and run a function called myFunc, which is defined in the .s file below\n//#include \u0026#34;mbed.h\u0026#34;  extern \u0026#34;C\u0026#34; int myFunc(int a, int b, int c); //a b and c correspond to registers R0, R1, R2 respectively  DigitalOut myled(LED1); Serial pc(USBTX, USBRX); int main() { pc.printf(\u0026#34;myFunc); pc.printf(\u0026#34;myFunc); while(1) //\u0026#34;Heartbeat\u0026#34;, this turns the LED on and off, a good way to see if the program is running  { myled = 1; //LED is ON  wait(2.0); //Wait 2 sec  myled = 0; //LED is OFF  wait(1.0); //Wait 1 sec  } } In another .s file:\nAREA |.text|, CODE, READONLY EXPORT myFunc myFunc ADDS R0, R0, R1; a + b ADDS R0, R0, R2; + c BX LR; branch exchange with link register (return) END  Sep 11, 2018 #  Shifting bits #  LSLS is a logical shift left. Multiplies by powers of 2. ($2 ^ {bits}$)\nLSRS is a logical shift right. Divides by powers of 2. ($2 ^ {bits}$)\nThese commands use a barrel shifter, takes 1 clock cycle. (Takes a lot of hardware real estate though)\nLSLS 1 bit shift left example:\n 0101 = 5 decimal\n    0011 = 3 decimal\n0110 = 6 decimal\n1100 = 12 decimal\n LSLS R0, R0, #2 shifts the register R0 by 2 to the left, then places the answer back into R0. The bit that is shifted \u0026ldquo;off\u0026rdquo; the number is transferred into the carry bit. This makes the LSLS command really useful to shift numbers into the carry flag. If you wanted to print a binary number to the screen you could individually shift numbers into the carry flag, add 0x30 to it and get the ASCII code for 1 and 0.\nLSRS 1 bit shift right example:\n 1100 = 12 decimal\n0110 = 6 decimal\n  0111 = 7 decimal\n   LSRS R3, R1, #4 effectively divides R1 by 16 ($2^4$) and puts the answer in R3\nExamples:\nLDR R0,=0x00000007 ; loads R0 with 7 LSLS R0, R0, #2 ; logical shift left 2 bits, answers 0x0000001C (7 * 4) LDR R0,=0xC0000000 ; loads R0 with 0xC0000000 LSRS R0, R0, #1 ; shifts to the right 1 bit, answers 0x60000000 (half of 0xC)  Sep 18, 2018 #  Logical instructions (bitwise) #  AND gate:\n   a b a \u0026amp;\u0026amp; b     0 0 0   0 1 0   1 0 0   1 1 1    ANDS R0, R1 is the biwise AND gate to compare two registers. Can be used to isolate a group or a single bits. Typically used to compare a value with a \u0026lsquo;mask\u0026rsquo; value.\nLDR R0, =0xABCDEFA5; input MOVS R1, 0xF; mask ANDS R0, R1 Returns 0x00000005 in the R0 register. ANDS basically clears out all the unwanted bits specified by the register R1. (Remember 0xF is 1111 in binary, so the 5 gets passed through).\nOR gate:\n| a | b | a || b | | :\u0026mdash;: | :\u0026mdash;: | :\u0026mdash;\u0026mdash;: | | 0 | 0 | 0 | | 0 | 1 | 1 | | 1 | 0 | 1 | | 1 | 1 | 1 |\nOR turns a bit on if one or the other bit is on.\nLDR R0, =0xABCDEFA5; input LDR R1, =0xF0000000; mask ANDS R0, R1; and MOVS R2, #3 ORRS R0, R2; or Returns 0xA0000003 in the R0 register. Because the A was left in the register because of the ANDS and then turns on the 3 in the last bit because of the ORRS.\nTo clear a bit ANDS it with 0\nTo pass a bit ANDS it with a 1\nTo set a bit ORRS it with a 1\nNOT gate:\n   a !a     0 1   1 0    LDR R1, 0xF0000000; mask MVNS R3,R1; not the R1 register Returns 0x0FFFFFFF into the R3 register. MVNS is the NOT operator for this chip (move register and not).\nExcluse OR (EOR):\n   a b a EOR b     0 0 0   0 1 1   1 0 1   1 1 0    One or the other, but not both.\nLDR R0, =0xABCDEFA5 LDR R1, =0xA5A5A5A5; mask EORS R0, R1; Returns 0x0E684A00. Everything that matchs gets zeroed out. Running the EORS R0, R1 command again will return the register to the original. This can be used to encrypt.\nC-\u0026gt;asm #  Start using a .c file in microvision.\nextern int myFunc(int a, int b, int c); int main(void) { int x; x); } extern means that the function exists in another block of code. Does need a semicolon after this method header because its connected to the extern. This file also needs a carriage return after the last curly brace.\nIn a .s file (thats named differently then the .c file)\nAREA |.text|,CODE,READONLY EXPORT myFunc myFunc ADDS R0, R0, R1; add a + b SUBS R0, R0, R2; subtract c BX LR END BX LR is the return. The variables in the myFunc.c will coorespond to the registers starting at R0 onwards (a).\n Sep 20, 2018 #  Embedded C Programming #  History\nDeveloped at Bell Labratories in the 70s. Dennis Ritchie and Ken Thompson developed this language. C was derived from the high-level assembly language B. Major goal of C was systems programming. The UNIX operating system was re-written in C. Today C is widespread use with a rich standard library of functions. C is the standard language of microcontrollers, this is because C generates small amounts of code compared to other languages (C++ for example).\nWhy C?\nFlexible language that imposes few constraints on the programmer. Allows low level access to data, operating system, and hardware. Retains the portability and sophisticated syntax of a high-level language. Supports pointers and bitwise operators. Weak type checking (Good or bad?). Designed for modular programming (for example when we had a .s file and a .c file). Extensive use of libraries. The lingua franca of embedded systems programming. Not object-oriented, but can be used with an \u0026ldquo;object-oriented mindset\u0026rdquo;.\nSimplest embedded program\nint main() { while(1); } This compiles sucessfully but doesn\u0026rsquo;t do anything.\nSlightly more useful program:\n//#include \u0026#34;mbed.h\u0026#34; (this line breaks the auto-toc)  Serial pc(USBTX, USBRX); //a little c++  int main() { pc.printf(\u0026#34;Hello world\\n\\r\u0026#34;); while (1); //infinite loop } Some key elements of a C program:\n;\n The semicolon is a statement terminator (just like in Java) The simplest expression is a semicolon alone.  {}\n Curly braces delineate the beginning and end of a function Curly braces also group statements so they are treated as one block  \u0026quot;text\u0026quot;\n A string is delineated with double quotes  comments\n // or /* */ are comment delimiters  Identifiers in C:\n An identifier is a name of something in your prograrm  a function, variable, constant   Identifiers begin with a letter or underscore (_)  Followed by a sequence of letters, digits, or underscores Its not good practice to start a identifier with an underscore, because it is reserved identifiers generated by the compiler   Identifiers are case sensitive Identifiers can be any length, but  some compilers recognize only a limited number of characters (usually 32 characters). This means if 2 identifiers use the same name up to 32 characters they will be treated as the same identifier, even if the characters after are different.   Reserved words cannot be used as identifiers  What are some reserved words in C? i.e. auto, break, case, char, continue, default, extern    Variables:\nVariables represent a value that can be changed. Variables are declared by indicating the type followed by an identifier.\nint dogs, cats; unsigned char portInput; float price; Variables are stored in the relatively small RAM of the microcontroller. The programmer must declare the type, and therefore the size of each variable.\nVariable scope:\nThe scope of a variable is its accessibility within the program.\n Local Variables  Declared within a function Memory space is allocated when a function is entered Generally, memory space is released when function exits (returns) Can only be accessed from within the function they are declared You can use the same local variable declarations in multiple functions since the compiler sees the local in functions independently   Global variables  Can be accessed by all the functions in a program (unlimited scope) Global variables can be modified by any function and will retain their value as long as the program is under execution    Constants:\n Constants are fixed values In microcontroller programs, constants are usually stored in read-only memory  This saves RAM for variables   Consider this assignment  z = rho + 5; the five is a numeric constant and becomes part of the code that performs the addition.   You can declare a named constant as follows:  const type identifier = expression; i.e. const int myIntConstant = 25;   Numeric constants can be declared with base or type Decimal is the default base  1695   Binary constants begin with 0b prefix  0b01000001   Hexadecimal prefixed with 0x  0x1234ABCD   You can specify the type of a numeric constant with a suffix  4000U, U is for unsigned 15.1F, F is for float   Character constants are enclosed in single quotes  'M'    Operators and expressions:\n Variables are assigned using the = A numeric expressions can be on the right side of the assignment operator   Sep 25, 2018 #  Compare #  CMP is the instruction that compares registers. CMP R0, #5 compares register R0 to the immediate 8 bit number 5. It subtracts the register with the number, if the zero flag is turned on then it means that the comparison is \u0026ldquo;true\u0026rdquo;, \u0026ldquo;set\u0026rdquo;, or \u0026ldquo;logic level one\u0026rdquo;. This is often used in conjunction with the branch conditional instruction, Bcc (pg. 34).\nCMP R0, #5; checks if R0 is 5 BEQ doStuff; BEQ means branch if equal, checks if the zero flag is 1 ;code to skip here doStuff Bcc Conditional Branch    Specific Flag Tests Meaning Flags affected     BEQ Branch if equal z == 1   BNE Branch if not equal z == 0   BCS Branch if carry is set c == 1   BCC Branch if carry is clear c == 0   BMI Branch if minus, negative n == 1   BPL Branch if plus, positive n == 0   BVS Branch if overflow v == 1   BVC Branch if no overflow v == 0       Unsigned/signed tests Meaning Flags affected     BEQ Branch if equal z == 1   BNE Branch if not equal z == 0   BHI Branch if higher c == 1, z == 1   BLO Branch if lower c == 0   BHS Branch if higher or the same c == 1   BLS Branch if lower or same c == 0, z == 1    if statement:\nFor example to translate:\nif (a) { a = b + 2; } In assembly:\n a = R0\nb = R1\n CMP R0 #5; compares a to 5 BNE endif1; branch if not equal, checks if zero flag is 0 MOVS R1, R0; move b into a ADDS R0, #2; b + 2 endif1 Look at the relationship of the high level language and make the opposite of the comparison.\nif..else:\nExample:\nif (a != b) { a = 5; } else //a == b { a = 1; } In assembly:\n a = R0\nb = R1\n CMP R0, R1; a != b ? BEQ else1; branch if equal, checks if zero flag is 1 MOVS R0, #5; a = 5 B endif1 else1 MOVS R0, #1; a = 1 endif1 Example with greater than:\nif (a \u0026gt; 5) { b = a + 2; } In assembly:\n a = R0\nb = R1\n CMP R0 #5; BLS endif1; branch if lower or equal, checks if carry flag is 0 and zero flag is 1 MOVS R1, R0 ADDS R1, R1, #2 endif1 One more if..else:\nif (a \u0026gt;= b) { a = 0; } else { a = 42; } In assembly:\n a = R0\nb = R1\n CMP R0, R1; a \u0026gt;= b BLO else1; branch if lower, (opposite of \u0026gt;=), checks if the carry flag is 0 MOVS R0, #0 B endif1 else1 MOVS R0, #42 endif1 While loop:\ncount = 0; while (count \u0026lt; 5) { count++; } In assembly:\n count = R4\n MOVS R4, #0; initilize count while1 CMP R4, #5; compare R4 to 5 BHS endwhile; unsigned higher or same, checks if carry flag is 1 ADDS R4, #1; increment count B while1; B alone is unconditional branch endwhile Calculating the length of a String #  In the first document LE3C.c, write a function called slen(char s[]) that takes a char array (String) as the parameter, (slen is short for string length). Also initialize the char array (String), myString[] and the int x. Then in the main() method set the variable x to the length of the string myString. Both variables are stored in memory because they are global.\nextern int slen( char s[] ): int x = 0; char myString[] = \u0026#34;anything you want.\u0026#34;; int main() { x); } Then in our LE3asm.s file, we write the assembly to do this:\n R0 is location in memory of myString\nR1 is char counter\nR2 is current character\n AREA |.text|, CODE, READONLY EXPORT slen slen MOVS R1, #0; char counter = 0 while1 LDRB R2, [R0]; current character pointer CMP R2, #0; compare for null terminator BEQ endWhile ADDS R1,#1; increment counter ADDS R0,#1; advance pointer B while1	endWhile	MOV R0,R1; put char count in return register BX LR; return END The commands after the BEQ check don\u0026rsquo;t need to be indented (and wouldn\u0026rsquo;t normally), but it helps to better visualize what is inside the loop.\nCapitalize first letter of string #  Add to our LE3C.c file add a firstToUpper(char s[]) method that takes an array of chars (String) as parameter. Note we call that method before our slen method in the main().\nextern int slen( char s[] ); extern void firstToUpper( char s[] ); int x = 0; char myString[] = \u0026#34;anything you want.\u0026#34;; int main() { firstToUpper( myString ); x); } In LE3asm.s file, we must add another EXPORT at the top with our new function firstToUpper. Adding firstToUpper label down below the other code is perfectly legal. It must be added after the return (BX LR) of the slen function though. firstToUpper also needs it own new return (BX LR). Only one END with a carriage return is needed.\nAREA |.text|, CODE, READONLY EXPORT slen EXPORT firstToUpper slen MOVS R1, #0; char counter = 0 while1 LDRB R2, [R0]; current character pointer CMP R2, #0; compare for null terminator BEQ endWhile ADDS R1,#1; increment counter ADDS R0,#1; advance pointer B while1	endWhile	MOV R0,R1; put char count in return register BX LR; return ;--------------------------------------------------- firstToUpper LDRB R1, [R0]; load first character from string into R1 MOVS R2, #0xDF; mask to clear bit 5 ANDS R1, R2; clear bit 5 STRB R1, [R0]; put char back in string BX LR; return END firstToUpper starts by loading the first char (byte) into R1 using the LDRB (load byte). We MOVS the hexadecimal number 0xDF into R2 to be used as a mask. This mask is 1101 1111 in binary. This allows us to use the ANDS with the mask to minus 32 bit (the 0) from the number (changing it from the ASCII code of the lowercase letter to the ASCII code of the uppercase, 97 - 65).\n   Decimal Hexadecimal Binary ASCII     97 0x61 0b0110 0001 a   65 0x41 0b0100 0001 A     0b0110 0001 (0x61)\n0b1101 1111 (0xDF mask)\nAND\n0b0100 0001 (0x41)\n  Sep 27, 2018 #  Video lecture notes\nMemory Review #  Loading a variable from RAM into a General Purpose Register\n Point at the memory location of the variable Load the ariable from the pointer register location  LDR R7, =0x20000000; address of variable LDR R0, [R7]; copy data addressed by R7 to R0 Storing a variable into RAM from a General Purpose Register\n Point at the memory location of the variable Store the register value at the pointer register location  LDR R7, =0x20000000; address of variable STR R0, [R7]; copy value in R0 to location addressed by [R7] More if..else patterns #  if pattern:\nif (a) { b = 9; } In assembly:\nCMP R0, #5; a == 5? BNE endif1; if a != 5 then branch LDR R7) MOVS R1, #9; STR R1, [R7] endif1 if..else pattern:\nif (a) { b = 9; } else { b = 7; } In assembly:\nCMP R0, #5; a == 5? BNE else1; if a != 5 then skip if part LDR R7,) MOVS R1, #9; data to store in R1 STR R1, [R7] B endif; skip the else else1 LDR R7, =b MOVS R1, #7 STR R1, [R7] endif Remember: use the branch that is opposite the high-level operator\nSummary:\n Load variable before doing comparison Use the branch opposite of the relational operator after the comparison  This will skip the block if the Boolean expression is false   Place an unconditional branch at the bottom of the if-true block in order to skip the else  The if-block and else-block are mutually exclusive    mbed Compiler Notes #   Typically, no need to load variables before doing comparison  mbed compiler passes the first four parameters in R0-R3 The compiler will load the variables before calling your subprogram   In the following function definition, a is passed in R0, b is passed in R1 and so on\u0026hellip;\nextern \u0026quot;C\u0026quot; int my_asm(int a, int b, int c);\nWhen you call the function in your C code as follows:\nmy_asm(25, x, y + 2);\nThe compiler will load R0 with 25, R1 with the value of the variable x, which was declared in the C code, and R2 with the value of the C declared variable y plus 2.  The compiler generates code something like this:\nMOVS R0, #25; first parameter into R0 LDR R7,) LDR R1, [R7]; second parameter, x, into R1 LDR R7, =y; address of y into R7 LDR R2, [R7]; third parameter y into R2 ADDS R2, #2; add 2 to y BL my_asm; call your function (=x and =y are placedholders for where it is in memory for the sake of these notes)\nARM Architecture #  Data sizes and instruction sets\n ARM is a RISC architecture  Most instructions execute in a single cycle, orthogonal register set, load-store architecture   ARM is a 32-bit load-store architecture  The only memory accesses allowed are loads and stores (LDR and STR) Most internal registers are 32-bits wide   When used in relation to the ARM  Word means 32 bits (four bytes) Halfword means 16 bits (two bytes) Doubleword means 64 bits (eight bytes)   Most ARM cores implement two instruction sets  32-bit ARM Instruction Set 16/32-bit Thumb Instruction Set   Older cores support 16-bit Thumb Instructions only  Thumb-2 technology in current cores adds 32-bit instructions Maintains code density with increased flexibility    Processor Modes\n Most ARM cores have seven basic operating modes  Each mode has access to its own stack space and a different subset of registers Some operations can only be carried out in a privileged mode       Mode Description Privileged     Supervisor (SVC) Entered on reset and when a Supervisor call instruction (SVC) is executed Yes   FIQ Entered when a high priority (fast) interrupt is raised Yes   IRQ Entered when a normal priority interrupt is raised Yes   Abort Used to handle memory access violations Yes   Undef Used to handle undefined instructions Yes   System Privileged mode using the same registers as User mode Yes   User Mode under which most Applications/OS tasks run No    (These are modes for ARM A and ARM R chips, ARM M chips have 2 modes: User and Handler)\nIn ARM M chips:\n 13 General purpose registers  Registers R0 - R7 (low registers) Registers R8 - R12 (high registers)   3 Registers with special meaning/usage  Stack Pointer (SP) - R13 Link Register (LR) - R14 Program Counter (PC) - R15   Special-purpose registers  xPSR is the program status register  Conditional code flags  N) Z) C) V)        ARM Instruction Set\n All instructions are 32 bits long Most instructions can be conditionally executed Load/Store instruction set - no direction manipulation of memory contents   Oct 2, 2018 #   Midterm on Oct 16 [2018-10-16] Make midterm notes [2018-10-16]\n(Ch. 1 - 5 LCARpi, number conversions, covers instructions we\u0026rsquo;ve used, and can use booklet and one 8.5x11 piece of paper for notes)  Multi-word Arithmetic #  Our registers are 32 bits long. The right most position is position 0 and the leftmost is position 31.\nExample:\n R4 = 1111 1111 1111 1111 1111 1111 1111 1111\n Adding 1 to this register will clear all the 1s into 0s and turn on the carry flag and the zero flag (effectively loosing the number).\nTo add larger numbers then our register size ($2^{32}$ (32 bits)) you will need to use 2 registers at a time, one to specify the lower word and one the higher word.\nTo demonstrate this:\nLDR R4, =0xFFFFFFFF ADDS R4, #1 This clears R4 and turns on the carry and the zero flags.\nTo successfully add numbers bigger then 32 bits you must specify a register as the low word and another as the high word. This is a symbolic specification, the registers don\u0026rsquo;t actually get joined, just arithmetic on them can be performed on them individually and thought of them as being joined.\nLDR R4, =0xFFFFFFFF; low word 64 bit first var MOVS R5, #1; high word 64 bit first var MOVS R6, #1; low word 64 bit second var MOVS R7, #0; high word of 64 bit second var ADDS R6, R4, R6; add low words ADCS R7, R5; add high words and potential carry ADCS is add with carry, takes 2 registers and the carry flag into consideration. To add the first and the second 64-bit variables you must add the low words (with ADDS) then the high words (with ADCS).\nTwo\u0026rsquo;s Complement #   $2 ^ {(bits - 1)} - 1 = max$\n$-2 ^ {(bits - 1)} = min$\n For example in 8 bits:\n $2^{(8 - 1)} - 1)$\n$-2^{(8 - 1)})$\n (The reason you minus one from the max is to compensate for zero)\nTo go from positive to negative (for example in a byte) invert the bits and add 1\nFor example with the decimal number 5:\n $0101 = 5_{10}$\n$1010 + 1 = 1011 = -5_{10}$\n SXTB instruction:\nLDR R7, =0x2000000F; load R7 with first address of RAM LDRB R0, [R7]; loads byte into R0 This returns all 1s in the low byte but 0s in the rest of the register. This means that the signed number (-1) isn\u0026rsquo;t preserved. You must use a SXTB (sign extend) instruction which extends an 8 bit value to 32 bits and writes the result to the same register. Continuing from the above example, to preserve the signed number (-1):\nSXTB R0, R0; sign extend Effectively changing R0 from\n 0000 0000 0000 0000 0000 0000 0000 1111\n To:\n 1111 1111 1111 1111 1111 1111 1111 1111\n (Preserving the -1)\nASRS Arithmetic Shift Right #  The ASRS instruction is like the LSRS (logical shift right) instruction, however instead of always injecting a 0 on the left, it injects the same bit as the most significant bit. This means that if the number is signed it preserves the negative. Effectively this instruction divides by powers of 2 while preserving the sign.\n Oct 4, 2018 #  Counting characters in a string #  To count how many times a char occurs in a string:\npseudocode:\n point character pointer at first char in string while char isn\u0026rsquo;t null  read ASCII of current character if current character == searched char  increment count   increment char pointer    extern int charCount(char s[], char c) char myString[] = \u0026#34;aababac\u0026#34;; int x = 0; int main { x); } In assembly:\n myString will be stored in memory with register R0 pointing at it. The character thats being searched for will be stored in R1\n AREA |.text|, CODE, READONLY EXPORT charCount charcount MOVS R2, #0; initalize count nextChar LDRB R3, [R0]; get character CMP R3,#0; end of string? BEQ endloop CMP R3, R1; is char == c? BNE nextIteration ADDS R2, #1; count++ nextIteration ADDS R0, #1; advance pointer B nextChar endloop MOV R0, R2; put char count in return register BX LR END  Oct 9, 2018 #  Calculating arithmetic mean #  Using a 64 cell array, we can calculate the arithmetic mean of the cells. We are concerned with how fast the mean can be calculated. This will be an array that is passed by some c code.\nIn statsC.c:\nextern int mean64(short data[]); short myData[64]; int xbar; int main() { for(int i) { myData[i] = 8; } xbar); } short is a 16 bit data type, so we\u0026rsquo;re working with half words in our registers.\nIn statsAsm.s:\n R0 = address of array\nR1 = sum of array elements\nR2 = current array element\nR3 = loop counter\n AREA |.text|, CODE, READONLY EXPORT mean64 mean64 MOVS R1, #0;initialize sum MOVS R3, #64;initialize loop count loop1 LDRH R2, [R0]; get current element ADDS R1, R1, R2; add element to sum ADDS R0, #2; advance pointer SUBS R3, #1; loop count - 1 BNE loop1; branch if zero flag is on ASRS R1, #6; divide by 64 and preserve sign MOVS R0, R1; return result in R0 BX LR END You must advance the for loop by 2 because we are working with half words.\nClock cycles:\n512 clock cycles in the loop alone. Clock speed of our chip is 48MHz. To figure out the period $1/f$, where $f$ is the frequency ($1/48MHz$, ~21 nanoseconds). 519 total clocks * 21 nano seconds = 10,899, ~11 micro seconds.\n Oct 11, 2018 #  10,000 foot view (software organization) #  Problems and concerns when creating embedded systems. In real time systems the software has time dependencies.\n Soft real time  Can miss deadlines, doesn\u0026rsquo;t have an extreme consequence (games, game controllers)   Hard real time  Cannot miss deadlines, if you miss a deadline whatever you were producing is now invalid. May have severe consequences in the system.    Highly reliable software:\nSoftware that you don\u0026rsquo;t want to fail. Usually real-time. (Autopilots, landing gear deployment, jet engine fuel controllers). A special way to write software.\nSoftware organization:\n Super loop  Actions are in a non-stop loop, never ending. (not used in Highly-reliable systems). Used more when timing isn\u0026rsquo;t a concern   Cyclic executive scheduling  A lightweight scheduling mechanism A gold standard for highly reliable systems. Small scale projects (automotive industry, dashboard control) No distinct scheduling mechanism, can be handled with interrupts Used extensively in aerospace, avionics Most real-time applications do not require  general purpose multitasking (or preemption) disk access printing   Full blown OS not necessary Scheduling Frames  Major/minor frames provide a way to organize repeating \u0026lsquo;processes\u0026rsquo; Major frame usually 1 second, but can be any consistent duration \u0026lsquo;Process scheduling\u0026rsquo; is defined by what will be computed during each minor frame Minor frame rate varies from 4/sec up to 100/sec Most important tasks occur first in minor frames, and the less important goes toward the end of the minor frame. Each time the timer goes off the task that is still executing will be cut off and switched to the next minor frame. The tasks are usually controlled by a switch statement. Frames are usually left with some head room after the tasks, to allow for other interrupts to occur (from a data port for example) Sum of subprogram execution times cannot exceed minor frame time limit.   Pros  Great for periodic systems intuitively obvious HRT processes not preemptive  no shared data problem   Lightweight, low overhead scheduler Proven technique   Cons  Difficult to load balance Processes rates limited by minor frame Time consuming processes must be split into shorter pieces Fragile: may break if you add a process, remove a process, or chance process order Difficult to incorporate sporadic process     Real-time OS  A highly reliable operating system used in real-time systems (however cyclic executive are used more so). (Wind River OS, for example). Allows us to create tasks (functions), and the OS will execute the tasks in turn. (Pre-emptive operating system). The system has a timer that periodically goes off, and the OS will use a context switch (save registers to memory), and go to the next task (and load its registers). One task can supercede another task in a pre-emptive system. If a shared variable is being used with multiple tasks, if a task gets pre-empted, the variable might not be fully updated. If the code is interrupted in the middle of a task, the instruction is completed and a \u0026lsquo;bookmark\u0026rsquo; is left in the task. Instead of turning interrupts off and on after the variable is used, you can use a semafor, a \u0026lsquo;flag\u0026rsquo; that says that the variable is in use in another task and must be completed before it can be used, so the task will pre-empt itself.     Oct 16, 2018 #  LEDs and Switches #  Switches\n   Digital Voltage     0 0 volts (ground)   1 3.3VDC    EMF), think of as a pressure.\nLEDs (light emitting diode)\nDiodes let power go one way, consists of anode (+) and cathode (-).\nOhms Law:\n $V = IR$\n V is voltage\nI is current\nR is resistance\nOur LEDs use 2ma, so $I).\n $R = \\frac{ V_{sys} - V_f }{ I_{LED} }$\n  Oct 18, 2018 #  Code conversion #  Binary -\u0026gt; ASCII hex\nTo change the byte 0100 0001 to ASCII, you\u0026rsquo;d have to run it through some code conversion software. That way the correct number will be shown instead of the ASCII letter \u0026lsquo;A\u0026rsquo;. A dumb terminal can\u0026rsquo;t differentiate what you want to do with certain information, all it does it show the ASCII codes for the binary patterns it receives. So by converting our original 65 into a 6 and a 5 in binary, it will show correctly.\nSome c code to show conversion from a PC to the embedded system and back to PC.\nSerial pc(USBTX, USBRX); //tx, rx  int main() { pc.printf(\u0026#34;Hello world\\b\\r\u0026#34;); pc.putc(65); //putc outputs one character  pc.printf(\u0026#34;\\n\\r\u0026#34;); //flushes buffer with a carriage return and line feed  while(1) { pc.putc( pc.getc() ); //echo input back to terminal  } }    4 bit number ASCII Hex     1010, 0xA 0100 0001, 65$_{10}$, 0x41, \u0026lsquo;A\u0026rsquo;    The best way to convert these numbers into hex is table lookup.\nAREA |.text|, CODE, READONLY EXPORT BtoAH BtoAH ;R0 will contain 4 bit number to convert to ASCII hex ;Output: ASCII hex char LDR R1,=ASCIIhexTable; address of table into R1 LDRB R0, [R1, R0]; copy char into R0 from table using R0 as the offset BX LR ASCIIhexTable DCB \u0026quot;0123456789ABCDEF\u0026quot;; define constant byte END  BtoAH stands for binary to ASCII hex\n In c:\nextern char BtoAH(int n); // 0 to 15 char asciiChar; int main() { asciiChar); }  Oct 23, 2018 #  Lab 4: 32-bit Binary to ASCII hex (B32toAH) #   Complete L4 [2018-10-23]  Continuing from the code conversion above. This can be possible by using our 4 bit code converter, counted loop, and left and right shifts.\nIn B32toAH.c\nextern void B32toAH(int n, char s[]); char buff8[9]; //one extra spot for null terminator on end  int main() { B32toAH(0xABCDEF01, buff8); } B32toAH returns void, however the second parameter (char s[]) will be the result, we will be modifying it but not returning it technically.\nIn B32toAHasm.s\nAREA |.text|, CODE, READONLY EXPORT B32toAH B32toAH ; R0 32-bit number to convert ASCII hex, passed by c ; R1 address of string buffer, passed by c ; R2 shift counter and loop count ; R3 preserve original number in R0 ; R4 char read from ASCII table ; R5 points to first char in ASCIIhexTab lookup table PUSH {R4, R5}; preserve R4 and R5 MOVS R2, #0; initialize left shift count and loop count to 0 MOVS R3, R0; preserve R0 into R3 LDR R5, =ASCIIhexTab; load R5 with address of lookup table while1 LSLS R0, R2; shift left by shift count LSRS R0, #28; shift most significant byte to least significant byte LDRB R4, [R5, R0]; load low byte into R4 STRB R4, [R1]; store byte from R4 into the location of our string in RAM ADDS R1, #1; increment string pointer by 1 ADDS R2, #4; increment shift counter by 4 MOVS R0, R3; restore original number CMP R2, #32; shift count != 32 BNE while1 MOVS R5, #00; temporarily put 00 in R5 STRB R1, [R5]; end string with null terminator POP {R4, R5}; restore R4, R5 BX LR; return ASCIIhexTab DCB \u0026quot;0123456789ABCDEF\u0026quot; END First off we\u0026rsquo;ll want to point at the ASCII hex table, then preserve the original string before we start shifting. Anything above R3 must be preserved when the code returns, so to preserve the higher registers we\u0026rsquo;ll need to use the stack. You want to preserve the registers in the stack first, and restore them once the subprogram has completed. PUSH and POP can be written using hyphens and/or commas (hyphens go thru from the start to the end), and must use curly braces (i.e. PUSH {R4-R6, R10}). The stacks grows toward low memory.\n Oct 25, 2018 #  More code conversion: ASCII decimal -\u0026gt; binary #  For example if the user enters the number \u0026lsquo;25\u0026rsquo; on the keyboard, the ASCII codes for that is technically 0x32 and 0x35, and we want to convert it into 0x00000019 (25 in binary) so we can work on it arithmetically.\n   ASCII Hex     \u0026lsquo;2\u0026rsquo; 0x32   \u0026lsquo;5\u0026rsquo; 0x35    If we minus 0x30 from the ASCII code, we will end up with the value intended in hex, which will then be converted to binary when compiled.\nIn ADtoB.c:\nextern int ADtoB(char s[]); char input[]=\u0026#34;25\u0026#34;; int x; int main() { x); } In ADtoBasm.s\nAREA |.text|, CODE, READONLY EXPORT ADtoB ADtoB ; R0 address of string ; R1 current char being evaluated ; R2 running total, initialized to 0 ; R3 holds 10 to be used with multiply instruction MOVS R2, #0; total = 0 MOVS R3, #10; multiplier = 10 nextChar LDRB R1, [R0]; get char from string ADDS R0, #1; advance char pointer CMP R1, #0; check for null terminator BEQ endLoop1 SUBS R1, #0x30; strip ASCII MULS R2, R3, R2; multiply by 10 to move the total digit to the left ADDS R2, R2, R1; add digit to running total B nextChar endLoop1 MOV R0, R2; put total into R0 BX LR END  Oct 30, 2018 #  More code conversion: Binary to ASCII Binary #  We want to convert a 32-bit binary value to ASCII binary. We want to take a binary number and print it in binary on the screen. This will be converted into a 33-byte char array (one for null terminator). This will be possible by left shifting then using a ADCS (add with carry), because the carry flag will contain the digit that we shifted out of the register.\nIn BtoAB.c\nextern void btoab(int n, char s[]); char ascbin[33]; //one extra space for null terminator  int main() { btoab(0xFFFF0000, ascbin); } In BtoABasm.s\nAREA |.text|,CODE,READONLY EXPORT btoab btoab ; R0 number to convert ; R1 address of first char of the string ; R2 holds 0x30, char to store ; R3 #0 ; R4 loop counter PUSH {R4}; preserve R4 MOVS R3, #0; 0 to add with carry MOVS R4, #32; loop counter loop1	MOVS R2,#'0';	reset 0 LSLS R0, #1;	msb into carry flag ADCS R2, R3;	add carry to R2 STRB R2, [R1];	store ascii digit into str ADDS R1, #1;	increment pointer SUBS R4, #1;	decrement loop counter BNE loop1 MOVS R2, #0 STRB R2, [R1];	null terminate string POP {R4};	restore R4 BX LR;	return END  Nov 1, 2018 #  Lab 5: Cipher #  This is a subsitution cipher. To make this cipher easier, and not run into making mid-string null terminators, we will make the message the same length each time. 16 byte messages plus 1 byte for the null terminator.\npseudo:\n initialize variables loop 16 times  get text char get key char if key char is null terminator  reset key pointer get key char   increment key pointer EOR text char and key char STRB where R0 points increment text pointer loop test    extern void cipher16(char text[], char key[]); char str[16] = \u0026#34;This is a test!!\u0026#34;; int main() { cipher16(str, \u0026#34;Bob123\u0026#34;); cipher16(str, \u0026#34;Bob123\u0026#34;); } AREA |.text|, CODE, READONLY EXPORT cipher16 cipher16 ; R0 address of text ; R1 address of key ; R2 loop counter (16) ; R3 preserve key location ; R4 current text char ; R5 current key char PUSH {R4-R5}; preserve registers MOVS R2, #16; loop counter = 16 MOVS R3, R1; preserving key location loop1 LDRB R4, [R0]; get text char LDRB R5, [R1]; get key char CMP R5, #0; key char == null terminator? BNE if1; MOVS R1, R3; reset key LDRB R5, [R1]; reload key if1 ADDS R1, #1; increment key EORS R4, R5; xor operation STRB R4, [R0]; store encrypted char ADDS R0, #1; increment text SUBS R2, #1; decrement loop counter BNE loop1; check if end of loop POP {R4-R5}; restore registers BX LR; return END Parameter passing #  The first 4 parameters of a function are passed thru R0-R3. Any parameters after the first 4 get pushed onto the stack. If a variable is passed as a parameter, it will need to go lookup the location of the variable in memory before moving it into a register. When an expression is passed as a parameter\n Nov 6, 2018 #  ALU #  ALU lives inside the CPU, everything else exists to bring data to the ALU.\nDigital logic:\nAND gate:\nOnly true if all inputs are true\n   a b a \u0026amp;\u0026amp; b     0 0 0   0 1 0   1 0 0   1 1 1    OR gate (inclusive):\nTrue if either input is true. This gate can be made with 3 NANDS.\n| a | b | a || b | | :\u0026mdash;: | :\u0026mdash;: | :\u0026mdash;\u0026mdash;: | | 0 | 0 | 0 | | 0 | 1 | 1 | | 1 | 0 | 1 | | 1 | 1 | 1 |\nNOT gate:\nReturns the opposite of the input. Also known as a inverter\n   a !a     0 1   1 0    NAND gate:\nNOT AND, returns opposite of a AND gate. One of two universal gates. Uses the least resistors. If you tie the two inputs together it turns into a NOT gate (however the propagation delay is slower then a NOT).\n   a b a AND b NOT     0 0 1   0 1 1   1 0 1   1 1 0    NOR gate:\nNOT OR gate. One of the two universal gates. Was the first integrated circuit to be mass produced (Fairchild organization, second silicon valley company, 1961).\n   a b a OR b NOT     0 0 1   0 1 0   1 0 0   1 1 0     Nov 13, 2018 #  The Assembler #  Used to translate our .s files to generate .o files. Object code files are not directly executed, they are prepared to be fed into the linker. The linker hooks all the .o files together and creates the core image (actual executable code). Inside the assembler there are 2 critical things we need to look at. The symbol table (label table), and the location counter. There is also a pass counter. The assembler \u0026ldquo;drinks the characters through a straw\u0026rdquo;, character by character. Lexical analysis. It checks each instruction in it\u0026rsquo;s table and keeps track of the next instruction will be. On the first pass its checking how much room each instruction takes up. The assembler also checks if anything is in column zero ( a label ) and it adds it to the symbol table, and it keeps track of it\u0026rsquo;s address. On the second pass of the assembler it actually makes the machine code for each instruction. It doesn\u0026rsquo;t check labels on the second pass. It looks up each symbol in the symbol table, to look ahead in the code.\nmbed \u0026gt; hardware boards \u0026gt; st microsystems boards \u0026gt; NUCLEO L432KC \u0026gt; Technical references document \u0026gt; Reference manual (RM0394)\nSTM32L432KC\n"}),a.add({id:311,href:'/notes/CS46/CS46-lecture-notes/',title:"CS46-lecture-notes",section:"CS46",content:"CS 46 Lecture Notes #  August 27 #  #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;I \u0026lt;3 C\\n\u0026#34;); } #include \u0026lt;stdio.h\u0026gt; int main() { for (int i) { printf(\u0026#34;I \u0026lt;3 C\\n\u0026#34;); } } #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Enter your agge: \u0026#34;); int age; scanf(\u0026#34;%d\u0026#34;, \u0026amp;age); // scanf is expecting a decimal (base 10), and stores it in age  int dogAge = age * 7; printf(\u0026#34;You are %d dog years old \\n\u0026#34;, dogAge); } To compile:\nType clang file.c where file is the name of the file\nThis will make a new file, to run this program type ./.a.out where a.out is the name of the file created\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Enter two numbers: \u0026#34;); int a, b; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;Average of %d and %d is: %d\u0026#34;, a, b, (a + b) / 2) } Differences between Java and C\n #include is kind of like import but not exactly No classes Not OO No public/private String is not a type  Primitive data types\n   Java C     boolean no equiavlent, use int   char char is a byte   int int is defined as a int with as many bits as the machine its running on, most natural data type   double same   float same   byte Use char   short half the size of an int   long double the size of an int     August 29 #  Data types and syntax #  Primitive types    Java C     int int   double double   char no equivalent   boolean int   byte char   String char[]   float float    C has unsigned intger types:\nunsigned int unsigned char unsigned long\nSame as java: braces semicolons if..else for while\nOperators: +, -, *, / \u0026amp;\u0026amp;, ||, !\nConditionals can be applied to ints\nint x = 5; if(x) // 0 is a false value, anything else is true { printf(\u0026#34;whee\u0026#34;); } int a = 10, b = 0; if (a || b) { printf(\u0026#34;whop!\u0026#34;); } int c = 0; printf(\u0026#34;%d\u0026#34;, !c); // this prints a 1 int z = 10; while(z--) { printf(\u0026#34;foo\u0026#34;); } printf and scanf are the 2 primary tools for getting information from a user and showing them information\nprintf(______) format\n%d is a integer %f is a float %s is a string (char array) %li is long int %u is unsigned int\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;int is %li bytes\\n\u0026#34;, sizeof(int)); } #include \u0026lt;stdio.h\u0026gt; int main() { int width, height, depth; printf(\u0026#34;Enter width: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;width); printf(\u0026#34;Enter height: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;height); printf(\u0026#34;Enter depth: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;depth\u0026#34;); int volume = width * height * depth; printf(\u0026#34;Volume is: %d\u0026#34;, volume); } In C the variables are not initialized, it defaults to whatever was in memory at the moment in time.\n September 3rd #  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;time.h\u0026gt; const int max = 100; // #define max 100  int main() { srandom(time(NULL)); // seeds random number generator from system\u0026#39;s time  int num) % max + 1; printf(\u0026#34;I have picked a random number between 1 and %d.\\n\u0026#34;, max); printf(\u0026#34;Can you guess it? \u0026#34;); int guess; scanf(\u0026#34;%d\u0026#34;, \u0026amp;guess); do { if (guess) { printf(\u0026#34;You got it!.\\n\u0026#34;); } else if (guess \u0026lt; num) { printf(\u0026#34;Too low.\\n\u0026#34;); } else { printf(\u0026#34;Too high!\\n\u0026#34;); } } while (guess != num); } Includes can be in angle brackets \u0026lt;\u0026gt; or quotes \u0026ldquo;\u0026rdquo;. Quotes look in the current directory and angle brackets look in the system\u0026rsquo;s directories. const is a constant that can\u0026rsquo;t be changed. #define is an older way to do it, (ex. #define max 100), no data type or equals sign, anywhere it sees the label max it\u0026rsquo;ll replace it with 100. Anything that starts with a hash mark is called a pre-processor directive.\nCompiling steps\n .c -\u0026gt; pre-processor  Any #define just swaps the term with the value   compilers, turns into assembly linker, hooks up everything executable   September 10th #  arduino.cc, download IDE\n#define #  An example of how to use #define\n#define DEBUG  int sum = 0; for (int i) { #ifdef DEBUG  printf(\u0026#34;i); #endif  sum = sum + i; } typedef works kind of like define but for data types\nJava:\nint[] arr = new int[10];\nC:\nint arr[10];\nBrackets for arrays go after variable name.\nSegmentation fault (core dumped):\n Happens when your program attempts to go outside of your memory segment.   October 1 #  10 foot view of the computer #  Memory is just an array of bytes. Programs/data both reside in memory.\nAddress of variables can be accessed with an \u0026amp;\nAddress of a is \u0026amp;a and b is \u0026amp;b\nA variable c that can hold the address of an int:\nint a; int b; int *c; // this is the address of an integer, not the interger itself  c = \u0026amp;b; // puts the address of b into the variable c  October 3 #  Pointers #  int x; // x holds an int float y; // y holds a float int *a; // a holds the address of an int float *z; // z holds the address of a float  \u0026amp;x; // address of x \u0026amp;y; // address of y  a = \u0026amp;x; // a is set to address of x z = \u0026amp;y; // z is set to address of y You can\u0026rsquo;t put the address of y into a because of loss of precision\nint j = 6; // 6 is checked to be an int before putting it into j int *k = \u0026amp;j; // legal The compiler checks the right hand side first, then the left side then checks if they are compatable. (Static analysis)\n October 10 #  Valid pointers #     Thing Name Type     int xy; xy int   double abc; abc double   char mp; mp char   int broom[10]; broom int array or int pointer   marp blee; blee marp   char *flam; flam char pointer   marp bomaz[5]; bomaz marp array or marp pointer   short int max; max short int   marp **z; z pointer to pointer to a marp, marp pointer pointer, pointer to marp pointer   double floof[2], *mop; floof, mop double array, double pointer   marp *whop[20]; whop array of marp pointers    // Valid? broom[4] = xy; // Valid floof[1] = \u0026amp;abc; // Invalid max = broom[2]; // Valid, with warning flam[8] = \u0026#34;1234\u0026#34;; // Invalid z = \u0026amp;whop[0]; // Valid *floof = 4.8; // Valid blee = \u0026amp;bomaz[2]; // Invalid mop = floof; // Valid flam = \u0026#34;hello\u0026#34;; // Valid mp = flam[5]; // Valid mp = \u0026amp;flam[4]; // Invalid whop[10] = *z; // Valid blah[5] is equivalent to *(blah + 5)\n// Valid ways of invoking these functions? void feet(int x); feep(xy) feep(broom[0]) feep(max) feep(*broom) feep(*(broom + 9)) char gabi(marp c); mp); *flam); flam[4]); marp asdf(int *a, marp *m); blee); **z); *\u0026amp;blee); struct gps { double lat; double long; }; This makes a new struct called gps that has 2 doubles inside\ntypedef struct gps gps; gps here; here.lat = 38.5; here.lon = -121.3; Or all at once:\ntypdef struct gps { double lat; double long; } gps; Memory allocation: address), this puts the memory into dynamic memory\n#include \u0026lt;stdlib.h\u0026gt;int *x) is called int *y); // Another way to figure out how much you need  October 15 #  Core dumps #  To debug a core dump: First recompile program with -g flag, then run gdb ./recover core\nString example:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main() { char str[40]; printf(\u0026#34;Enter a string: \u0026#34;); gets(str); printf(\u0026#34;Length is: %lu\\n, strlen(str)); } Compiler warns that gets() is dangerous because it will continue over the 40 chars set aside. fgets() takes three parameters, name of string, how long, and where to get input from. It will compensate for the null term at the end and also compensates for the new line char at the end of the string. This differs from scanf() with a %s because scanf will stop when it hits a space.\nOur own length functions:\nint length(char * s) { int count = 0; while (s[count] != \u0026#39;\\0\u0026#39;) // Checks against null char  { count++; } return count; } int length2(char *s) { int count = 0; while(s[count]) // Implicitally compares to 0  { count ++; } return count; } int length3(char *s) { int count = 0; while(*(s+count)) // Pointer arithmetic  { count++; } return count; } int length4(char *s) { int count = 0; while(*s) // Dereference s and increment it  { s++; count++; } return count; } int length5(char *s) { int count = 0; while(*s++) // Post increment  { count++; } return count; } int length6(char *s) { char *t = s; while(*++s); // Pre increment and return difference  return s - t; } int length7(char *s) { int count; for(count); return count; }  October 17 #  Version Control Systems #  Git commands:\ngit init initializes local repo git config configures user\u0026rsquo;s information git add \u0026lt;filename\u0026gt; marks a file to commit git commit -m \u0026quot;commit message\u0026quot; commit ready files with a message\n October 22 #  Working with files in C #  Use #include \u0026lt;stdio.h\u0026gt; to work with files. A file is just a sequence of bytes. It has a beginning and an end.\nFiles can be \u0026ldquo;unstructured\u0026rdquo; or \u0026ldquo;structured\u0026rdquo;\n Unstructured: text files Structured: CSX, executables, JPEG, video  Structured files can be \u0026ldquo;record oriented\u0026rdquo;\n Fixed-sized records Array of structs  The FILE struct keeps track of things like:\n Name of file Permissions Where you are in the file  When you read from a file, you start from the beginning, the FILE struct keeps track fo how far you have ready, so the next time you read it resumes where you left off.\nOperations on a file:\n Open  FILE * fopen(char *, char *); filename, mode (\u0026ldquo;r\u0026rdquo;, \u0026ldquo;w\u0026rdquo;, \u0026ldquo;a\u0026rdquo;) Returns a FILE * or NULL if there was a problem   Read  Use functions like fscanf and fgets fscanf(fp, \u0026quot;format\u0026quot;, variables); fgets(char *, length, fp);   Write  fprintf(fp, \u0026quot;format\u0026quot;, variables);   Close  fclose(fp);    For example:\n#include \u0026lt;stdio.h\u0026gt; int main() { FILE * fp; // file pointer  fp); // opens a file called \u0026#34;test\u0026#34; for read  if (fp) { // This means the file didn\u0026#39;t open correctly  printf(\u0026#34;Can\u0026#39;t open file\\n\u0026#34;); exit(1); } } #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; // For exit command int main() { FILE * fp; fp); if (!fp) { printf(\u0026#34;Could not open file!\\n\u0026#34;); exit(1); } fprintf(fp, \u0026#34;hello\\n\u0026#34;); // Write to file  fclose(fp); // Close file } #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; int main(int argc, char * argv[]) // Main now accepts command line parameters { if (argc) { fprintf(stderr, \u0026#34;Please enter a filename after the command\\n\u0026#34;); exit(2); } FILE * fp; fp); if (!fp) { fprintf(stderr, \u0026#34;Can\u0026#39;t open %s\\n\u0026#34;, argv[1]); exit(1); } char line[500]; int count = 1; while(fgets(line, 500, fp); != NULL) { printf(\u0026#34;%d %s\u0026#34;, count, line); count++; } fclose(fp); } #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt; int main(int argc, char * argv[]) { if (argc \u0026lt; 3) { fprintf(stderr, \u0026#34;You must supply a file name\\n\u0026#34;); exit(1); } FILE *in, *out; in); if (!in) { fprintf(stderr, \u0026#34;Can\u0026#39;t open %s for reading\\n\u0026#34;, argv[1]); exit(2); } out) if (!out) { fprintf(\u0026#34;Can\u0026#39;t open %s for writing\\n\u0026#34;, argv[2]); } char line[500]; while (fgets(line, 500, in) != NULL) { if (strcmp(line, \u0026#34;pizza\\n\u0026#34;)) { fprintf(out, \u0026#34;Nice! %s\u0026#34;, line); } else { fprintf(out, \u0026#34;%s\u0026#34;, line) } } fclose(in); fclose(out); }  October 24 #  /* A program to count the number of spaces The filename is given on the command line */ #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt; // For exit()#include \u0026lt;string.h\u0026gt; // For strlen()#include \u0026lt;ctype.h\u0026gt; // For isupper() int main(int argc, char * argv[]) { // Check number of command line arguments  if (agc \u0026lt; 2) { fprintf(stderr, \u0026#34;You must supply a filename\\n\u0026#34;); exit(1); } // Open file for reading  FILE * fp); if (!fp) { fprintf(stderr, \u0026#34;Can\u0026#39;t open %s for reading\\n\u0026#34;, argv[1]); exit(2); } // Read line by line  char line[5000]; int space_count = 0; int cap_count = 0; while(fgets(line, 5000, fp) != NULL) { // For each line, go char by char  for (int i) { // If its a space count++  if (line[i]) space_count++; // if (line[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; line[i] \u0026lt;= \u0026#39;Z\u0026#39;) cap_count++;  if (isupper(line[i])) cap_count++; } } // Close the file  fclose(fp); // Print the counts  printf(\u0026#34;Spaces: %d\\n\u0026#34;, space_count); printf(\u0026#34;Capitals: %d\\n\u0026#34;, cap_count); } Converts file to all uppercase letters\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;ctype.h\u0026gt;#include \u0026lt;sys/stat.h\u0026gt; // For stat struct int main(int argc, char * argv[]) { // Check number of command line arguments  if (argc \u0026lt; 2) { fprintf(stderr, \u0026#34;Please enter a filename to read from.\\n\u0026#34;); exit(1); } else if (argc \u0026lt; 3) { fprintf(stderr, \u0026#34;Please enter a filename to write to.\\n\u0026#34;); exit(2); } /* else if (strcmp(argv[1], argv[2])) { fprintf(stderr, \u0026#34;You must supply two different files, otherwise file loss will occur.\\n\u0026#34;); exit(5); } */ // Better way to check if files are the same  struct stat s1, s2; stat(argv[1], \u0026amp;s1); stat(argv[2], \u0026amp;s2); if (s1.st_ino) { fprintf(stderr, \u0026#34;You must supply two different files, otherwise file loss will occur.\\n\u0026#34;); exit(5); } // Open input file for reading  FILE * in); if (!in) { fprintf(stderr, \u0026#34;Could not open %s for reading.\\n\u0026#34;, argv[1]); exit(3); } // Open output file for writing  FILE * out); if (!out) { fprintf(stderr, \u0026#34;Could not open %s for reading.\\n\u0026#34;, argv[2]); exit(4); } // Loop through input file, line by line  char line[5000]; while (fgets(line, 5000, in) != NULL) { // For each line, convert chars to upper  for (int i) { line[i]); } // Write line to output  fprintf(out, \u0026#34;%s\u0026#34;, line); } // Close files  fclose(in); fclose(out); }  October 29 #  Hashing algorithms #  Mixes up the bits of input data and produces a fixed-size output\n   Types Output     MD5 128 bits   SHA256 256 bits   SHA512 512 bits   DES 56 bits    echo -n word | md5sum\n October 31 #  When compiling, make sure you compile you\u0026rsquo;re own .c file and the md5.c file.\nUse -g when compiling program and then call valgrind then the command to detect memory leaks.\nclang -c hash1.c makes it compile and not delete the .o file.\nThen you can compile all the .o files with clang and -l crypto.\nMakefiles #  Dependency tree (Makefile)\nhash1 : hash1.o md5.o clang hash.o md5.o -o hash1 -l crypto hash1.o : hash1.c clang -c hash1.o md5.0 : md5.c clang -c md5.c  Indentation must be 1 tab!\n  November 21 #  Quantum computers #  Classic bit (cbit): 0 or 1 Quantum bit (qbit): 0 or 1 (or anywhere in between)\nQuantum bits can be represented as |0\u0026gt; or |1\u0026gt;\nX operation, (similar to classic NOT) (1, 0) flips into (0, 1)\nH operation (Hadamard), turns bit into intermediate bit between 0 and 1 H |0\u0026gt; = |+\u0026gt;\nCNOT (Conditional NOT) If the first qbit is a 1 then the second is flipped (using X) CNOT |00\u0026gt; = |00\u0026gt; CNOT |01\u0026gt; = |01\u0026gt; CNOT |10\u0026gt; = |11\u0026gt; CNOT |11\u0026gt; = |10\u0026gt;\nstruct qbit { double x; double y; } const struct qbit q0 = {1.0, 0.0}; const struct qbit q1 = {0.0, 1.1}; struct qbit x(struct qbit q) { struct qbit qnew; qnew.x = 0 * q.x + 1 * q.y; qnew.y = 1 * q.x + 0 * q.y; return qnew; }  November 26 #  Networking #  Host: a computer with network access\nHostname: a \u0026ldquo;human readable\u0026rdquo; name for a host\n www.amazon.com sierracollege.edu  IP address: unique number assigned to a host\n IPv4: 10.6.34.124 IPv6: fe80:4332:5153:\u0026hellip;.  Client: requests info from a server\nServer: fulfills the requests\nUsually, client initiates the transaction\nSocket: a connection between two hosts\n Setup a socket to the server, you get back a socket number Turn the socket number into a FILE * Use any of the file functions (fprintf, fscanf, fgets, fclose, fread, fwrite)  Example on the command line\nncat -C www.cs.sierracollege.edu 80 GET /~mmelendexgalindo/index.html HTTP/1.0 Host: www.cs.sierracollege.edu For C code: use a library called libsocket\n "}),a.add({id:312,href:'/notes/CS46/luhns.c/',title:"Luhn's Algorithm",section:"CS46",content:"Luhn\u0026rsquo;s Algorithm #  An implementation of the Luhn algorithm in the C language.\nThis algorithm is used for verification of credit card numbers. It is a simple to follow process that generates the last digit of the credit card (the checksum).\nThe algorithm is as follows:\n  From the rightmost digit (excluding the check digit) and moving left, double the value of every second digit. The check digit is neither doubled nor included in this calculation; the first digit doubled is the digit located immediately left of the check digit. If the result of this doubling operation is greater than 9 (e.g., 8 × 2). Take the sum of all the digits. If the total modulo 10 is equal to 0 (if the total ends in zero) then the number is valid according to the Luhn formula; otherwise it is not valid.   So with a number, say 4539704354706391, we can check the number like so:\n4 5 3 9 7 0 4 3 5 4 7 0 6 3 9 1 original number 8 5 6 9 14 0 8 3 10 4 14 0 12 3 18 1 double every other 8 +5 +6+ 9+1+4+0 +8 +3+1+0+4+1+4+0+1+2+3+1+8+1 add all digits = 70 valid card Implementing the algorithm #  Let n be the card number we\u0026rsquo;re checking, we\u0026rsquo;ll store this off in a long called number.\nlong number = n; We\u0026rsquo;ll start a running sum at 0. We can extract the rightmost digit by modding the number with 10 (% 10), then add it to our sum. Then we can chop off the digit by dividing by 10.\nint sum = 0; sum = number % 10; // add checksum number = number / 10; // chop checksum off Next while the number is positive we\u0026rsquo;ll extract the rightmost digit with a mod 10 and double it. If it is a double digit number we\u0026rsquo;ll subtract 9 from it. (i.e. for the number 18: `1 + 8). It is then added to the running sum, and chopped off.\nThe next number is just added to the sum, and not doubled. This continues until all the digits have been processed.\nwhile(number) { int temp = (number % 10) * 2; // get rightmost digit and double  if (temp \u0026gt; 9) // if 2 digit number add digits together  { temp = temp - 9; } sum = sum + temp; // add digit to sum  number = number / 10; // chop rightmost digit off  temp = number % 10; // get rightmost digit  sum = sum + temp; // add interleaved digit to sum  number = number / 10; // chop right digit off } The function will return the leftmost digit of the card number to determine which company. That\u0026rsquo;s simply dividing the number by 10 until its a one digit number\nwhile (n \u0026gt; 10) // get leftmost digit { n = n / 10; } If the sum after all of this ends in a 0, then the card is valid. If it isn\u0026rsquo;t a -1 is returned indicating an invalid card number.\nif (sum % 10) // invalid card number { return -1; } return n; // return leftmost digit Visualizing the algorithm #  st=\u0026gt;start: start with credit card number valid=\u0026gt;end: valid number return leftmost digit invalid=\u0026gt;end: invalid number return -1 chksum=\u0026gt;operation: extract checksum, add to sum, and chop off ext=\u0026gt;operation: extract rightmost digit chop=\u0026gt;operation: extract rightmost digit then chop digit off chop2=\u0026gt;operation: extract rightmost digit add to sum, chop off dbl=\u0026gt;operation: double the digit splt=\u0026gt;operation: subtract 9 from digit sum=\u0026gt;operation: add to sum leftmost=\u0026gt;operation: extract leftmost digit to return isdbl=\u0026gt;condition: doubled digit \u0026gt; 9? loop=\u0026gt;condition: number still positive? isvalid=\u0026gt;condition: is sum multiple of 10? st-\u0026gt;chksum-\u0026gt;loop loop(yes)-\u0026gt;chop-\u0026gt;dbl-\u0026gt;isdbl loop(no)-\u0026gt;leftmost leftmost-\u0026gt;isvalid isdbl(no)-\u0026gt;sum isdbl(yes)-\u0026gt;splt-\u0026gt;sum-\u0026gt;chop2(left)-\u0026gt;loop isvalid(yes)-\u0026gt;valid isvalid(no)-\u0026gt;invalid The working example #  Here\u0026rsquo;s an entire working example (the algorithm is in the validate function):\n// Luhn\u0026#39;s algorithm for checking credit card numbers // 4539704354706391 should have a sum of 70 (valid)  #include \u0026lt;stdio.h\u0026gt;  // #define DEBUG  // Function prototypes long get_cc(); int validate(long n); int main() { switch (validate(get_cc())) { case 3: printf(\u0026#34;AMEX\\n\u0026#34;); break; case 4: printf(\u0026#34;VISA\\n\u0026#34;); break; case 5: printf(\u0026#34;MASTERCARD\\n\u0026#34;); break; case 6: printf(\u0026#34;DISCOVER\\n\u0026#34;); break; default: printf(\u0026#34;INVALID\\n\u0026#34;); } } long get_cc() { printf(\u0026#34;Enter a credit card number: \u0026#34;); long n; scanf(\u0026#34;%ld\u0026#34;, \u0026amp;n); return n; } int validate(long n) { long number = n; #ifdef DEBUG  printf(\u0026#34;Number: %ld\\n\u0026#34;, number); #endif  int sum = 0; sum = number % 10; // add checksum  number = number / 10; // chop checksum off  while(number) { int temp = (number % 10) * 2; // get rightmost digit and double  if (temp \u0026gt; 9) // if 2 digit number add digits together  { temp = temp - 9; } sum = sum + temp; // add digit to sum  number = number / 10; // chop rightmost digit off  temp = number % 10; // get rightmost digit  sum = sum + temp; // add interleaved digit to sum  number = number / 10; // chop right digit off  } while (n \u0026gt; 10) // get leftmost digit  { n = n / 10; } #ifdef DEBUG  printf(\u0026#34;Sum: %d\\nLeftmost: %ld\\n\u0026#34;, sum, n); #endif  if (sum % 10) // invalid card number  { return -1; } return n; // return leftmost digit } "}),a.add({id:313,href:'/notes/MATH100/MATH100-lecture-notes/',title:"MATH100-lecture-notes",section:"MATH100",content:"Math 100 lecture notes #  File: MATH100-lecture-notes.pdf  "}),a.add({id:314,href:'/notes/MATH102/MATH102-lecture-20220125/',title:"MATH102-lecture-20220125",section:"MATH102",content:"Number Theory #  Syllabus #  File: math102-syllabus.pdf  Notes during orientation #   No complex numbers in this class If we use the variable   \\( n \\)  , it is assumed it is an integer  \\( p \\)  assumes a prime number  Warm up #  Breakdown according to oldest age:\n note that 36 appears twice, since Mary needs more time to figure it out it must be this value When Rafael talks about his \u0026ldquo;eldest\u0026rdquo; son that means that one son is older than the rest, so the answer is 9 2 2  Important sets #    \\( \\mathbb{Z} = \\{\\ldots, -2, -1, 0, 1, 2, 3, \\ldots\\} \\)  , the set of all integers.  \\( \\mathbb{Z}^\u0026#43; = \\{1, 2, 3, \\ldots\\} \\)  , the set of all positive integers.  \\( \\mathbb{N} = \\{0, 1, 2, 3, \\ldots\\} \\)    \\( \\mathbb{Q} = \\)  all numbers that can be written as  \\( \\frac{a}{b} \\)  where  \\( a \\)  and  \\( b \\)   \\( \\in \\mathbb{Z} \\)  . So,  \\( \\mathbb{Z} \\)  is contained in  \\( \\mathbb{Q} \\)  , but  \\( \\mathbb{Q} \\)  is not contained in  \\( \\mathbb{Z} \\)  .  \\( \\mathbb{R} \\)  is the set of all real numbers, also denoted by  \\( (\\infty, \\infty) \\)  .  \\( \\mathbb{Q} \\)  is contained in  \\( \\mathbb{R} \\)  , but  \\( \\mathbb{R} \\)  has elements that are not in  \\( \\mathbb{Q} \\)  .  Primes and composites #  Any integer  \\( \u0026gt; 1 \\)  which is only divisible by  \\( 1 \\)  and itself is called a prime number.\n \\[\\begin{aligned} 2, 3, 5, 7, 11, 13, 17, \\ldots \\end{aligned}\\]  Any integer  \\( \u0026gt; 1 \\)  , which is not a prime, is a composite number.\nDefinition: The Fundamental Theorem of Arithmetic\n All composite numbers are products of primes. We call these products prime factorizations. Each composite number has only one prime factorization (sometimes abbreviated as pf), up to order.   Finding the prime factorization of composite numbers #  Divide by the smallest prime which goes in repeatedly. So,\n \\[\\begin{aligned} 240 = 2^4 \\cdot 3 \\cdot 5 \\end{aligned}\\]  "}),a.add({id:315,href:'/notes/MATH102/MATH102-lecture-20220127/',title:"MATH102-lecture-20220127",section:"MATH102",content:'The language of divisibility #  The following 7 statements are equivalent:\n 18 is divisible by 6 18 is a multiple of 6 6 is a factor or divisor of 18 6 goes into 18, or 6 divides 18    \\( \\frac{18}{6} \\)  is a whole number 18 is equal to 6 times a whole number, which is the same as saying there is  \\( 18 = 6k \\)  for some  \\( k \\in \\mathbb{Z} \\)   In the long division of 18 by 6, the remainder is 0.  Note:  \\( 6\\ |\\ 18 \\)  is read as "6 divides 18".  Some more statements that are equivalent:\n 19 is not divisible by 6 19 is not a multiple of 6 6 is not a factor or divisor of 19 6 does not go into 19, or 6 does not divide 18  \\( \\frac{19}{6} \\)  is not a whole number 19 is not equal to 6 times a whole number, which is the same as saying  \\( 19 \\not = 6k \\)  for any  \\( k \\in \\mathbb{Z} \\)   In the long division of 19 by 6, the remainder is not 0  So, we can say that  \\( 6 \\not | \\ 19 \\)  .\nDivisbility theorem #  Theorem. If  \\( 7 | a \\)  , and  \\( 7 | b \\)  , then  \\( 7 | a \\pm b \\)  .  In the above theorem, it is understood that  \\( a, b \\in \\mathbb{Z} \\)  .\nExample  \\( 7 | 21 \\)  and  \\( 7 | 35 \\)  , so  \\( 7 | 56 \\)  .   Example  \\( 7 | 700 \\)  and  \\( 7 | 21 \\)  , so  \\( 7 | 679 \\)  (because  \\( 700 - 21 = 679 \\)  ).   Proof. We are given that  \\( 7 | a \\)  and  \\( 7 | b \\)  , so  \\[\\begin{aligned} a \u0026amp;= 7 k_1 \\\\ b \u0026amp;= 7 k_2 \\end{aligned}\\]  where  \\( k_1, k_2 \\in \\mathbb{Z} \\)  .\nSo,\n \\[\\begin{aligned} a \u0026#43; b \u0026amp;= 7 k_1 \u0026#43; 7 k_2 \\\\ \u0026amp;= 7 ( k_1 \u0026#43; k_2 ) \\end{aligned}\\]  Note that  \\( k_1 \u0026#43; k_2 \\)  is also  \\( \\in \\mathbb{Z} \\)  .\nWe can also show the same with a minus, therefore we are done. By statement 6 at the top we are done.\n \\( \\square \\)   A more general divisbility theorem #  This is a generalization of the above theorem.\nTheorem. If  \\( c | a \\)  , and  \\( c | b \\)  , then  \\( c | ma \\pm nb \\)  , where  \\( a, b, c, m, n \\in \\mathbb{Z} \\)  .  Example When  \\( c = 7, a = 140, b = 21, m = 10, n = 3 \\)  :  \\[\\begin{aligned} ma \u0026#43; nb \u0026amp;= 10(140) \u0026#43; 3 (21) \\\\ \u0026amp;= 1463 \\end{aligned}\\]  and indeed  \\( 7 | 1463 \\)  .\n  Using the fundamental theorem of arithmetic #  Example Let us use the FThA to prove that  \\( 7^2 \\)  cannot divide  \\( 7000 \\)  .  \\[\\begin{aligned} 7000 \u0026amp;= 7 ( 1000) \\\\ \u0026amp;= 7 (10)^3 \\\\ \u0026amp;= 7 (2 \\cdot 5)^3 \\\\ \u0026amp;= 7 \\cdot 2^3 \\cdot 5^3 \\end{aligned}\\]  Let us consider  \\( 7^2 k \\)  . The power of 7 will be at least 2 in the prime factorization of  \\( 7^2 k \\)  . Since the factorization of 7000 above has only 1 power of 7, it can never be equal to the prime factorization of  \\( 7^2k \\)  . If they were equal, it would violate the second part of the fundamental theorem of arithmetic (each number only has 1 pf).\nLet us consider  \\( 2^3 \\)  , since  \\( 7000 = 2^3 \\cdot 7 \\cdot 5^3 \\)  , it shows us that  \\( 2^3 | 7000 \\)  . This works because we can write 7000 as  \\( 2^3 \\)  multiplied by a whole number.\nLets look at the divisors of  \\( 7000 = 2^3 \\cdot 5 ^3 \\cdot 7 \\)  (there shold be 32).\n \\( 2^2, 2^2 \\cdot 7, 5^2 \\cdot 7, 2^3 \\cdot 7, 2^3, 5^3, \\ldots \\)    '}),a.add({id:316,href:'/notes/MATH102/MATH102-lecture-20220201/',title:"MATH102-lecture-20220201",section:"MATH102",content:"Divisibility cont. #  There are many ways to represent 24, but there is only 1 way to represent it as a product of primes.\nTheorem. Whenever we add a number to itself, the sum will be even.  Proof. Let first number be   \\( k \\)  , let the second number be  \\( k \\)  . So if  \\[\\begin{aligned} k \u0026#43; k = 2k \\end{aligned}\\]  and  \\( 2 | 2k \\)   \\( \\square \\)   Example Prove that if  \\( 10 | a \\)  and  \\( 10 | b \\)  , then  \\( 10 | ma \\pm nb \\)  , where  \\( a, b, m, n \\in \\mathbb{Z} \\)  . Proof.  \\( 10 | a \\)  so  \\( a = 10k_1 \\)  ,  \\( 10 | b \\)  so  \\( b = 10k_2 \\)  , where  \\( k_1, k_2 \\)  are unknown  \\( \\in \\mathbb{Z} \\)  .  \\[\\begin{aligned} ma \\pm nb \u0026amp;= m (10k_1) \\pm n (10 k_2) \\\\ \u0026amp;= 10(m k_1 \\pm n k_2) \\end{aligned}\\]  Note that  \\( (m k_1 \\pm n k_2) \\in \\mathbb{Z} \\)  .\n \\( \\square \\)     Example  \\( 7 \\not | a \\)  and  \\( 7 \\not | b \\)  .  \\( a \u0026#43; b \\)  may or may not be divisible by 7. For example:  \\( 7 \\not | 13 \\)  ,  \\( 7 \\not | 15 \\)  , but  \\( 7 | (13 \u0026#43; 15) \\)  .\nFor example:  \\( 7 \\not | 15 \\)  ,  \\( 7 \\not | 16 \\)  , and  \\( 7 \\not | (15 \u0026#43; 16) \\)  .\n  Example If  \\( 7 | a \\)  and  \\( 7 \\not | b \\)  , then it is certainly the case that  \\( 7 \\not | a \u0026#43; b \\)  . Proof.  \\( 7 | a \\)  so  \\( \\frac{a}{7} \\)  is a whole number.  \\( 7 \\not | b \\)  so  \\( \\frac{b}{7} \\)  is not a whole number. So  \\( \\frac{a}{7} \u0026#43; \\frac{b}{7} \\)  is not whole. Therefore,  \\( \\frac{a \u0026#43; b}{7} \\)  is not a whole number.\nSo, by statement 5:  \\( 7 \\not | a \u0026#43; b \\)  .\n \\( \\square \\)     Nmemonics for divisibility #  So, based on the examples above:\n IS + IS = IS IS + IS NOT = IS NOT IS NOT + IS NOT = IS or IS NOT  Example  \\[\\begin{aligned} 7^3 \\cdot 19^{24} \\not = 5^2 \\cdot 11^{30} \\end{aligned}\\]  By the fundamental theory of arithmetic, each number only has 1 pf, therefore these number cannot equal each other.\n  Can  \\( 2^6 | 2^5\\)  ? No, because  \\( \\frac{2^5}{2^6} = \\frac{1}{2} \\)  , which is not a whole number.\nExample Prove that  \\( 5^3 \\)  cannot divide  \\( 3^2 \\cdot 5^2 \\cdot 11^3 \\)  . Proof. Numbers that are divisible by  \\( 5^3 \\)  are of the form  \\( 5^3k \\)  . There are two cases:\n  \\( k \\)  contains a power of 5, therefore the power of  \\( 5^3k \\)  will be greater than 3.  \\( k \\)  does not contain a power of 5, therefore the power of  \\( 5^3k \\)  is 3.  Both of these scenarios have too many 5s to go into numbers with a  \\( 5^2 \\)  in their prime factorization.\n \\( \\square \\)     Amount of divisors #  If  \\( N = 2^{11} \\cdot 3 \\cdot 19^{20} \\)  . We can multiply the exponents (+ 1) together to get the total amount of divisors:  \\( (11 \u0026#43; 1) (1 \u0026#43; 1) (20 \u0026#43; 1) = 25 \\)  .\n the multiplication principle  "}),a.add({id:317,href:'/notes/MATH102/MATH102-lecture-20220203/',title:"MATH102-lecture-20220203",section:"MATH102",content:"Divisibility cont. #  Example Find a number with the amount of divisors of   \\( N \\)  to be  \\( 4 \\cdot 6 \\cdot 3 \\)  .  \\[\\begin{aligned} N = 7^3 \\cdot 11^5 \\cdot 41^2 \\end{aligned}\\]    Theorem. Consider the 4 digit number  \\( n = \\overline{abcd} \\)  .  \\( n \\)  is divisible by 9 if the sum of its digits  \\( a \u0026#43; b \u0026#43; c \u0026#43; d \\)  is divisible by 9.  Proof.  \\[\\begin{aligned} \\overline{abcd} \u0026amp;= 1000a \u0026#43; 100b \u0026#43; 10c \u0026#43; d \\end{aligned}\\]   \\( \\square \\)   Note:  \\( \\overline{abcd} \\)  means a 4 digit number.  "}),a.add({id:318,href:'/notes/MATH102/MATH102-lecture-20220208/',title:"MATH102-lecture-20220208",section:"MATH102",content:"Returning to an old problem #  Quiz 1 sols #  2Th review #  "}),a.add({id:319,href:'/notes/MATH102/MATH102-lecture-20220210/',title:"MATH102-lecture-20220210",section:"MATH102",content:"3T solutions #  Least common multiples #  Consider   \\( a = 2^2 \\cdot 5^4 \\cdot 7 \\cdot 41^{10} \\)  and  \\( b = 5^2 \\cdot 19 \\cdot 41 \\cdot 47^2 \\)  .\nIf  \\( M \\)  is a common multiple of  \\( a \\)  and  \\( b \\)  , that means that  \\( a | M \\)  and also  \\( b | M \\)  .\nSo what can we say about the pf of  \\( M \\)  ?\nThe closed form of  \\( M \\)  :\n \\[\\begin{aligned} M \u0026amp;= 2^i \\cdot 5^j \\cdot 7^r \\cdot 19^k \\cdot 41^s \\cdot 47^t \\cdot u \\end{aligned}\\]  where\n \\[\\begin{aligned} i \u0026amp;\\geq 2 \\\\ j \u0026amp;\\geq 4 \\\\ k \u0026amp;\\geq 1 \\\\ r \u0026amp;\\geq 1 \\\\ s \u0026amp;\\geq 10 \\\\ t \u0026amp;\\geq 2 \\\\ u \u0026amp;\\in \\mathbb{Z} \\end{aligned}\\]  So the shortcut is the union of primes with the higher power in each number.\nExample  \\( a = 2 \\cdot 5^3 \\cdot 19^4 \\)  and  \\( b = 2^4 \\cdot 19 \\cdot 41^7 \\)  So our  \\( \\text{LCM} (a, b) = 2^4 \\cdot 5^3 \\cdot 19^4 \\cdot 41^7 \\)    Example  \\( a = 2 \\cdot 5^3 \\)  and  \\( b = 2^2 \\cdot 5^4 \\cdot 11^9 \\)  So our  \\( \\text{LCM} (a,b) = 2^2 \\cdot 5^4 \\cdot 11^9 \\)  Notice that the least common multiple is  \\( b \\)  ( \\( b \\)  is a multiple of  \\( a \\)  ).\n  Example  \\( a = 2^2 \\cdot 3^2 \\cdot 7 \\)  . Find  \\( b \\)  such that  \\( \\text{LCM} (a, b) = 2^2 \\cdot 3^{15} \\cdot 7 \\cdot 19^3 \\)   \\( b = 2^2 \\cdot 3^{15} \\cdot 7 \\cdot 19^3 \\)    "}),a.add({id:320,href:'/notes/MATH102/MATH102-lecture-20220215/',title:"MATH102-lecture-20220215",section:"MATH102",content:"Quiz 2 solns #  3Th solns #  Some word problems #   Yes No    \\( \\text{gcd} (220,308) \\)    "}),a.add({id:321,href:'/notes/MATH102/MATH102-lecture-20220301/',title:"MATH102-lecture-20220301",section:"MATH102",content:"Functions #  Basic terminology\nIf   \\( f(x) = 2x^3 \u0026#43; 4 \\)  Then,  \\( f(1) = 2(1)^3 \u0026#43; 4 = 6 \\)  So,  \\( f(1) = 6 \\)  . When input is 1, output is 6.\n \\( f(10) = 2(10)^3 \u0026#43; 4 = 2004 \\)  . So, when input is 10, output is 2004.\nThe operations are what make a function, not the symbols.\nRemember,  \\( f(2 \u0026#43; 3) \\not = f(2) \u0026#43; f(3) \\)  . On the left side, the inputs have been added, and on the right side the outputs have been added.\nInteresting questions regarding functions #  "}),a.add({id:322,href:'/notes/MATH102/MATH102-lecture-20220303/',title:"MATH102-lecture-20220303",section:"MATH102",content:"Quiz 4 solns #  6T solns #  "}),a.add({id:323,href:'/notes/MATH102/MATH102-lecture-20220308/',title:"MATH102-lecture-20220308",section:"MATH102",content:"6Th solns #  Complete residue system questions #  "}),a.add({id:324,href:'/notes/MATH170/MATH170-latex-notes/',title:"MATH170-latex-notes",section:"MATH170",content:"MATH170 lecture notes #  File: m170-lecture-notes.pdf  "}),a.add({id:325,href:'/notes/MATH170/MATH170-lecture-20210831/',title:"MATH170-lecture-20210831",section:"MATH170",content:"Course orientation #  File: m170-syllabus.pdf  Notes during orientation #   Will be some technology, matlab, wolfram alpha Lectures all online, synchronous Async videos may be posted  "}),a.add({id:326,href:'/notes/MATH170/MATH170-lecture-20211012/',title:"MATH170-lecture-20211012",section:"MATH170",content:"MATLAB #  An introduction #  File: m170-matlab-linprog.pdf  For example, lets define a vector\nx = [1 2 3] If we want to transpose x, we can use the ':\nx' Or we can define a column vector like:\ny=[1 2 3] which can also be defined with ;:\ny=[1;2;3] So, to define an entire matrix we can use a combination of both:\nA=[1 2 3; 4 5 6; 7 8 9] We can do some matrix multiplication:\nA*y Or find the inverse:\ninv(A) We can change the format to rational numbers with:\nformat rat linprog function #  For a minimization LPP with \u0026ldquo;   \\( \\leq \\)  \u0026rdquo; and \u0026ldquo; \\( = \\)  \u0026rdquo; constraints, we can directly apply the linprog function.\nGiven  \\( z = c_0 \u0026#43; c_1 x_1 \u0026#43; c_2 x_2 \u0026#43; \\cdots \u0026#43; c_n x_n \\)  , we can put this in a vector of coefficients:\n \\[\\begin{aligned} \\bar{c} \u0026amp;= [c_1, c_2, \\ldots, c_n]^T \\end{aligned}\\]  and a vector of our decision variables\n \\[\\begin{aligned} \\bar{x} = [x_1, x_2, \\ldots, x_n]^T \\end{aligned}\\]  we can describe this as\n \\[\\begin{aligned} z \u0026amp;= c_0 \u0026#43; \\sum_{k=1}^{n} c_k x_k \\\\ \u0026amp;= c_0 \u0026#43; u \\end{aligned}\\]  So,\n We minimize  \\( u = \\sum_{k=1}^{n} c_k x_k \\)  , subject to the same constraints. Convert all constraints to \u0026ldquo; \\( \\leq \\)  \u0026rdquo; or \u0026ldquo; \\( = \\)  \u0026rdquo;.  Note on notation: if we say  \\( \\bar{x} \\leq \\bar{y} \\)  , then that means for each  \\( k \\)  ,  \\( x_k \\leq y_k \\)  .  For \u0026ldquo; \\( \\leq \\)  \u0026rdquo; constraints:\n \\[\\begin{aligned} A \\bar{x} \\leq \\bar{b} \\end{aligned}\\]  For \u0026ldquo; \\( = \\)  \u0026rdquo; constraints:\n \\[\\begin{aligned} A_{\\text{eq}} \\bar{x} = \\bar{b}_\\text{eq} \\end{aligned}\\]  For upper and lower bounds:  \\[\\begin{aligned} \\bar{\\text{lb}} \\leq \\bar{x} \\leq \\bar{\\text{ub}} \\end{aligned}\\]  where  \\( \\text{lb} \\)  is lower bound, and  \\( \\text{ub} \\)  is upper bound.\nSo to minimize  \\( u = c^T \\bar{x} \\)  subject to  \\[\\begin{aligned} A \\bar{x} \u0026amp;\\leq \\bar{b} \\\\ A_\\text{eq} \\bar{x} \u0026amp;= \\bar{b}_\\text{eq} \\\\ \\text{lb} \u0026amp;\\leq \\bar{x} \\leq \\text{ub} \\end{aligned}\\]  We use this in the linprog function like so:\nx = linprog(c, A, b, Aeq, beq, lb, ub) which will return the optimal solution. If we are also interested in the u value, we can call the function like this:\n[x,u] = linprog(c, A, b, Aeq, beq, lb, ub) where x is the optimal solution, and u is the optimal value (minimal).\nIf we are missing a parameter, like ub, we can replace it with a [].\nA concrete example #  Minimize  \\( z = 1 \u0026#43; x_1 - x_2 \u0026#43; 2x_3 \\)  subject to  \\[\\begin{aligned} -x_1 \u0026#43; x_2 \u0026#43; x_3 \u0026amp;\\geq 5 \\\\ 2x_1 - 2x_2 \u0026#43; x_3 \u0026amp;\\leq 5 \\\\ x_2 - x_3 \u0026amp;= 1 \\end{aligned}\\]  and  \\( x_k \u0026gt; 0 \\)  , for each  \\( k \\)  .\nSo even though this is in canonical form, we need to change the first constraint to either an  \\( = \\)  or  \\( \\leq \\)  constraint. Then, we need to identify our coefficient vector  \\( c \\)  .\nSo our new constraint is obtained by multiplying both sides by  \\( -1 \\)  .\n \\[\\begin{aligned} x_1 - x_2 - x_3 \\leq -5 \\end{aligned}\\]  Let  \\( u = x_1 - x_2 \u0026#43; 2x_3 \\)  , where we can take the coefficients to get  \\( c^T = \\begin{bmatrix} 1\u0026amp;-1\u0026amp;2 \\end{bmatrix} \\)  .\nTo get  \\( A \\)  , we can use the coefficients of the constraints:\n \\( A \\bar{x} = \\begin{bmatrix} 1 \u0026amp; -1 \u0026amp; -1 \\\\2 \u0026amp; -2 \u0026amp; 1 \\end{bmatrix} \\)  and  \\( \\bar{b} = \\begin{bmatrix} -5 \\\\ 5 \\end{bmatrix} \\)  Our equality constraint is  \\( x_2 - x_3 = 1 \\)  , so  \\( \\begin{bmatrix} 0 \u0026amp; 1 \u0026amp; -1 \\end{bmatrix} \\bar{x} = 1 \\)  .\nSo  \\( A_\\text{eq} = \\begin{bmatrix} 0 \u0026amp; 1 \u0026amp; -1 \\end{bmatrix} \\)  and  \\( b_\\text{eq} = [1] \\)  .\nWe only have a lower bound (the sign constraints), so  \\( \\text{lb} = \\bar{0} \\)  , and our upper bound is infinity.\nSo now that we have identified all necessary parameters, we can enter into MATLAB and then into the linprog function:\nC=[1 -1 2]' A=[1 -1 -1; 2 -2 1] b=[-5; 5] Aeq=[0 1 -1] beq=[1] lb=[0 0 0]' [x,u] = linprog(C, A, b, Aeq, beq, lb, []) which returns\nOptimal solution found. x = 0 3 2 u = 1 So our minimal value is  \\( z = 1 \u0026#43; u = 1 \u0026#43; 1 = 2 \\)  with  \\( x_1 = 0, x_2 = 3 \\)  and  \\( x_3 = 2 \\)  being the optimal values of decision variables.\nAnother example #  If we want to use linprog for a maximization problem, we need to convert it to a minimization problem. Minimizing  \\( z \\)  is the same as maximizing  \\( -z \\)  .\nMaximize  \\( z = 7x_1 \u0026#43; 6x_2 \\)  subject to\n \\[\\begin{aligned} 2x_1 \u0026#43; x_2 \u0026amp;\\leq 3 \\\\ x_1 \u0026#43; 4x_2 \u0026amp;\\leq 4 \\end{aligned}\\]  And positive sign constraints.\nTo use linprog, we consider minimizing  \\( -z = u = -7x_1 - 6x_2 \\)  .\nC=[-7 -6]' A=[2 1; 1 4] b=[3;4] lb=[0 0]' [x,u] = linprog(C, A, b, [], [], lb, []) which returns\nOptimal solution found. x = 8/7 5/7 u = -86/7 Then, the solution to the original (max) problem is  \\( z = \\frac{86}{7} \\)  , with  \\( x_1 = \\frac{8}{7} \\)  and  \\( x_2 = \\frac{5}{7} \\)  .\nA more involved example #  Minimize  \\( z = 3x_1 \u0026#43; 2x_2 \\)  subject to  \\[\\begin{aligned} -x_1 \u0026#43; 2x_2 \u0026amp;\\leq 40 \\\\ x_1 \u0026#43; 2x_2 \u0026amp;\\geq 40 \\to -x_1 - 2x_2 \\leq 40 \\\\ x_1 \u0026amp;\\geq 10 \\to -x_1 \\leq -10 \\\\ 0 \\leq x_2 \u0026amp;\\leq 30 \\end{aligned}\\]  We can use the upper bound of  \\( x_2 \\)  in the  \\( \\bar{b} \\)  matrix, but leave the lower bound in the lower bound vector.\nSo, we could have  \\( \\bar{C} = \\begin{bmatrix} 3\\\\2 \\end{bmatrix} \\)  , and  \\( A=\\begin{bmatrix} -1 \u0026amp; 2 \\\\ -1 \u0026amp; -2 \\end{bmatrix} \\)  .\nOur right hand side vector is  \\( \\bar{b} = \\begin{bmatrix} 40 \\\\-40 \\end{bmatrix} \\)  .\nOur lower bound vector is  \\( \\text{lb} = \\begin{bmatrix} 10\\\\0 \\end{bmatrix} \\)  and upper bound vector is  \\( \\text{ub} = \\begin{bmatrix} \\infty \\\\30 \\end{bmatrix} \\)  So, in MATLAB:\nC=[3 2]' A=[-1 2;-1 -2] b=[40 -40]' lb=[10 0]' ub=[inf 30]' [x, u] = linprog(C, A, b, [], [], lb, ub) which returns\nOptimal solution found. x = 10 15 u = 60  "}),a.add({id:327,href:'/notes/MATH170/MATH170-lecture-20211020/',title:"MATH170-lecture-20211020",section:"MATH170",content:"Two phase procedure #  Unbounded LP problem example #  "}),a.add({id:328,href:'/notes/MATH170/MATH170-lecture-20211021/',title:"MATH170-lecture-20211021",section:"MATH170",content:"Two phase procedure cont. #  Last problem finished #  Detecting a non feasible region #  Can we recognize a non-feasible region using the two phase method?\nPhase one completes because we have all negative coefficients in the last row, but since   \\( w \\not = 0 \\)  , there is no solution. We could solve this using Big M method where  \\( s_4 \u0026gt; 0 \\)  , and  \\( z\u0026#39; = z \u0026#43; M s_4 \\)  .\nApplying the Big M method to an unbounded problem #  Using the problem from earlier:\n \\( s_3 \\)  would be our next entering variable, however since there are no valid ratios (all negative), we cannot continue. So, applying the \u0026ldquo;unboundedness\u0026rdquo; criterion, we conclude that there is no optimal solution. This matches our result when we did it earlier using the two phase procedure.\nSensitivity analysis #  What happens if we are able to move the constraints around a little? What will the potential changes do the optimal solution?\nWe will cover\n The effect of changes in the constraints as well as in the lower/upper bounds on the optimal solution (vector) and on the optimal solution. Applications include  cost minimization, revenue maximization, profit maximization (the difference of the two) marginal cost, revenue, or profit. The impact of an increase in one unit of a decision variable, for example.   In LP problems, we also use the term shadow price for impact of a unit increase in a right hand side constant of a constraint on the optimal solution.  An example of finding shadow price #  We can use technology or some insight from the last simplex tableau for an optimal solution to determine the shadow price of a constraint.\nLets start with something where we already know the optimal solution, an example from the first homework:\n"}),a.add({id:329,href:'/notes/MATH170/MATH170-lecture-20211026/',title:"MATH170-lecture-20211026",section:"MATH170",content:"Sensitivity analysis cont. #  By increasing the right hand side of the   \\( c_1 \\)  constraint by 1 unit, we obtain a new  \\( \\tilde{z} \\)  value of  \\( \\frac{108}{7} \\)  .\nSo the shadow price is  \\( z - \\tilde{z} = \\frac{22}{7} \\)  .\nNext, identify shadow prices from a completed simplex tableau:\nShadow prices using MATLAB #  A=[2 1; 1 4] b=[3 4]' C=[-7 -6]' lb=[0 0]' [x, u]=linprog(C,A,b,[],[],lb,[]) Optimal solution found. x = 8/7 5/7 u = 86/7 Then we can start playing with the constraints to see shadow prices.\nb1=b b1(1)=4 [x, u1]=linprog(C,A,b1,[],[],lb,[]) Optimal solution found. x = 12/7 4/7 u = -108/7 b2=b b2(2)=5 [x, u2]=linprog(C,A,b2,[],[],lb,[]) Optimal solution found. x = 1 1 u2 = -13 lb1=[1 0] [x, u3]=linprog(C,A,b,[],[],lb1,[]) Optimal solution found. x = 8/7 5/7 u3 = -86/7 Exercise #  "}),a.add({id:330,href:'/notes/MATH170/MATH170-lecture-20211028/',title:"MATH170-lecture-20211028",section:"MATH170",content:"Sensitivity analysis cont. #  Recall previous example #  So how can we identify the shadow price when we have artificial variables by looking at the last row of the simplex tableau?\nNotice that moving the upper constraint up does not change the optimal solution at point   \\( C \\)  . But if you move the lower constraint up the optimal point will change.\nCorrection:  \\( x_5 \\)  replaced  \\( x_2 \\)  , so the left hand side BV is labeled incorrect.  We can ignore the artificial variable columns, and still consider  \\( z \\)  optimal, because the  \\( w \\)  equation equals  \\( 0 \\)  , and  \\( w = x_5 \u0026#43; x_7 \\)  .\nSo, the optimal solution to the original minimization LP problem is  \\( x_1 = 10, x_2 = 20 \\)  with  \\( z = 50 \\)  . Now let\u0026rsquo;s check the shadow prices and how they are related to the coefficients in the last row ( \\( z \\)  row), of the last simplex tableau.\nRecall,\n if it is a slack variable, we can simply multiply by  \\( -1 \\)  to obtain shadow price for corresponding constraint  Since the coefficients of  \\( x_3 \\)  and  \\( x_8 \\)  are both 0, their shadow price is 0.\nSurplus variables in  \\( c_2 \\)  and  \\( c_3 \\)  : shadow price is the negative of the coefficients of the corresponding surplus variables.\n So, for  \\( c_2 \\)  the shadow price of a 1 unit increase is  \\( \\frac{1}{2} \\)  . This is obtained by multiplying the slack variable  \\( x_4 \\)  by  \\( -1 \\)  . Similarly, for  \\( c_3 \\)  , the shadow price of a 1 unit increase is  \\( \\frac{5}{2} \\)  .  "}),a.add({id:331,href:'/notes/MATH170/MATH170-lecture-20211102/',title:"MATH170-lecture-20211102",section:"MATH170",content:"Sensitivity analysis using Delta method #  Since our new feasible region is smaller, we are getting a sub optimal result (because we are minimizing).\nFor this impact of   \\( \\tilde{c_4} \\)  on  \\( z \\)  , we need  \\( \\Delta \\leq -20 \\)  .\n At  \\( \\Delta = -20 \\)  ,  \\( C=(10,20) \\)  is still the optimal solution. After that, for  \\( \\Delta \u0026lt; -20 \\)  , it creates a new corner point  \\( C\u0026#39; \\)  .  For example, when  \\( \\Delta=-21 \\)  ,  \\( C\u0026#39; \\)  is the point with  \\( c_4\u0026#39; : x_2 \\leq 40 - 21 = 19 \\)  and  \\( x_1 \\)  satisifies  \\( \\ell_2 : x_1 \u0026#43; 2x_2 = 50 \\)  , so  \\( x_1 = 12 \\)  .\n the new point is  \\( C\u0026#39; = (12,19) \\)   new corresponding  \\( z \\)  value of  \\( z\u0026#39; = 55 \\)    Since this is larger than the original  \\( z \\)  , it is a sub optimal solution (recall we are minimizing).\nSo can we identify this without graphing?\nFrom the simplex tableau:\n check the current value column for the decision variables to see how big  \\( \\Delta \\)  can be  observe that  \\( x_3 = 20 \\)  and  \\( x_8 = 20\\)  are the values for the slack variables of  \\( c_1 \\)  and  \\( c_4 \\)  respectively. they are basic variables in the optimal BFS, so they have zero coefficient in the  \\( z \\)  -equation (last row) in the simplex tableau (which is why their shadow prices are 0) However, from their values of  \\( x_3=x_8=20 \\)  , we can conclude that  \\( \\Delta \\)  changes in their constraints impact the optimal solution when  \\( \\Delta \\)  amount is at least  \\( 20 \\)  units (in the negative direction for this minimzation problem)    Look at the impact of changes in the coefficients of the decision variables on the optimal solution.\n Consider the same objective function,  \\( z= 3x_1 \u0026#43; x_2 \\)  . What happens if it is changed to  \\( z = 4x_1 \u0026#43; x_2 \\)  ? The isocost lines will have the slope  \\( -4 \\)  . We can check graphically that it doesn\u0026rsquo;t change the optimal solution with the same constraints, in this example Similarly, we can check that an increase in the coefficient of  \\( x_2 \\)  will not impact the solution  "}),a.add({id:332,href:'/notes/MATH170/MATH170-lecture-20211104/',title:"MATH170-lecture-20211104",section:"MATH170",content:"Unrestricted variables in constraints #  In some scenarios, we may allow variables to be negative (like overdrawing an account).\nFor example:\nNow we can solve this new extended problem using the simplex algorithm.\n"}),a.add({id:333,href:'/notes/MATH170/MATH170-lecture-20211109/',title:"MATH170-lecture-20211109",section:"MATH170",content:"Duality #  So lets find the dual of a previous problem:\nThis is the primal problem, so lets look at the corresponding dual problem:\nA dual problem is: another LP problem that is related to the primal problem with different constraints and objective function.\n This will be a minimization problem (for a maximization primal problem) Two constraints of the primal yield two decision variables fo rthe dual, say   \\( y_1 \\)  and  \\( y_2 \\)   To determine the coefficients of the objective function, ie minimize  \\[ v= ? y_1 \u0026#43; ? y_2 \\]  . For the new constraints, lets first describe the primal problem in vector/matrix format, ie minimize  \\[ z = \\bar{c}^T \\bar{x} \\]  subject to  \\( A \\bar{x} \\leq \\bar{b} \\)    Another example from HW#2:\nDuality problems with MATLAB #  For the primal function use linprog function setup of the primal problem with the following changes:\n use the negative transpose -A' swap b and C parameters in the function  [y, u]=linprog(b, -A', C, [], [], lb, []) Another example #   we can also switch from a primal LP minimization problem to dual LP maximization problem by reversing the steps used in the previous examples then, we get the fact that \u0026ldquo;dual of the dual is the primal\u0026rdquo;  A general format to switch from a primal to a dual:\nConsider a generalp LP max problem of maximizing  \\( z=c_1 x_1 \u0026#43; c_2 x_2 \u0026#43; \\cdots \u0026#43; c_n x_n \\)  with  \\( n \\)  decision variables and  \\( m \\)  linear constraints  \\( C_1, C_2, \\ldots, C_m \\)  each with a \u0026ldquo; \\( \\leq \\)  \u0026rdquo; format.\n"}),a.add({id:334,href:'/notes/MATH170/MATH170-lecture-20211116/',title:"MATH170-lecture-20211116",section:"MATH170",content:"Duality cont. #   and   \\( A \\to A^T \\)    Facts, properties, principals #   Observe that there is a connection between shadow prices and the dual problem. An optimal solution to the symmetric dual of a primal LP problem Let  \\( \\hat{x} \\)  be a feasible solution to a primal problem in normal form with objective function  \\[ z = \\bar{C}^T \\bar{x} \\]  Let  \\( \\hat{y} \\)  be a feasible solution to its symmetric dual problem with the objective function  \\[ v=\\bar{b}^T \\bar{y} \\]  Let  \\[ \\hat{z} = \\bar{C}^T \\bar{x} \\]  and  \\[ \\hat{v} = \\bar{b}^T \\hat{y} \\]  If  \\( \\hat{z} = \\hat{v} \\)  , then  \\( \\hat{x} \\)  and  \\( \\hat{y} \\)  are optimal solutions to their respective LP problem, and  \\( \\hat{z} = \\hat{v} \\)  is the optimal value for both problems. This is called the Optimality Principle. Strong Duality Principle: If an optimal solution exists to either primal or dual, the other problem also has an optimal solution and the optimal values for both problems are equal to each other.  What if some of the constraints are not in normal form? #  If our constraints are not in the normal form in the primal LP problem, then we can transform them into a normal form.\nFor example,\n if a constraint  \\( C_j \\)  in a maximization problem has a \u0026ldquo; \\( \\geq \\)  \u0026rdquo; type inequality, we multiple by sides by  \\( -1 \\)  to convert it to a \u0026ldquo; \\( \\leq \\)  \u0026rdquo; type inequality. if a constraint  \\( C_j \\)  in a minimization problem has a \u0026ldquo; \\( \\leq \\)  \u0026rdquo; type inequality, we do the same as above  For equality constraints:\n we need to replace an inequality with two inequalities to make it a constraint in a \u0026ldquo;normal\u0026rdquo; form for duality purposes. for a maximization problem, if we have a constraint  \\[C_j : a_1 x_2 \u0026#43; a_2 x_2 = K \\]  which is equivalent to  \\[ a_1 x_2 \u0026#43; a_2 x_2 \\leq K \\\\ a_1 x_1 \u0026#43; a_2 x_2 \\geq K \\]  we can multiply the second one by  \\( -1 \\)  so everything is \u0026ldquo; \\( \\leq \\)  \u0026rdquo;. So, our new constraint  \\( C_j \\)  is  \\[\\begin{aligned} C_j\u0026#39;\u0026amp;: \u0026amp;a_1 x_1 \u0026#43; \u0026amp;a_2 x_2 \u0026amp;\\leq \u0026amp;K \\\\ C_j\u0026#39;\u0026#39;\u0026amp;: \u0026amp;-a_1 x_1 - \u0026amp;a_2 x_2 \u0026amp;\\leq \u0026amp;-K \\end{aligned}\\]   for a minimization problem, convert both constraints to a \u0026ldquo; \\( \\geq \\)  \u0026rdquo; in a similar manner. another approach is to introduce \u0026ldquo;free\u0026rdquo; variables and create variables unrestricted in sign to control its dimension.  An example #  Lets convert it to canonical form:\nAnother example #  "}),a.add({id:335,href:'/notes/MATH170/MATH170-lecture-20211130/',title:"MATH170-lecture-20211130",section:"MATH170",content:"The group assignment is related to the example we\u0026rsquo;ll discuss today.\nDuality finished up #  Auto trailers example #   the shadow prices of the primal problem are the optimal solution to the dual problem   since   \\( \\bar{x_1} \\)  and  \\( \\bar{x_2} \\)  are non-zero,  \\( \\bar{c_1} \\)  and  \\( \\bar{c_3} \\)  hold with equality  Another example #  Network models #   9 nodes 10 arcs  An example with two sources and three sinks #  Next time:\n"}),a.add({id:336,href:'/notes/MATH170/MATH170-lecture-20211202/',title:"MATH170-lecture-20211202",section:"MATH170",content:"Network models cont. #  Compressor shipment example #   note that this problem only has equality constraints, which makes it a bit easier for us to use technology   as we can see, this is very involved when trying the simplex method with this dimension  There are other approaches to simplify the simplex tableaus (procedures), at least in obtaining a more efficient initial BFS which is somewhat close to the optimal solution. Some methods to obtain such a useful initial BFS include\n northwest corner method minimum matrix method minimum row method minimum column method  The idea is to start with an initial guess which is likely to reduce the procedures in applying the optimality criterion.\nThe northwest corner method is simple to apply but it ignores the cost structure. Other methods take a bit more time to apply, but the corresponding initial BFS is expected to be \u0026ldquo;better\u0026rdquo; (closer to optimal solution), because they take the cost structure into account by favoring the variables whose corresponding costs are smaller.\nNorthwest corner method #  Using the example before:\nConsider the table of supply and demand constraints:\nWe want to put value for each cell so that the supply and demand is satisfied (recall that the supply amount = demand amount, because this is a \u0026ldquo;balanced\u0026rdquo; problem).\nWe start with the top left (the \u0026ldquo;northwest\u0026rdquo;) cell. Try to find the max that we can place in each cell.\nNow this row is finished because the supply is 0. So, we move down a row. (If we didn\u0026rsquo;t finish the row, we would move right one cell).\nNow the first column is done, we move right.\nAfter this initial BFS is obtained, we can use improvement criterion (apply optimality criteron multiple times).\nWhen assigning values to the cells we can use the price structure by assigning to the lowest costing item first.\n"}),a.add({id:337,href:'/notes/MATH170/MATH170-lecture-20211207/',title:"MATH170-lecture-20211207",section:"MATH170",content:"Last problem #  Recall the problem we worked on using \u0026ldquo;northwest corner\u0026rdquo; method to get the BFS:\n similar to northwest corner, except that we choose the lowest cost cells first  Shortest path problem #  "}),a.add({id:338,href:'/notes/MATH170/MATH170-lecture-20211209/',title:"MATH170-lecture-20211209",section:"MATH170",content:"Shortest path problem cont. #  Example from mock final #   the dummy line is to balance the supply/demand  The runtime complexity of this method is   \\( O(2^n) \\)  , there are some faster methods:\n"}),a.add({id:339,href:'/notes/MATH31/MATH31-comparison-tests/',title:"MATH31-comparison-tests",section:"MATH31",content:"Comparison tests #  Idea: Compare one series to another with a known convergence/divergence (geometric, harmonic, p-series, etc).\nSuppose we have two series   \\(\\sum a_n\\)  and  \\(\\sum b_n\\)  with positive terms:\n If  \\(a_b \u0026lt; b_n\\)  for all  \\(n\\)  , and  \\(\\sum b_n\\)  converges, then  \\(\\sum a_n\\)  also converges. If  \\(a_b \u0026gt; b_n\\)  for all  \\(n\\)  , and  \\(\\sum b_n\\)  diverges, then  \\(\\sum a_n\\)  also diverges.  If you show divergence for  \\(b_n\\)  when  \\(a_n \u0026lt; b_n\\)  , it proves nothing. The upper series diverges up to infinity and that tells us nothing about the lower series. It may diverge or converge. So make sure to show the correct comparison. (The same useless comparison is showing convergence for  \\(b_n\\)  when  \\(a_n \u0026gt; b_n\\)  ).\nExample 1 #   \\[\\begin{aligned} \\sum_{n=1}^\\infty \\frac{1}{n^2\u0026#43;2} \\end{aligned}\\]  First check if it fails divergence test, look for other known series, see if integral test could work (it would), but theres a better way. Consider this comparison:\n \\[\\begin{aligned} 0 \\leq \\frac{1}{n^2\u0026#43;2} \\leq \\frac{1}{n^2} \\end{aligned}\\]  If we\u0026rsquo;re trying to show convergence, we need this to be less than something we know convergence for.\nSo lets show convergence of  \\(\\frac{1}{n^2}\\)  :\n$$ \\sum_{n=1}^\\infty \\frac{1}{n^2} $$\nThis is a P-series with  \\(p=2\\)  , and since our  \\(p \u0026gt;1\\)  it means the series converges. This means by the comparison test that the original problem also converges.\nExample 2 #  $$ \\sum_{n=1}^\\infty \\frac{1}{3+2^n} $$\nAll the terms are positive on the interval, consider this comparison:\n$$ 0 \\leq \\frac{1}{3+2^n} \\leq \\frac{1}{2^n} $$\nSo try to determine convergence of the rightmost fraction:\n \\[\\begin{aligned} \\sum_{n=1}^\\infty \\frac{1}{2^n} \u0026amp; = \\sum_{n=1}^\\infty \\Big( \\frac{1}{2} \\Big)^n \\\\ \u0026amp; = \\sum_{n=1}^\\infty \\Big( \\frac{1}{2} \\Big) \\Big( \\frac{1}{2}\\Big)^{n-1} \\end{aligned}\\]  This is a geometric sum with  \\(a = \\frac{1}{2}\\)  and  \\(r = \\frac{1}{2}\\)  , therefore since  \\(r \u0026lt; 1\\)  this will converge. So by the comparison test the original problem also converges.\nExample 3 #  $$ \\sum_{n=3}^\\infty \\frac{3^n}{2^n-4} $$\nAll the terms on the interval are positive, so lets try a comparison:\n$$ \\frac{3^n}{2^n - 4} \\geq \\frac{3^n}{2^n} $$\nWe\u0026rsquo;re trying to show divergence of the rightmost fraction, and that will show that the original also diverges.\n \\[\\begin{aligned} \\sum_{n=3}^\\infty \\frac{3^n}{2^n} \u0026amp; = \\sum_{n=3}^\\infty \\Big( \\frac{3}{2} \\Big)^n \\\\ \u0026amp; = \\sum_{n=3}^\\infty \\Big( \\frac{3}{2} \\Big)^3 \\Big( \\frac{3}{2} \\Big)^{n-3} \\end{aligned}\\]  Since this is a geometric and our  \\(r \u0026gt; 1\\)  , it diverges. Therefore the original problem diverges.\nExample 4 #  $$ \\sum_{n=1}^\\infty \\frac{1}{\\sqrt{n} + 1} $$\nConsider this comparison:\n$$ 0 \\leq \\frac{1}{\\sqrt{n}+1} \\leq \\frac{1}{\\sqrt{n}} $$\nThis is a P-series with  \\(p\\)  . This means it diverges. This shows nothing about the original problem!\nWhen you can\u0026rsquo;t use a comparison like this, you can use the limit comparison test.\nLimit comparison test #  Idea: If  \\(\\sum a_n\\)  and  \\(\\sum b_n\\)  have positive terms, and this limit exists:\n$$ \\lim_{n \\rightarrow \\infty} \\frac{a_n}{b_n} $$\nIf this limit exists, then that means that both terms are so close together that it doesn\u0026rsquo;t matter. That means that both series either converge or diverge.\nIf it goes to infinity then the terms must difference enough that one or both of them diverges.\nProof #  Suppose this limit exists:\n$$ \\lim_{n \\rightarrow \\infty} \\frac{a_n}{b_n} = L $$\nThen by definition:\n$$ \\Big| \\frac{a_b}{b_n} - L \\Big| \u0026lt; \\epsilon $$\nSo:\n \\[\\begin{aligned} -\\epsilon L \u0026lt; \\frac{a_b}{b_n} - L \u0026lt; \\epsilon L \\\\ L-\\epsilon L \u0026lt; \\frac{a_b}{b_n} \u0026lt; L \u0026#43; \\epsilon L \\\\ (1-\\epsilon)L \\cdot b_n \u0026lt; a_n \u0026lt; (1\u0026#43; \\epsilon)L \\cdot b_n \\end{aligned}\\]   \\((1\u0026#43; \\epsilon)L\\)  is just a constant (doesn\u0026rsquo;t affect the convergence/divergence of the series), so if  \\(b_n\\)  converges  \\(a_n\\)  is less than that so it also converges. If  \\(b_n\\)  diverges, then  \\(a_n\\)  is greater than that so it also diverges.\nExample 5 #  So to take a look again at Example 4 above:\n$$ \\sum_{n=1}^\\infty \\frac{1}{\\sqrt{n} + 1} $$\nLets try the limit comparison test where:\n$$ \\lim_{n \\rightarrow \\infty} \\frac{a_n}{b_n} $$\nand\n$$ b_n = \\frac{1}{\\sqrt{n}} $$\nSo:\n \\[\\begin{aligned} \\lim_{n \\rightarrow \\infty} \\frac{\\frac{1}{\\sqrt{n} \u0026#43; 1}}{\\frac{1}{\\sqrt{n}}} \u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{1}{\\sqrt{n} \u0026#43; 1} \\cdot \\frac{\\sqrt{n}}{1} \\\\ \u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{\\sqrt{n}}{\\sqrt{n} \u0026#43; 1} \\\\ \u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{1}{1 \u0026#43; \\frac{1}{\\sqrt{n}}} \\\\ \u0026amp; = 1 \\end{aligned}\\]  Since our limit exists,  \\(a_n\\)  and  \\(b_n\\)  are so close together, that if one converges the other must also. If one diverges the other must also. Just because the limit exists it doesn\u0026rsquo;t mean they converge! They will just have the same result.\nNow we know that  \\(b_n\\)  diverges (p-series with  \\(p \u0026lt; 1\\)  ), it means the  \\(a_n\\)  does also!\nExample 6 #  $$ \\sum_{n=1}^\\infty \\frac{2n^2+n}{\\sqrt{4n^7+3}} $$\nLets choose a  \\(b_n\\)  that we know convergence/divergence. Start by trying a  \\(b_n\\)  that models the end behavior of  \\(a_n\\)  :\n \\[\\begin{aligned} \\sum_{n=1}^\\infty \\frac{2n^2}{\\sqrt{4n^7}} \u0026amp; = \\sum_{n=1}^\\infty \\frac{1}{n^{3/2}} \\end{aligned}\\]  This is a P-series with a  \\(p = \\frac{3}{2}\\)  , since  \\(p \u0026gt; 1\\)  it converges!\nLimit comparison test:\n \\[\\begin{aligned} \\lim_{n \\rightarrow \\infty} \\frac{a_n}{b_n} \u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{\\frac{2n^2\u0026#43;n}{\\sqrt{4n^7\u0026#43;3}}}{\\frac{1}{n^{3/2}}} \\\\ \u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{2n^2\u0026#43;n}{\\sqrt{4n^7\u0026#43;3}} \\cdot n^{3/2} \\\\ \u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{2n^{7/2} \u0026#43; n^{5/2}}{\\sqrt{4n^7\u0026#43;3}} \\\\ \u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{2 \u0026#43; \\frac{1}{n}}{\\sqrt{4 \u0026#43; \\frac{3}{n^7}}} \\\\ \u0026amp; = 1 \\end{aligned}\\]  Since we know the limit exists, and we know that  \\(b_n\\)  converges,  \\(a_n\\)  must converge also!\nExample 7 #  $$ \\sum_{n=1}^\\infty \\frac{\\sqrt{n} + \\ln n}{n^2 + 1} $$\nLets use the limit comparison test, and compare to  \\(b_n\\)  of:\n \\[\\begin{aligned} b_n \u0026amp; = \\sum_{n=1}^\\infty \\frac{\\sqrt{n}}{n^2} \\\\ \u0026amp; = \\sum_{n=1}^\\infty \\frac{1}{n^{3/2}} \\end{aligned}\\]  This is a P-series with  \\(p\\)  .\nLimit comparison test:\n \\[\\begin{aligned} \\lim_{n \\rightarrow \\infty} \\frac{\\sqrt{n} \u0026#43; \\ln n}{n^2 \u0026#43; 1} \\cdot n^{3/2} \u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{n^2 \u0026#43; n^{3/2} \\ln n}{n^2 \u0026#43; 1} \\\\ \u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{1 \u0026#43; \\frac{\\ln n}{n^{1/2}}}{1 \u0026#43; \\frac{1}{n^{2}}} \\\\ \u0026amp;\u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{\\ln n}{n^{1/2}} \\\\ \u0026amp;\u0026amp; \\text{Use L\u0026#39;Hospitals} \\\\ \u0026amp;\u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{\\frac{1}{n}}{\\frac{1}{2\\sqrt{n}}} \\\\ \u0026amp;\u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{2\\sqrt{n}}{n} \\\\ \u0026amp;\u0026amp; \\text{Use L\u0026#39;Hospitals} \\\\ \u0026amp;\u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{2}{\\sqrt{n}} \\\\ \u0026amp;\u0026amp; = 0 \\\\ \\therefore \u0026amp; = \\lim_{n \\rightarrow \\infty} \\frac{1 \u0026#43; 0}{1 \u0026#43; 0} \\\\ \u0026amp; = 1 \\end{aligned}\\]  So since the series  \\(b_n\\)  converges, the series  \\(a_n\\)  also converges.\n"}),a.add({id:340,href:'/notes/MATH31/MATH31-integral-test/',title:"MATH31-integral-test",section:"MATH31",content:"Integral test #  For   \\(f(n))\\)  is continous, positive, and decreasing, then we can use the integral to show convergence/divergence of our series.\nSo:\n$$ \\sum_{n=1}^\\infty \\text{ and } \\int_1^\\infty f(x)\\ dx $$\nwill have the same result (either converge or diverge).\n This can tell you convergence/divergence, but does not necessarily give the sum of the series. Convergence is not affected by the addition or subtraction of a finite number of terms from our series.  We can judge the convergence of  \\(\\sum_{n=1}^\\infty a_n\\)  with:\n$$ \\sum_{n=1}^\\infty a_n \\text{ or } \\int_1^\\infty f(x)\\ dx $$\nBut to do the integral test, we can start the integral at  \\(N\\)  , the sum of our integral will not be the sum of the series, but we can at least tell if it converges/diverges.\n$$ \\int_N^\\infty f(x)\\ dx $$\nExample 1 #  $$ \\sum_{n=1}^\\infty \\frac{1}{n^2+1} $$\nFirst thing first, you should check the divergence by taking the limit. The limit here equals 0, so it fails the divergence test. (It may be divergent some other way, but we don\u0026rsquo;t know. It may be convergent, but we don\u0026rsquo;t know). It\u0026rsquo;s not telescoping, its not factorable, so lets try the integral test.\n$$ f(x) = \\frac{1}{x^2+1} $$\nThis should act as an upper bound for our sequence provided its always positive, continuous, and decreasing on it\u0026rsquo;s interval  \\([1, \\infty)\\)  . If it meets these requirements then we can do the integral test:\n$$ \\int_1^\\infty \\frac{1}{x^2+1} dx $$\nThis is an improper integral:\n \\[\\begin{aligned} \\lim_{b \\rightarrow \\infty} \\int_1^b \\frac{1}{x^2\u0026#43;1} dx \u0026amp; = \\lim_{b \\rightarrow \\infty} \\Big[ \\tan^{-1}x \\Big]_1^b \\\\ \u0026amp; = \\lim_{b \\rightarrow \\infty} \\Big[ \\tan^{-1}b - \\tan^{-1}1 \\Big] \\\\ \u0026amp; = \\frac{\\pi}{2} - \\frac{\\pi}{4} \\\\ \u0026amp; = \\frac{\\pi}{4} \\end{aligned}\\]  Since we got a number, that shows that the series must converge! Our answer from the integral is not necessarily the sum of the series!\nExample 2 #  $$ \\sum_{n=1}^\\infty \\frac{3}{2n-1} $$\nTry the divergence test first. The limit is 0 so it doesn\u0026rsquo;t automatically diverge.\nThe integral test:\n$$ f(x) = \\frac{3}{2x-1} $$\nIt isn\u0026rsquo;t always positive, but it is on our interval  \\([1, \\infty)\\)  . It is continuous on our interval and it is also decreasing, so lets try the integral test.\n \\[\\begin{aligned} \\int_1^\\infty \\frac{3}{2x-1} \u0026amp; = \\lim_{b \\rightarrow \\infty} \\int_1^b \\frac{3}{2x-1} \\\\ \u0026amp;\u0026amp; u = 2x-1 \\\\ \u0026amp;\u0026amp; du = 2dx \\\\ \u0026amp; = \\lim_{b \\rightarrow \\infty} \\frac{3}{2} \\int \\frac{1}{u} du \\\\ \u0026amp; = \\lim_{b \\rightarrow \\infty} \\frac{3}{2} \\ln \\ \\big[2x-1\\big]_1^b \\\\ \u0026amp; = \\frac{3}{2} \\lim_{b \\rightarrow \\infty} \\big[ \\ln(2b-1) - \\ln(2-1) \\big] \\\\ \u0026amp; = \\infty \\end{aligned}\\]  Since the limit evaluates to  \\(\\infty\\)  the integral diverges. So the series also diverges.\nExample 3 #   \\[\\begin{aligned} \\sum_{n=1}^\\infty \\frac{\\ln n}{n} \\\\ f(x) = \\frac{\\ln x}{x} \\end{aligned}\\]  The function is positive and continuous. To show decreasing show that  \\(f\u0026#39;(x) \u0026lt; 0\\)  :\n \\[\\begin{aligned} f\u0026#39;(x) \u0026amp; = \\frac{1 - \\ln x}{x^2} \\\\ 1 \u0026amp; \\leq \\ln x \\\\ e \u0026amp; \\leq x \\end{aligned}\\]  Choose a interval where  \\(f(x)\\)  will be decreasing.  \\(f(x)\\)  will certainly be decreasing on the interval  \\([3, \\infty)\\)  .\nSo:\n \\[\\begin{aligned} \\int_3^\\infty \\frac{\\ln x}{x} \u0026amp; = \\lim_{b \\rightarrow \\infty} \\int_3^b \\frac{\\ln x}{x} dx \\\\ \u0026amp;\u0026amp; u = \\ln x \\\\ \u0026amp;\u0026amp; du = \\frac{1}{x} dx \\\\ \u0026amp; = \\lim_{b \\rightarrow \\infty} \\int_3^b u\\ du \\\\ \u0026amp; = \\lim_{b \\rightarrow \\infty} \\big[ \\frac{1}{2} (\\ln x)^2\\big]_3^b \\\\ \u0026amp; = \\lim_{b \\rightarrow \\infty} \\big[ \\frac{1}{2} (\\ln b)^2 - \\frac{1}{2} (\\ln 3)^2 \\big] \\\\ \u0026amp; = \\infty \\end{aligned}\\]  Therefore, the integral diverges. So the series also diverges.\nExample 4 #  $$ \\sum_{n=1}^\\infty \\frac{e^\\frac{1}{n}}{n^2} $$\nFirst do the divergence test, the limit is 0 so it doesn\u0026rsquo;t immediately diverge. Its not a geometric series. Its also not a P-series. Let\u0026rsquo;s try the integral test.\n$$ f(x) = \\frac{e^\\frac{1}{x}}{x^2} $$\nThe function must be positive, continuous, and decreasing on the interval. The function is positive. Its only discontinuous at 0 and thats not in our interval. To show decreasing make sure  \\(f\u0026#39;(x) \u0026lt; 0\\)  (alternatively you could show that  \\(a_{n-1} \u0026lt; a_n\\)  ):\n \\[\\begin{aligned} f\u0026#39;(x) \u0026amp; = \\frac{-e^\\frac{1}{x}-2xe^\\frac{1}{x}}{x^4} \\end{aligned}\\]  This is negative on our interval  \\([1, \\infty)\\)  .\nSo lets do the integral test:\n \\[\\begin{aligned} \\int_1^\\infty \\frac{e^\\frac{1}{x}}{x^2} dx \u0026amp; = \\lim_{b \\rightarrow \\infty} \\int_1^b \\frac{e^\\frac{1}{x}}{x^2} dx \\\\ \u0026amp;\u0026amp; u \u0026amp; = \\frac{1}{x} \\\\ \u0026amp;\u0026amp; du \u0026amp; = - \\frac{1}{x^2} dx \\\\ \u0026amp; = - \\lim_{b \\rightarrow \\infty} \\int_1^b e^u du \\\\ \u0026amp; = - \\lim_{b \\rightarrow \\infty} \\big[ e^\\frac{1}{x}\\big]_1^b \\\\ \u0026amp; = - \\lim_{b \\rightarrow \\infty} \\big[ e^\\frac{1}{b} - e^1 \\big] \\\\ \u0026amp; = - [1 - e] \\\\ \u0026amp; = e - 1 \\end{aligned}\\]  Therefore since the integral converges, the series must converge also.\n"}),a.add({id:341,href:'/notes/MATH31/MATH31-series/',title:"MATH31-series",section:"MATH31",content:"Series and sequences #  What is a series #  To evaluate series, first find the partial sum:\n  \\[\\begin{aligned} \\sum_{n=1}^\\infty n \\\\ S_n = 1 \u0026#43; 2 \u0026#43; 3 \u0026#43;\\ ...\\ \u0026#43; n \\end{aligned}\\]  Find the formula for  \\(S_n\\)  $$ S_n= \\frac{n(n+1)}{2} $$\nTake the limit as  \\(n \\rightarrow \\infty\\)  $$ \\lim_{n \\rightarrow \\infty} \\frac{n(n+1)}{2} = \\infty $$\nTelescoping #  These series look like two repeating fractions that end up canceling everything except something from the first term and something from the last. For example:\n \\[\\begin{aligned} \\sum_{n=1}^{\\infty} \\Big(\\frac{1}{2n\u0026#43;3} - \\frac{1}{2n\u0026#43;1}\\Big) \\end{aligned}\\]  First find the partial sum  \\(S_n\\)   \\[\\begin{aligned} S_n) \u0026#43; \\ ... \u0026#43;\\ \\Big ( \\frac{1}{2n\u0026#43;1}-\\frac{1}{2n-1}\\Big ) \u0026#43; \\Big ( \\frac{1}{2n\u0026#43;3}-\\frac{1}{2n\u0026#43;1}\\Big ) \\end{aligned}\\]  Almost all of these fractions will cancel if you see the patern. The only 2 left are:\n$$ S_n = - \\frac{1}{3} + \\frac{1}{2n+3} $$\nTake the limit of this partial sum  \\(S_n\\)  $$ \\lim_{n \\rightarrow \\infty}\\big[ - \\frac{1}{3} + \\frac{1}{2n+3} \\big] = - \\frac{1}{3} $$\nGeometric #  Geometric series take the form of:\n$$\\sum_{n=1}^\\infty ar^{n-1}$$\nThe series will converge of  \\(\\big|r\\big|\u0026lt; 1\\)  , otherwise it will diverge.\nIf the sum does converge, the sum is:\n$$\\sum_{n=1}^\\infty ar^{n-1} = \\frac{a}{1-r}$$\nShortcut #  If the first power of the sequence is 0 then the first term is  \\(a\\)  .  \\(a\\)  stands for the first term in your series.\nFor example:\n \\[\\begin{aligned} \\sum_{n=1}^{\\infty} \\Big ( \\frac{2}{3} \\Big )^n \u0026amp; = \\sum_{n=1}^{\\infty} \\Big ( \\frac{2}{3} \\Big )\\Big ( \\frac{2}{3} \\Big )^{n-1} \\\\ \u0026amp; = \\frac{\\frac{2}{3}}{1-\\frac{2}{3}} \\end{aligned}\\]  Another example:\n \\[\\begin{aligned} \\sum_{n=2}^{\\infty} \\frac{e^n}{3^{n\u0026#43;1}} \u0026amp; = \\sum_{n=2}^{\\infty} \\frac{e^n}{3\\bullet3^n} \\\\ \u0026amp; = \\sum_{n=2}^{\\infty} \\frac{1}{3} \\Big( \\frac{e}{3}\\Big)^n \\end{aligned}\\]  The mistake most people make here is thinking that  \\(a = \\frac{1}{3}\\)  . This isn\u0026rsquo;t the case because plugging in  \\(n=2\\)  doesn\u0026rsquo;t make the first exponent 0. So split off more $\\frac{e}{3}$\u0026rsquo;s to make it in the right form:\nNow since the first term makes the exponent go to 0. You can tell what  \\(a\\)  and  \\(r\\)  are now. So:\n$$ = \\frac{ \\frac{e^2}{27} }{1- \\frac{e^2}{3}} $$\nSo the shortcut here is that you can start with\n$$ = \\sum_{n=2}^{\\infty} \\frac{1}{3} \\Big( \\frac{e}{3}\\Big)^n $$\nand simply plug in 2 for  \\(n\\)  (the starting point). Since we know that the first term is  \\(a\\)  you can jump to the answer:\n$$ = \\frac{ \\frac{e^2}{27} }{1- \\frac{e^2}{3}} $$\nHarmonic #  Harmonc series are defined as:\n$$ \\sum_{n=1}^{\\infty} \\frac{1}{n} = \\frac{1}{1} + \\frac{1}{2} + \\frac{1}{3} +\\ \u0026hellip;\\ + \\frac{1}{n} $$\nHarmonic series are divergent. If a sequence  \\(\\{a_n\\}\\)  is convergent, any subsequence of  \\(\\{a_n\\}\\)  must also be convergent. To show that a sequence  \\(\\{a_n\\}\\)  diverges, it is enough to show that a subsequence diverges.\nNote: If a series converges, then\n \\[\\begin{aligned} \\sum_{n=1}^{\\infty} a_n \\\\ \\lim_{n \\rightarrow \\infty}^{} a_n = 0 \\end{aligned}\\]  So to show a series diverges, it\u0026rsquo;s enough to show:\n$$ \\lim_{n \\rightarrow \\infty} a_n \\neq 0 $$\nIf the limit doesn\u0026rsquo;t equal 0, or  \\(DNE\\)  , the series  \\(\\{a_n\\}\\)  diverges.\nRemember! The limit equaling 0 does NOT necessarily mean convergence!\nExample #   \\[\\begin{aligned} \\sum_{n=1}^{\\infty} \\frac{2n^2-1}{3n^2-1} \\\\ \\lim_{n \\rightarrow \\infty} \\frac{2n^2-1}{3n^2-1} \\neq 0 \\end{aligned}\\]  Diverges because the limit equals 0!\nProperties of convergent series #   You can always pull a constant out in front of the series  $$ \\sum_{n=1}^{\\infty} C a_n = C \\sum_{n=1}^{\\infty} a_n $$\nYou can split sequences on sums or differences  $$ \\sum_{n=1}^{\\infty} (a_n \\pm b_n) = \\sum_{n=1}^{\\infty} a_n \\pm \\sum_{n=1}^{\\infty} b_n $$\nExample #  $$ \\begin{split} \\sum_{n=1}^{\\infty} \\Big ( \\frac{2^n-5^n}{3^n}\\Big ) \u0026amp;) \\ \u0026amp; =\\sum_{n=1}^{\\infty} \\frac{2^n}{3^n} - \\sum_{n=1}^{\\infty} \\frac{5^n}{3^n} \\end{split} $$\nIf we split this sequence into parts, each part much be convergent for the entire sequence to be convergent! If any single part is divergent then the entire thing is divergent.\n$$ =\\sum_{n=1}^{\\infty} \\Big (\\frac{2}{3}\\Big )^n - \\sum_{n=1}^{\\infty} \\Big (\\frac{5}{3}\\Big )^n $$\nIn this form we can evaluate them as geometric series. Automatically we know this is divergent because the rightmost fraction\u0026rsquo;s  \\(r\\)  is greater than 1. Since a subsequence of the original diverges, the original does too.\nP series #  $$ \\sum_{n=1}^\\infty \\frac{1}{n^P} $$\nWhen  \\(P \u0026lt; 1\\)  the series will diverge.\n$$ \\lim_{n \\rightarrow \\infty} \\frac{1}{n^P} $$\nWhen  \\(P \u0026gt; 1\\)  the series will converge (can be shown with the integral test).\nExample 1 #  $$ \\sum_{n=1}^{\\infty} \\frac{1}{n^2} $$\nHere we can see that  \\(P\\)  , so the series must converge.\nExample 2 #  $$ \\sum_{n=1}^\\infty \\frac{1}{\\sqrt[3]{n}} $$\nHere we can see that  \\(P\\)  , so the series diverges.\nExample 3 #  $$ \\sum_{n=1}^\\infty n^{-\\pi} = \\sum_{n=1}^\\infty \\frac{1}{n^\\pi} $$\nSince  \\(P\\)  the series must converge.\n"}),a.add({id:342,href:'/notes/MATH31/MATH31-unit-1/',title:"MATH31-unit-1",section:"MATH31",content:"Unit 1 #  Notes #  Math 31 Exam 1 SOLN Fall 2018.pdf\nExam stuff #  Math 31 Exam 1 SOLNS Spring 2018.pdf Math 31 Exam 1 SOLNS Spring 2019.pdf Math 31 Fall 2019 LN UNIT 1.pdf\n"}),a.add({id:343,href:'/notes/MATH31/MATH31-unit-2/',title:"MATH31-unit-2",section:"MATH31",content:"Unit 2 #  Notes #     Unit 2      Base notes Math 31 LN Differential Equations CH 9 REVISED Spring 2019.pdf    Math 31 LN UNIT 2 Chapter 6 Fall 2019.pdf    Math 31 UNIT 2 LN (part 2) Spring 2019.pdf   Exam stuff Math 31 Exam 2 SOLNS Spring 2019.pdf    Math 31 Exam 2 Spring 2020.pdf   Suppliments Ch 6 Ch 8 Ch 9 Examples Suppliment.pdf    Videos #     Chapter 6 YouTube link     6.1 Areas Between Curves link   6.2 Volumes link    6.3 Volumes by Cylindrical Shells link   6.4 Work link       Chapter 8 YouTube Link     8.1 Arc Length link   8.2 Area of a Surface of Revolution link   8.3 Applications to Physics and Engineering link        Chapter 9 YouTube Link     9.1 Modeling with Differential Equations link    link    link    link   9.3 Separable Equations link    link   9.4 Models for Population Growth link   9.5 Linear Equations link    link    Quizzes #     Unit 2 Quizzes      Ch. 6 6.2-shell.pdf    6.2-torus.pdf    6.4-work.pdf   Ch. 8 8.1-arc-length copy.pdf    8.2-surface-area.pdf    8.3-physics.pdf   Ch. 9 Math 31 Chapter 9 Assignment Spring 2020.pdf    "}),a.add({id:344,href:'/notes/MATH31/MATH31-unit-3/',title:"MATH31-unit-3",section:"MATH31",content:"Unit 3 #  File: calculus-2.pdf   Math 31 Sequences and Series Part I Spring 2020.pdf\nChance Zed Chapter 11 Assignment part 1.pdf\nMath 31 Series Assignment Part 2 Spring 2020.pdf\nChance Zachary Chapter 11 Assignment Part 2.pdf\nMath 31 Chapter 11 Exam 3 Spring 2020.pdf\nChance Zachary Exam 3.pdf\n"}),a.add({id:345,href:'/notes/PHIL103/PHIL103-ec-lecture/',title:"PHIL103-ec-lecture",section:"PHIL103",content:"Marybeth Gasman: Are we ready to educate a diverse nation? #  The landscape of higher education\n 2014, for the first time the nation\u0026rsquo;s study body, K-12, was majority students of color 2019, almost half (45%) of the nation\u0026rsquo;s college students are students of color 2050, census data predicts that the US will be majority people of color  Faculty\n  88% of faculty at 60 top research universities is White\n  76% of the nation\u0026rsquo;s faculty overall is White\n  5% of faculty are Latinx compared to 20% of undergraduate population, 2% growth in 20 years\n  6% of faculty are black compared to 14% of undergraduate population, 1% growth in 20 years\n  11% of faculty are Asian compared to 7% of the undergraduate population\n  How teaching needs to change a diverse nation\n Assume success on the part of the students rather than seeing students of color from a deficit perspective.  Faculty should believe in their students success (even sometimes more so than the student believes in themselves)   Teach in ways that focus on what the students need to learn rather than what is convenient for the professor. Work together to co-construct classes and cirricula that empowers the students.  Changing teaching to educate a diverse nation\n Allow students to bring their full identities to the classroom and capitalize on all aspects of a student\u0026rsquo;s identity in the learning process Give students the opportunity to participate in culturally relevant assignments that speak to the issues in the communities from which they come. Encourage students collaboration over competition.  The role today\u0026rsquo;s students can play, consider becoming a professor, why?\n Opportunity to challenge and shape the minds of the next generation Chance to pursue your ideas Opportunity to have an impact on society with your research and teaching.  The role today\u0026rsquo;s faculty can play\n Encourage your students to pursue the professoriate as a career. Introduce your students to research of various types. Share the various aspects of your faculty career with your students so they understand faculty life. Show enthusiasm for your teaching, research and career so that students understand the positive aspects of being a professor.  Eric Helland: Why are the prices so damn high? #  Why?\n Lazy rivers and other waste? Administrative costs? Increases in quality?  Administrators\n The reason college tuition costs so much is \u0026ldquo;the constant expansion of university administration\u0026rdquo;  Bloat\nIncrease in quality?\nWhy should higher quality increase cost?\n What we teach has improved in quality (in some cases), but these kinds of improvements cannot explain increases in costs. It is no more expensive to teach new theories than old Why should quality increase cost?  If not bloat or quality then what?\nIt really looks like the story is the cost of faculty is the big driver in the rise of tuition.\nHealth care: note fastest increase in 60s and 70s\n Waste and administrative costs are plausible reasons why the US health care costs system is expensive but less so for why costs have grown over time. If growth in admin costs explain the growth in health care costs, then admin costs would have to grown by 8k%, even assuming that base health care costs had doubled. These numbers are not plausible.  The costs have been driven by the salaries\nBut why do wages increases lead to price increases in some industries but not others?\nRelative productivity growth\nUnique aspects of the Baumol Effect\n"}),a.add({id:346,href:'/notes/PHIL103/PHIL103-lecture-20200831/',title:"PHIL103-lecture-20200831",section:"PHIL103",content:"Applied ethics #   Bioethics, medical ethics, environmental, animal, business, political, sexual, population\u0026hellip;  Why study applied ethics?\n Philosophers are supposed to have a comparative advantage in argument and analysis Ethics is inherently something to apply  Philosphy\n What is involved in doing philosophy well? Pursue the truth Better: present good reasons for thinking one has got things right How good to the reasons have to be? Philosophy isn\u0026rsquo;t supposed to be a game where different sides choose their favorite argument Supposed to avoid idealogical advocacy  Applied ethics and philosophy\n Does applied ethics measure up? People disagree; there are too many areas characterized by reasonable pluralism  So what do we do?\n Rational, reasoned discussion But is that doing philosophy?  Other aims\n Can simply clarify what the different arguments are and the problems they encounter Sometimes there could be genuinely philosophical argument that has direct implications for an applied issue  Some advice for the semester\n We need to watch out for the pretense of applied ethics Be skeptical of the opinions that the readings present Be careful that we don\u0026rsquo;t mask private advocacy with philosophy  1. Introduction sp15 recap.pdf\n"}),a.add({id:347,href:'/notes/PHIL103/PHIL103-lecture-20200907/',title:"PHIL103-lecture-20200907",section:"PHIL103",content:"Lecture \u0026ldquo;In which I defend capitalism\u0026rdquo; #  Capitalism (the ideology) says:\n Anything thats peaceful Voluntary trading. not war; not empire  Lecture on causes of wealth and nature #  "}),a.add({id:348,href:'/notes/PHIL103/PHIL103-lecture-20200916/',title:"PHIL103-lecture-20200916",section:"PHIL103",content:"Capitalism socialism lecture #   Welfare economics #  7. econ2.pptx\n"}),a.add({id:349,href:'/notes/PHIL103/PHIL103-lecture-20200924/',title:"PHIL103-lecture-20200924",section:"PHIL103",content:"lockean property rights-revised.pdf Posner-IP.pdf\n"}),a.add({id:350,href:'/notes/PHIL103/PHIL103-lecture-20200927/',title:"PHIL103-lecture-20200927",section:"PHIL103",content:""}),a.add({id:351,href:'/notes/PHIL103/PHIL103-lecture-20201008/',title:"PHIL103-lecture-20201008",section:"PHIL103",content:"Why are we \u0026ldquo;creeped out\u0026rdquo; when someone we don\u0026rsquo;t know knows something about us?\nAnother example: a jointly authored book\nThe question is: How free and open should it be?\n"}),a.add({id:352,href:'/notes/PHIL103/PHIL103-lecture-20201014/',title:"PHIL103-lecture-20201014",section:"PHIL103",content:"a-short-introduction-to-the-world-of-cryptocurrencies.pdf\n"}),a.add({id:353,href:'/notes/PHIL103/PHIL103-lecture-20201024/',title:"PHIL103-lecture-20201024",section:"PHIL103",content:"The Law and Economics of Internet Access #  Innovation and Sec 230\n Develop and offer content without fear of legal liability \u0026ldquo;No provider or user of an interactive computer service shall be treated as the publisher or speaker of any information provided by another information content provider.\u0026rdquo; Innovation: want to make it likely that we\u0026rsquo;ll have access to more awesome content.  Net neutrality and Title II FCC public utility regulation\n Private carrier vs contract carrier vs common carrier Governments and ISPs should treat all data equally. Examples: blocking/filtering content, intentionally increasing or decreasing up/download speeds for certain users/content.  Common carrier designation\n June 2015 Federal Communications Commission ruling requires treating broadband providers as a telecom, and so a common carrier (like a public utility) under 1923 Communications Act. Was reversed by FCC vote under the new chairman, Ajit Pai, on December 14 2017 This vote returned ISPs to oversight of the FTC This was upheld in Federal Court in 2018, but that decision also allowed states to pass their own Net Neutrality laws. 20+ Peurto Rico and DC have. These are being challenged by the US Dept. of Justice  Title II FCC common carrier designation\n The economic rationale; high fixed cost (initial investment to build out), low marginal cost (to serve each subsequent subscriber). Leads to monopoly power and calls for public utility style regulation. The \u0026ldquo;Bell Doctrine\u0026rdquo;  The Bell Doctrine\n Only the \u0026ldquo;edge\u0026rdquo; segment of delivery is subject to monopoly power, so heavily regulated there. Ma Bell: devices/equipment, long distance service (deregulated market); only local transmission was heavily regulated Electricity: plant generation, transmission lines (less regulated or deregulated); local distribution (heavily regulated) Broadband: devices/equipment, websites/apps (mostly unregulated); ISPs (FCC regulation)  Technology and Access Neutrality #  Net Neutrality\n Governments and ISPs should treat all data equally Examples: rules converning blocking/filtering content, intentionally increasing or decreasing up/download speeds for certain users/content, zero-rating.  Is FCC regulation necessary for access to awesome content?\n Case study: the internet of the 90s Early 90s bought access to content centers where they only got access to content, users and sites who were associated with the center (e.g. CompuServe or AOL) Why did that change?  ISP competition\n FTC had oversight of ISP abuses of market power from 2005-2015, policing anti-competitive practices. In most areas, there are at least two wireline competitors Plus, additional competition from wireless/5G. Market is at least a duopoly with the threat of new entry and innovation. A contestable enough market?  Does FCC regulation make it more likely that we\u0026rsquo;ll have a better access to awesome content?\n FCC is a media (content) regulator. FCC open internet rules expressly allowed ISPs to filter and block content. Effect of FCC regulations on build-out investment in areas currently underserved. Effect of regulations on other forms of competition: ICPs and the example of Netflix. Netflix opposed zero-rating in the US, but doesn\u0026rsquo;t in Australia (because they were newer in Australia it gives them a way to compete for users). Other regulator effects: who\u0026rsquo;s in a better position to thrive in a heavily regulated market? Large corporations/firms love a heavily regulated market.  Compliance costs and cronyism #  GRAHAM: So would you work with us in terms of what regulations you think are necessary in your industry?\nZUCKERBERG: Absolutely.\nGRAHAM: Okay. Would you submit to us some proposed regulations?\nZUCKERBERG: Yes. And I\u0026rsquo;ll have my team follow up with you so, that way, we can have this discussion across the different categories where I think that this discussion needs to happen.\nGRAHAM: Look forward to it.\n"}),a.add({id:354,href:'/notes/PHIL103/PHIL103-lecture-20201028/',title:"PHIL103-lecture-20201028",section:"PHIL103",content:"Corporate Social Responsibility #  Markets, recap\u0026hellip; #   Market mechanisms vs political mechanisms for resource allocation You get (more!) effecient coordination without central direction in a system of property, contract, and consent. Private vices translate into public benefits Social obligations?  CSR #   Friedman\u0026rsquo;s main complain: \u0026ldquo;socially responsible\u0026rdquo; business amounts to a kind of fraud A violation of the fiduciary relatioinship between principal (owners, shareholders) and agent (CEO, management).  Examples #   Reducing emissions more than the law requires to offset global warming Using more expensive domestic suppliers to keep American indsutry strong Keeping on unproductive workers to save jobs Keeping a failing, obsolete factory open to save a local community  Using other people\u0026rsquo;s money without their consent #   A business executive needs to decide whether or not to close an unprofitable division. Who would be affected? Stakeholders: shareholders of corporation, but also employees, customers, suppliers, and local community of the company. \u0026ldquo;Creative destruction\u0026rdquo; Larry the Liquidator  So who\u0026rsquo;s the better fiduciary?\nPrincipal-agent problems #   Separation of ownership (shareholders) and control (CEO, management). Gekko says \u0026ldquo;greed is good.\u0026rdquo; Why? Problems in corporations are primarily the result of a lack of managerial accountability.  What happens if managers are told to serve multiple masters? #   Endangers incentives that encourage managers to make very poor decisions. Makes it difficult to detect the rent-seeking behavior of corporate managers because they aren\u0026rsquo;t scrutinized according to the profitability of the firm. And Friedman\u0026rsquo;s position actually makes the actions of managers more tractable – prevents corporate managers from being able to concentrate benefits on themselves, while dispersing costs on unsuspecting shareholders.  A diagnosis #   The problem is a stakeholder-type approach that makes it very difficult to detect the rent-seeking behavior of corporate managers because they aren\u0026rsquo;t scrutinized according to the profitability of the firm.  Friedman\u0026rsquo;s claim #  \u0026ldquo;There is one and only one social responsibility for business – to use its and engage in activities designed to increase its profits so long as it stays within the rules of the game.\u0026rdquo;\nFriedman\u0026rsquo;s argument implies either\n Managers (CEOs) should do whatever it takes to maximize profit (shareholder interests), so long as they don\u0026rsquo;t break the law, OR Managers should maximize profit, but only in ways that observe their pre-existing moral duties.  Option 1 makes the view false, or option 2 makes the view vacuous.\nHeath\u0026rsquo;s market failures approach to ethics in business #  Thesis #   The market will force firms to be ethical (or, ethical enough). Really?  \u0026ldquo;Pharma bro\u0026rdquo; Martin Shkreli #  Shkreli bought the rights of a drug that started at $13 per pill, and raised the price to $750 per pill. He was able to take the monopoly situation because there was only a certain group of people who needed the situation. Other companies had to go through a long rigaramole to create their own version of the drug, so he had a monopolized market for a while.\nTypical argument (in reponse to market failure) #   Idealized perfectly competitive economic model of a market would achieve some socially optimal (or Pareto efficient) outcome. Real world market fails to achieve that outcome: \u0026ldquo;Market failure!\u0026rdquo; Implement an interventionist solution.  What is a market failure? #   Not just a market outcome that you don\u0026rsquo;t like A (free) market failed to generate an efficient outcome. Not all the costs associated with a private transaction are internalized? Or, certain goods/services will tend to be under-provided by the market because of a lack of incentives. An institution failed in some way: the market.  Heath\u0026rsquo;s argument #   Idealized perfectly competitive economioc model of a market would achieve some socially optimal (or Pareto efficient) outcome. Real world market fails to achieve that outcome: \u0026ldquo;Market failure!\u0026rdquo; Business have a morally responsibility to act in ways that correct for these inefficiencies.  Three kinds of rules #   Recognition rules: rules about the making of rules, rules that rules have to answer to. Rules of the game: formal rules governing \u0026ldquo;play.\u0026rdquo; Rules in the game: informal rules governing \u0026ldquo;play.\u0026rdquo; This third area is where business ethics is important.  "}),a.add({id:355,href:'/notes/PHIL103/PHIL103-lecture-20201104/',title:"PHIL103-lecture-20201104",section:"PHIL103",content:"Market and government failures #  What is a market failure? #   A (n unregulated) market failed to generate an efficient outcome Not all the costs associated with a private transaction are internalized. For example: pollution. Or, certain goods/services will tend to be under-provided by the market because of a lack of incentives. For example: a lighthouse. An institution failed in some way: the market.  Typical argument #   Idealized perfectly competitive economic model of a market would achieve some socially optimal (or Pareto efficient) outcome Real world markets sometimes fail to achieve that outcome: \u0026ldquo;Market failure!\u0026rdquo; Government implements a regulatory solution  Heath\u0026rsquo;s argument #   Idealized perfectly competitive economic model of a market would achieve some socially optimal (or Pareto efficient) outcome Real world markets sometimes fail to achieve that outcome: \u0026ldquo;Market failure!\u0026rdquo; Business have a morally responsibility to act in ways that avoid or correct these inefficiencies.  Parallel legal argument #   An idealized legal process would achieve the perfectly just outcome The real world court system sometimes fails to achieve that outcome \u0026ldquo;Legal failure!\u0026rdquo; Lawyers (or judges\u0026hellip;) have a moral responsibility to act in ways that avoid or correct for these failures.  Three kinds of rules #   Recognition rules: rules about the making of rules, rules that rules have to answer to Rules of the game: formal rules of governing \u0026ldquo;play\u0026rdquo; Rules in the game: informal rules governing \u0026ldquo;play\u0026rdquo;  Applying the approach #   The purpose of market interaction is to generate Pareto-efficient (or positive sum) outcomes. Rules that provide for privte ownership and voluntary exchange generally generate Pareto-efficient (or positive sum) outcomes But Sometimes they don\u0026rsquo;t! Sometimes there are market failures When they don\u0026rsquo;t do what would generate (or a more) efficient outcome A regulatory way to avoid the failure (public intervention, Pigouvian tax, etc). A business-ethical way to avoid the failure (\u0026ldquo;don\u0026rsquo;t exploit market failures – correct them\u0026rdquo;)  Failures, market and government (from business ethics to political ethics) #  Thesis #   The market will force firms to be ethical enough But there are a lot of cases where corps are able to get away with lying and cheating, and be profitable  Corporate power and corporate harm #   Where does this power come from? How are they able to get away with inflicting harm on, e.g. exmployees, consumers, general public? Under what conditions would their power to do this be sustainable?  Revised thesis #   The market will force firms to be ethical enough UNLESS corps are able to insulate themselves from competitive market pressures  How? #   Government failure Example: government privilege concentrates corporate power, which translates into various social harms  Examples? #   Martin Shkreli, Turing Pharm Bailouts for 956 financial corps Regulatory capture: regulatory agencies that are created to \u0026ldquo;protect people from industry\u0026rdquo; end up serving the established interests in that industry to the detriment of consumers, potential competitors, and everyone else.  What is a government failure? #   Government intervention generates an outcome that is less efficient than if they hadn\u0026rsquo;t intervened An institution failed in some way: the government itself  Lesson 1: behavior symmetry #   Market failure, market actors are self-interested and lack complete information Interventionist solution? Are political actors morally and informationally perfect? Even if particular markets don\u0026rsquo;t meet the standard conditions of perfect competition required to ensure social optimality, government intervention doesn\u0026rsquo;t always make things better. (sometimes it makes things worse) Is polotics a Deus Ex Machina, or another tool we have to be careful about how we use?  Lesson 2 #   A market and government failures approach to business ethics General moral rule of thumb: do not seek or distribute/offer rents  Michael Munger – Market Failure and Sensible Regulation #  The pretty pig contest #  \u0026ldquo;The first pig is so absolutely ugly that you give the prize to the second pig without even seeing it.\u0026rdquo;\nStep 3 is weak.\nThe munger test: no unicorns!\n"}),a.add({id:356,href:'/notes/PHIL103/PHIL103-lecture-20201110/',title:"PHIL103-lecture-20201110",section:"PHIL103",content:"How to be a better person #  How can we manage for better behavior? #   Successful morality interventions need to be based on the correct model of moral psychology. The way to induce better behavior depends on how people make decisions.  Moral psychology #   A study to determine how people (fail to) make moral decisions. Behavioral ethics. Distinct from normative ethics: a study to determine what the moral (i.e., morally right and morally wrong) decision is.  Behavioral questions #   What motivates good/bad behavior? Why do people act badly? Why aren\u0026rsquo;t we better? (Why aren\u0026rsquo;t we worse?)  Four models #   Rational egoists Confused do-gooder Blind spots Weakness of will  Rational egoist model #   People are smart and selfish Smart: rational, effective in taking the most efficient means to secure their end. Ends? Their own. People act badly when they can \u0026lsquo;get away with it.\u0026quot;  How do you get rational egoists to act better? #   Make good behavior pay; make bad behavior costly. Don\u0026rsquo;t subsidize bad behavior. Better question: are people rational egoists? Consider ultimatum games  People do have tendencies associated with rational egoists #   Things that effect performance in ultimatum games  Meeting the receiver beforehand Seeing the receiver (Perceived) characteristics of the players    Confused do-gooder model #   People want to do the right thing But they\u0026rsquo;re often unsure what that is Can\u0026rsquo;t reason their way through the dilemma.  We just need more ethics training? #   Confused do-gooder model might be based on a false assumption. People will recognize a moral issue or dilema when confronted with it. Can we train people to recognize this?  Blind spot model #   Wrongdoers aren\u0026rsquo;t aware they\u0026rsquo;re in a dilemma. They\u0026rsquo;re unaware of the relevant moral issues that are at stake. They go through situations on autopilot. The Lake Wobegon Effect  Weak willed model #   I know its wrong, I don\u0026rsquo;t really want to do it, but I just can\u0026rsquo;t stop myself. Ego depletion: willpower is like a muscle that gets tired from use, and hard to use effectively when its tired.  Ego depletion experiments #  Horrifying real life experiments include favorable positions vs time throughout a day for a judge.\nWhat affects behavior? #  Milgram variations #  Another variation #  If the subjects were told that the test was supposed to test their own moral will, most subjects wouldn\u0026rsquo;t shock them at all.\n"}),a.add({id:357,href:'/notes/PHIL103/PHIL103-lecture-20201122/',title:"PHIL103-lecture-20201122",section:"PHIL103",content:"Why be moral? #  Two questions\n Descriptive: would you be moral if you could always get away with immorality? Normative: should you be moral if you could always get away with immorality? Normativity clarification: this is a rational should, not a moral should. Is morality rational?  Rational choice theory\n People have a stable, ordered set of preferences. Actions have utility insofar as they satisfy these preferences. Rational agents always choose the action that has the highest expected utility in light of their preferences.  Expected utility\n Discount the value of something by the probability it will occur. E.g., you can buy a lottery ticket for $10. Has a 1% chance of winning $100, and a 99% chance of winning $0. Whats the expected utility? ((0.01 \\cdot 90) + (0.99 \\cdot -10))  Is morality (altruism) rational?\n Why does this matter? Why try to show that it can be in our interest to be altruistic? Remember, preferences are just given. And it turns out that most people are naturally altruistic. So, according to rational choice expected utility theory, altruism is rational.  Not a satisfying answer\n Still want to know if its rational to have such preferences in the first place  If you could take a pill that would eliminate altruistic ends, would you have reason to do so/not to do so? If you were a sociopath and you could take a pill that would imbue you with altruistic prefernces, would you have a reason to do so/not do so?    Prisoner\u0026rsquo;s Dilemma\nImagine you have 2 prisoners, A and B\n    B is silent B testifies     A is silent Both get 6 months A gets 10 years, B goes free   A testifies A goes free, B gets 10 years Both get 5 years    Another version\n    Player 2 cooperates Player 2 defects     Player 1 cooperates 1: WIN, 2: WIN 1: LOSE BIG, 2: WIN BIG   Player 1 defects 1: WIN, 2: LOSE BIG 1: LOSE, 2: LOSE    Cooperation is a positive-sum, but defection is a dominant strategy\n Dominant strategy: a strategy that produces the best results for a player regardless of what other players do Other player will either defect or cooperate:  If she defects, I do better by defecting If she cooperates, I do better by defecting. So I should always defect.    Connection to morality\n Generally, morality is a positive-sum game. Life without morality is a negative sum game. But theres always a strong temptation to cheat. Should I?  Iterated games\n What if you play PD multiple times with different players who play a wide variety of ways? What strategy works best then?  Robert Axelrod\u0026rsquo;s computer simulations\n Best strategy is tit for tat. Cooperate until the other player defects, then do whatever the other player did last.  Variations: reputation\n Play one PD round with the person next to you Record total score Hold up whatever card you played (so everyone can see) Find a new player to play with – must agree to play next round. Play another round and record the total score Repeat 3-5 One person is randomly selected and paid a tally of their score  An argument that it\u0026rsquo;s rational to be mroal\n Life is a series of PD interactions, where we have informatino about each other So, \u0026ldquo;maximize my utility\u0026rdquo; doesn\u0026rsquo;t maximize your utility. It\u0026rsquo;s better to adopt a credible, public strategy to restrain yourself, provided others do so as well. Therefore, it\u0026rsquo;s rational to internalize a moral code that requires restraint and disposes one to cooperate.  "}),a.add({id:358,href:'/notes/PHYS105/PHYS105-lab-20200326/',title:"PHYS105-lab-20200326",section:"PHYS105",content:"Centripetal force lab #  The string holds the bob, and the entire mechanism spins in a circle to cause the bob to extend outward and hit the tape marker.\nTime for 20 revolutions\nData measured is from inside to center of L\nShould be percent difference not % error\nWrite a brief conclusion after the lab. Usually we try to make our experiments have a small percent error, but until now its been hard to tell if it is indeed small. Be familiar with our numbers, the precision of the instruments. For instant v is measured to the .01cm. Estimate the cumulative error, in other words, if the percent diff is less than 10% then thats pretty good!\nThis is due Fri at 5p, data is in CANVAS.\nProcedure\n Measure the mass of the bob on the digital scale Measure the time for 20 revolutions  "}),a.add({id:359,href:'/notes/PHYS105/PHYS105-lab-20200402/',title:"PHYS105-lab-20200402",section:"PHYS105",content:"Due in 3 weeks.\nThe Ballistic Pendulum #  2 different ways to measure a projectile\nWatch the youtube video\nFor the theory section: #  How to find initial velocity:\nMeasure the total height\nAnd the length in the x direction\nKinematics\nThen find total time\nSolve for t\nPlug back in\nTo make the calculations:\nHorizontal measurements\nBoth of these together is x total\nThen measure vertical\nAdd both together to get y total\nData is already in the document\nCalculate the muzzle speed using the kinematics equations\nSecond part of the lab has the pendulum down so the ball launches into the pendulum.\nThe change in height of the pendulum is measured.\n$h$ is the difference in height of the pendulum\u0026rsquo;s center of mass\nSolve for $V_o$\nFor the second part\nInitial height is of above the platform, final is the height after launch. Change in height is the difference between them.\nDue on the 24th\nHW questions #  Number 4\nWe want to know the speed of the Earth around the Sun and Io around Jupiter.\nNumber 5\nSolve for $x$\nNumber 6\nThe two objects are traveling perpendicular\nBoth speeds are relative to earth and its asking for the rivet\u0026rsquo;s speed relative to the satellite\nBefore they collide\nAfter they collide\nSmashed like a pancake, they want to know time of interaction\nWhat is the average force?\nLab 6 question #  "}),a.add({id:360,href:'/notes/PHYS105/PHYS105-lab-20200423/',title:"PHYS105-lab-20200423",section:"PHYS105",content:"Today #  Lab 8 #  Gas pressure arises from the thermal energy of the gas molecules\nPressure on the y axis, temp on x axis\nGraph the data, find the x intercept, and that should be near absolute zero. Compare that to the accepted absolute zero for percent diff.\n"}),a.add({id:361,href:'/notes/PHYS105/PHYS105-lecture-20200319/',title:"PHYS105-lecture-20200319",section:"PHYS105",content:"Announcements #   CH 8 HWs due tomorrow Quiz 6 due tomorrow  PDF   Power and Energy Lab due tomorrow Can come to either recitation meetings  Test 2 #   Tuesday 11a - 1p Given in docx and PDF Info posted in Course Info folder Just like in class, only use your big powerful brain and the crib sheet No outside help permitted Please do not post test on Cheggs or other websites, academic misconduct  "}),a.add({id:362,href:'/notes/PHYS105/PHYS105-lecture-20200326/',title:"PHYS105-lecture-20200326",section:"PHYS105",content:"Anouncements #   HW 12 CH6 due tues HW 13 Office hour tomorrow at 11am We will meet for lab today (either meeting) Spring break is coming  Clicker question notes #  $$ \\Sigma F = ma \\ \\Sigma F = -mgy $$\nIn circular motion the direction of the velocity is tangent to the circle.\nCircular motion and Gravity #  Major topics\n Uniform circular motion Centripetal acceleration Gravitation  Circular motion #  Objects moving in a circular path are accelerating. This is because the objects want to go in a straight line.\n$a_{avg} = \\frac{\\Delta v}{\\Delta t}$\nThis is true even if their speed and circular radius are constant.\n$r = constant \\ v = constant$\nSimilar triangles\n$ r_1 = r_2 = r \\ v_1 = v_2 = v \\ \\frac{\\Delta r}{r} = \\frac{\\Delta v}{v} \\ \\frac{\\Delta r}{\\Delta t r} = \\frac{\\Delta v}{\\Delta t v} \\ \\frac{v}{r} = \\frac{a_c}{v} $\nSince the velocity is tangent to the circle that means the velocity is perpendicular to the acceleration.\nCentripetal Force\nThis is the name we give to the net force that is causing something to bend in a circle!\n$F_{net} = ma = ma_c = \\frac{mv^2}{r}$\nWhat causes centripetal forces?\n This is not a \u0026ldquo;new force\u0026rdquo; to consider The previous slide shows that it is always the net fofce Tt will be the result of all the forces acting on the system Results from T, mg, n, Fa, fs, fk  $ \\frac {Tsin \\theta = \\frac{mv^2}{r}}{Tcos \\theta = mg} \\ tan \\theta = \\frac{v^2}{gr} $\nAs the acceleration gets bigger, the larger that angle $\\theta$ gets.\n$r = Lsin \\theta$\nwhere $L$ is the length of the string.\nMinimum speed needed to complete a vertical circle:\n$V_{min} = \\sqrt{gr}$\nAt bottom of the circle:\n$T = \\frac{mv^2}{r} + mg$\n"}),a.add({id:363,href:'/notes/PHYS105/PHYS105-lecture-20200331/',title:"PHYS105-lecture-20200331",section:"PHYS105",content:"Annoucements #   HW 13 due tonight HW 14 due fri Quiz 7 posted due 4/16 Centripetal force lab due Fri Recitation today: attend either session Lab on Thurs: attend either session Schedule update by thurs  Today #   More centripetal force  Clicker questions #  Problems #   Ball hanging from pendulum inside moving car turning at 10 mph, what is the radius of the turn?  How fast can a car travel and make a turn without slipping? (Assume road is perfectly flat). What is the force thats bending the car in a circle? The friction of the tires.  The maximum is when $f_s$ reaches $\\mu _sn$\nA car is safely negotiating an unbanked circular turn at a speed of 21 m/s. The maximum static frictional force acts on the tires. Suddently a wet patch in the road reduces the maximum static frictional force by a factor of three. If the car is to continue safely around the curve, to what speed must the drive slow the car?  A banked turn\nFormulas for friction/banked turning\nAcceleration in the y direction is just gravity\nOrbits #  The force that pulls the apple toward the earth is the same force that keeps the moon in orbit. The force of gravity isn\u0026rsquo;t a constant, it depends on the distance away from the object squared.\nThe force is directly proportional to the mass involved. Inversely proportional to the distance separation squared.\nGravitational force is always an attractive force.\n$r$ is the distance from the center of the earth, so as you get farther away the gravitational force becomes smaller.\n"}),a.add({id:364,href:'/notes/PHYS105/PHYS105-lecture-20200402/',title:"PHYS105-lecture-20200402",section:"PHYS105",content:"Announcements #   HW 13 Ch 6 due tomorrow Quiz 7 due 4/14 Lab due tomorrow New lab today Revised schedule posted Office hour tomorrow @ 11am  Today #  Clicker questions #  Gravitational force is always attractive.\nTo find the net force equaling 0, solve this for x:\nLecture #  $G$ is really small, so for it to be appreciable at least one of the masses needs to be big (for instance Earth).\nDirection of the force is always toward center of mass.\nMass is a property independent of location. Mass is a measure of inertia, but also a source of the gravitational force.\nMinimum speed for a circular orbit:\nThe time for one complete revolution of the Earth. Geosynchronous satellites orbit the Earth the same period as 1 day. They orbit the equator.\nWhat is the $h$ to put the satellite into geosynchronous orbit:\nKepler took data from a naked eye observatory to find this law.\nAt the altitude of this orbit the gravitational force has only fallen by around 10%.\nStronger when closer to the planet. The idea of a field allows us to talk about how the force is transmitted. The universal law of gravity depends upon these fields. Einstein added another feature to this where the idea doesn\u0026rsquo;t involve a mass (we\u0026rsquo;re not going to worry about that).\nField lines can never cross.\n"}),a.add({id:365,href:'/notes/PHYS105/PHYS105-lecture-20200414/',title:"PHYS105-lecture-20200414",section:"PHYS105",content:"Anouncements #  Todays new material #  Clicker questions #  The mass of the satellites actually don\u0026rsquo;t matter\nThe smaller the radius the faster the satelite.\n The bigger the radius the longer the period.\n  Discussion #  Last chapter we introduced centripetal acceleration. We briefly introduced what happens when the speed doesn\u0026rsquo;t change. The tangenital component makes the accelerate faster in a circle.\nHow do we get things spinning in a circle in the first place?\nTorque #  The farther away the easier it is to spin the pipe.\nTorque varies with the $sin$ of the angle. Decreasing the radius decreases the torque.\n$$\\tau =rFsin \\theta$$\n(Typo on bottom there, only supposed to be one $\\tau$)\nNo radius $r$ so there isn\u0026rsquo;t any rotation.\n Units of torque is meter Newton (or ft-lbs).\n With the radius being drawn to the corner it gets the longest radius possible.\n Equilibrium #  Sum of the torques must be equal to zero along with sum of the forces being equal to zero.\n$m_1 = 100 g \\ m_2 = 200 g$\nWhere do you put the second mass to get this in balance?\nThe pivot point on this uniform meter stick located in the middle is called the center of mass.\nThe center of mass of the wrench moves in a straight line while the body of the mass rotates around it.\n It is a weighted average.\n The pole lowers the center of mass so it is below the pivot point.\nSoda can won\u0026rsquo;t balance when empty. However when you add liquid it ends up balancing (up to a certain point).\nIf the center of mass is above a point of balance it will be in equilibrium.\nWhen the center of mass is past the point of support it will fall.\n Pivot is at the elbow. Clockwise torque is positive.\nThe distance that the muscle needs to move is small, but the movement of the arm is big.\n"}),a.add({id:366,href:'/notes/PHYS105/PHYS105-lecture-20200416/',title:"PHYS105-lecture-20200416",section:"PHYS105",content:"Announcements #  Today #  Clicker questions #     Discussion #  Weight of the beam is in the middle because it is uniform, and the center of mass is in the exact center.\nTwo conditions for equilibrium, x is positive to right y is positive to up.\nTwo equations and three unknowns. To get to the solution we need to use the sum of the torques = 0 also.\nChoose any pivot point because the sum of the torques is zero. Choose the point that gets rid of as much unknowns as possible.\nChoose rotational coordinate system. Clockwise will be positive torque.\nSolve for $T$\n$Tsin\\theta$ causes the torque.\nLook at the x component of the pivot\n How to decide the direction of the torque? Lets say this is the setup:\nIf you ignore $F_1$ the beam will rotate CCW.\n The walls are frictionless and the rope at the bottom keeps it from sliding back.\nWhat keeps it from falling is the tension in the rope.\nWhen we choose the pivot point at the bottom it ends up getting rid of what we want, but before we showed that the tension is equal to the force the wall exerts at the top of the ladder.\nCCW +, CW -\n$L$ goes away\nFinding the perpendicular force that causes torque:\n Spinning to the left\nSpinning to the right\n $R$ is the distance from axis of rotation\nRelationships to kinematics\n Try this one:\n"}),a.add({id:367,href:'/notes/PHYS105/PHYS105-lecture-20200421/',title:"PHYS105-lecture-20200421",section:"PHYS105",content:"Announcements #  No graphing exercises on upcoming test despite containing some kinematics.\nToday #  Clicker questions #  Radians are unitless. The 1/2 second doesn\u0026rsquo;t have anything to do with the problem.\n Use the first equation\nYou can also use this equation:\n Use the third equation from above\nWhat is the initial tangential speed $v_{oT}$ and the tangential acceleration $a_T$?\nIts slowing down quite fast!\n Discussion #  1:1 correspondence between transational motion and rotational motion.\nShould be added to the list:\nThese link rotational motion to tangential motion. The sum of the torques is the same as sum of the forces.\nAlso adding in our understanding of energy:\nThe point thats in contact with the surface is instantanteously at rest\n We gave two terms that go into the kinetic energy portion of the equation, how fast the center of mass is moving and how fast it is rotating about the center of mass.\nReplace $\\omega$\nMass $m$ is cancelled\nIf this was just sliding (no friction) the $v_{cm}$ would be higher.\nA look at the cylinder half way down the incline:\nPlus a frictional force $f_s$ that creates the rotation\nThe point that is in contact is at rest so there isn\u0026rsquo;t any displace, thus no work.\n Last thing to add to the table of rotational quantities\n  A look at Quiz 8 #  The angle is 90 degrees between pivot and moment arm.\nCan use these to solve the equation:\nWe\u0026rsquo;re looking for velocity of the center of mass $v_{cm}$:\nRegarding the moment arm\nSince the string is always tangent to the circle it is always perpendicular to where it is attached. Therefore $\\theta = 90$\n"}),a.add({id:368,href:'/notes/PHYS105/PHYS105-lecture-20200428/',title:"PHYS105-lecture-20200428",section:"PHYS105",content:"Announcements #  Test scores\nProbably cancel today\u0026rsquo;s recitation.\nToday #  Microscopid mechanics will have macroscopic ramifications. We\u0026rsquo;ll have to go over:\n Heat Temperature Internal energy Thermal energy  Temperature #  Prof Harris will almost always use (U) for internal energy instead of (E).\nTemperature affects the vibrational energy (E_{vib}), rotational energy (E_{rot}), and the kinetic energy (KE).\nThermal energy\nThe aspects of the internal energy that is affected by thermal processes. The thermal energy (Q) at room temperature the translational kinetic energy is usually much greater than all the other forms of energy.\nThermal energy can be transmitted thru the walls of the container by vibrating the molecules of the wall. The heat can be transferred between each gas thru the wall.\nTemperature is the measure of the average molecular energy of the substance.\nThermal equilibrium is when the average temperatures between two gases are the same. It doesn\u0026rsquo;t matter how many molecules of gas there is.\nThermal equilbrium is like the transitive property in algebra.\nIf (A)\nThermal expansion #  Here (\\Delta T) is the change in temperature, (\\alpha) is the coeffecient of expansion, (\\gamma) is the coeffecient of area expansion, (\\beta) is the coeffecient of volume expansion.\n a)\nb)\nThe measuring tape also expands with that change in temp.\nThis means that the distance betweek meter marks on the tape is actually (1.00009 m)\n This is the way an old thermostat works:\nLets consider a solid rectangular ring:\nAs the part heats up it expands:\n"}),a.add({id:369,href:'/notes/PHYS105/PHYS105-lecture-20200430/',title:"PHYS105-lecture-20200430",section:"PHYS105",content:"Announcements #  Today #  Clickers #    Remember temperature is the average kinetic energy of the system.\nDiscussion #   Note: Ability to derive this next part isn\u0026rsquo;t included in the test.\n Look at a box with one particle:\nNow lets add a lot more particles:\nThese don\u0026rsquo;t need to be derived, but understood. Will be useful on the next exam.\nThe degree of freedom is the \u0026ldquo;number of boxes\u0026rdquo; you can divide the energy into.\nExample #  The conversion of a liter:\nFirst law of thermodynamics #  We\u0026rsquo;ll use the symbol (Q) for heat.\nThe change in internal energy equals the heat added to or the work done on the system.\nImagine dumping a bunch of heated copper pellets into a beaker of water and stir:\nThe final temp ends up being close to the water temp:\nRemember water has an ability to absorb a lot of heat without changing temp.\nLooking at the copper against a thermometer:\nLooking at water against the thermometer:\nWhats (C)?\nExample #  Ignore heat exchange with the calorimeter/outside world.\nThe answer we got for our grey metal is very close to lead:\n"}),a.add({id:370,href:'/notes/PHYS105/PHYS105-lecture-20200505/',title:"PHYS105-lecture-20200505",section:"PHYS105",content:"Announcements #  Class postponed until recitation.\n"}),a.add({id:371,href:'/notes/PHYS105/PHYS105-lecture-20200507/',title:"PHYS105-lecture-20200507",section:"PHYS105",content:"Announcements #  Clickers #    Discussion #  Convection:\nThe warm air is pushed up by the cold air underneath it. Same as buoyant force! This is where the term \u0026ldquo;heat rises\u0026rdquo; comes from.\nThen the hot air cools and cycles down.\nRadiation:\nInfrared heat. Wavelengths that are longer than visible light.\nThe emissivaty of 1 radiates a lot (like a black surface). Emissivaty of 0 radiates nothing.\n Example of a PV (pressure/volume) diagram\nNo matter what path is taken to the second state, it always ends up at the same pressure and volume\nThe system and surrounds\n Make sure to convert all the units\nAnother useful conversion:\nSince energy has left the system, the temperature has gone down.\n The gas is doing work on the environment. The work done is the area under the curve.\n(V_1) is initial volume and (V_2) is final volume.\n Because the volume is not changing, there isn\u0026rsquo;t any work done on the gas or by the gas.\n(C_V) is the molar specific heat.\n "}),a.add({id:372,href:'/notes/PHYS105/PHYS105-lecture-20200512/',title:"PHYS105-lecture-20200512",section:"PHYS105",content:"Announcements #  The open ended question on the exam will almost certainly be a heat engine problem.\nToday #  There will be recitation this afternoon.\nClickers #    Quick review of thermal processes #  Isobaric (constant pressure)\nIsometric (constant volume)\nIsothermal (constant temperature)\nAdiabatic ((q)\nRemember:\nDiscussion #  According to the second law of thermodynamics, there is no perfect heat engine.\n   "}),a.add({id:373,href:'/notes/PHYS105/PHYS105-lecture-20200514/',title:"PHYS105-lecture-20200514",section:"PHYS105",content:"Announcements #  Today #  Clickers #   Clockwise around the PV diagram is negative work done on the gas.\nDiscussion #  Container on the left contains 3 times the thermal energy because it has 3 times the amount of particles, even tho the temperatures are the same.\nThe disorder is proportional to the number of available states (boxes that you can divide each curve into). More temp = more disordered state.\n  The universe always looses order, so the negative value is off.\n"}),a.add({id:374,href:'/notes/PHYS105/PHYS105-recitation-20200331/',title:"PHYS105-recitation-20200331",section:"PHYS105",content:"Angular motion questions #  HW Questions #  1\n5\nSince traveling less than ideal speed the car slides down the bank.\n6\nAnother problem #  A pendulum swings back and forth with a given length 2m. (Similar to quiz)\nIt is moving tangenital at 8 m/s\n What is the radial or centripetal acceleration?  What is the tangential acceleration?  What is the tension in the string?  "}),a.add({id:375,href:'/notes/PHYS105/PHYS105-recitation-20200414/',title:"PHYS105-recitation-20200414",section:"PHYS105",content:"Anouncements #  Quiz 7 #  Part 1 #  The shape made by swinging the string makes a cone.\nTo find the angle look at the second equation.\nThe radius of the circle is $lsin \\theta$\nSolve for $v$.\nPart 2 #  Vertical circle\nWe\u0026rsquo;re interested in the ball at three different points.\nPart A\nSolve for $v$\nPart B\nSolve for $v$\nPart C\n HW #  2 #  Positive torque clockwise, negative torque CCW.\nSolve for $\\ell_2$\nIf getting the wrong answer switch the place of the pivot and the center of mass.\nSwitch sign (at red arrow above)\nPart B\nUse the other condition of equilibrium\n3 #  What is the force applied at that orientation to achieve the given torque.\nThe perpendicular force results in the wrench spinning.\n"}),a.add({id:376,href:'/notes/PHYS105/PHYS105-recitation-20200416/',title:"PHYS105-recitation-20200416",section:"PHYS105",content:"This is usually lab time but today it will be recitation.\nAnnouncements #   Spine problem\nTo find these unknowns we use the sum of the torques\nFill out distances\nFind perpendicular components\nSolve for $F_m$\nBack muscle exerts 2.3 times your weight to hold you up!\nTotal force\nJust bending over the force you put on your spine is 2.5 times your body weight.\n Kinematics problem\nFinal angular velocity will be 0\nWhat does the sign of the answer mean?\nMeans it is slowing down.\n Rotational inertia will be given to us. Not expected to calculate or memorize them.\nPoint particle\nRing\nDisc / clinder\nSolid sphere\n Atwood machine (w/ pulley)\nWhat is the acceleration of the masses?\nFrictionless pulley\nFree body of $m$\nFree body of $2m$\nThe rope is not stretching\nFree body of pulley\nSum the torques\nPivots on the axel\nThe tensions causes the rotation. Clockwise positive\n3 equations with a new unknown\nSolve for $T_1$ and $T_2$\n HW Problems #  4 #  Problem is looking for force the ground exerts on the hoof $F_{GY}$\nDivide total mass by 2 because only looking at one hoof.\nUnknowns\nChoose pivot point at hoof\nFind angles\nCCW positive torques\nCorrection: actually force of wall divided by two because its being supported by both hoofs.\n"}),a.add({id:377,href:'/notes/PHYS105/PHYS105-recitation-20200421/',title:"PHYS105-recitation-20200421",section:"PHYS105",content:"Quiz 8 #  Part 1\nWhat is the tension $T_L$?\nPart 2\nBecause the disc is spinning you must add in the rotational component. $I$ Will be given.\nDoesn\u0026rsquo;t depend on mass.\n Topics to be covered on exam #  Rotational translation\nCentripetal acceleration\nGravitational laws\nAngular velocity\nIf something is rolling\n HW #  6 #  Convert to seconds\nUse the period around the sun to find the speed\nPossible to do it this way:\n7 #   Clicker question #  Prove it:\n"}),a.add({id:378,href:'/notes/PHYS105/PHYS105-recitation-20200428/',title:"PHYS105-recitation-20200428",section:"PHYS105",content:"Announcements #  Clicker #   The only thing that doesn\u0026rsquo;t change with temperature is mass.\n Atoms are also mostly empty space.\n Ideal gas law #  Molecules of a gas bouncing off the walls of a container on average is the gas pressure.\nGas pressure arises from the temperature of the gas molecules.\nIncreasing the temp increases the pressure. Increasing the number of molecules also increases the temperature.\nDecreasing the volume of the container increases the pressure.\nGases reach their minimum thermal energy at 0 kelvin (absolute zero). Because of quantum mechanics, you can never stop all molecular motion.\nThis was understood before even the molecular theory.\nExamples #  Lets use the ideal gas law:\nSo lets interpret this:\nCheck the periodic table for the atomic number of N (the number of protons/electrons in an atom). And the bottom number is the atomic mass in g/mol\nRemember that nitrogen in the gasous state is a diatomic molecule. Since there are two molecules, it has 26 grams per mole.\nSolve for the volume:\nAll gases at standard temp and pressure, all gases occupy the same volume regardless of the makeup.\n Start with the ideal gas law:\nRemember to convert to kelvin to use the ideal gas law.\n We\u0026rsquo;re looking for (h) here where the red portion is the gas in the bell:\nWe need to find the pressure final (P_f).\nwhere (D) is the depth of water.\nConvert:\nNow we can solve for (v_f)\nLets find out what (v_o) is so we can finish it.\nThis problem has some similarities to the next quiz.\n"}),a.add({id:379,href:'/notes/PHYS105/PHYS105-recitation-20200430/',title:"PHYS105-recitation-20200430",section:"PHYS105",content:"HW #  2 #  A\nB\nSolve for (K)\n5 #  7 #  Part b asks for the same thing but with water, then you find the difference in the overflows.\nNext HW #  For the next HW assignment we need to define gauge pressure.\nThe gauge pressure is like what you measure when you measure your tire pressure. Its not the pressure of the gas inside, its the pressure of the gas inside above normal atmosphere. You can\u0026rsquo;t use gauge pressure in the ideal gas law!\nQuiz 9 #  "}),a.add({id:380,href:'/notes/PHYS105/PHYS105-recitation-20200505/',title:"PHYS105-recitation-20200505",section:"PHYS105",content:"Announcements #  Today #  Discussion #  The melting process is breaking the bonds\nThe temp stays the same while changing from liquid to gas also.\nMelting and evaporating are cooling processes.\nFreezizng and condensating are warming processes.\n The system is the ice, aluminum, and the water. Isolated from the environment.\nThere are three possible cases:\nWe know the water and liquid will cool, but we\u0026rsquo;re letting the sign take care of it.\nThe ice warms to 0 degrees c then starts to melt. And the liquid warms.\nThe way that heat flows is the sign of the term, if positive its assuming its flowing in:\nLets look at conduction in a solid:\nAs the solid warms, the molecules start to vibrate.\nThe energy will start to transfer via lattice vibrations. Solids tend to be better conductors because of the vibrations.\n(R) value is like a resistance to heat flow.\n"}),a.add({id:381,href:'/notes/PHYS105/PHYS105-recitation-20200507/',title:"PHYS105-recitation-20200507",section:"PHYS105",content:"Announcements #  Discussion #  N means no change C means change on this summary.\n  If you travel around a PV diagram in the clockwise direction the net work will be negative. If counterclockwise, the work done on the gas is positive.\nHW #  5 tonights #  7 tomorrows #  "}),a.add({id:382,href:'/notes/PHYS105/PHYS105-recitation-20200512/',title:"PHYS105-recitation-20200512",section:"PHYS105",content:"Announcements #  HW #  3 #  4 #  7 #   Other questions #  It is reflecting all colors because of its crystal structure, so it is not absorbing a lot of heat.  It adds a lot of thermal mass so it takes a lot more energy to cool down the entire room.\nAir is a worse conductor of heat than water.\nShiney side will reflect more, so shiny side in lets heat thru then traps it inside.\nThe amount of mass in the pot is a lot more so it has a lot more potential to dump out heat to your hand.\n"}),a.add({id:383,href:'/notes/PHYS105/PHYS105-recitation-20200514/',title:"PHYS105-recitation-20200514",section:"PHYS105",content:"HW 22 #  4 #  Solve for (T_H)\n10 #  HW 21 #  2 #  Quiz 11 #  Calculate the value (P_A) and the circled empty values of the table:\n"}),a.add({id:384,href:'/notes/RPTA125/RPTA125-lecture-20220125/',title:"RPTA125-lecture-20220125",section:"RPTA125",content:"Leisure, the Individual, and Contemporary Society #  Syllabus #  File: rpta125-syllabus.pdf  Notes during orientation #   the greyed out rows on the tentative schedule in the syllabus are weeks when we don\u0026rsquo;t meet via Zoom   minimum of 5000 words total for the class broken up into smaller assignments 2 large papers, several smaller papers, several discussions  "}),a.add({id:385,href:'/notes/RPTA125/RPTA125-lecture-20220201/',title:"RPTA125-lecture-20220201",section:"RPTA125",content:"Overview of Leisure #  To endure rather than to enjoy means: trying to make a living, just to get by. I plan on being able to balance work life with leisure to not burn out.\nWhat is leisure? #  Leisure as a state of mind #  Leisure is political #  "}),a.add({id:386,href:'/notes/RPTA125/RPTA125-lecture-20220208/',title:"RPTA125-lecture-20220208",section:"RPTA125",content:"Recreation and Play #   social capital = network of relationships  Definition #  Play #  Types #  Definitions #  Reminders #  "}),a.add({id:387,href:'/notes/RPTA125/RPTA125-lecture-20220215/',title:"RPTA125-lecture-20220215",section:"RPTA125",content:"Reminders #  History of leisure #  "}),a.add({id:388,href:'/notes/RPTA125/RPTA125-lecture-20220301/',title:"RPTA125-lecture-20220301",section:"RPTA125",content:"Assignment overview #  Theories related to the meaning and practice of leisure #  Leisure, Media Consumption and Representation #  "}),a.add({id:389,href:'/notes/RPTA125/RPTA125-lecture-20220308/',title:"RPTA125-lecture-20220308",section:"RPTA125",content:"Recap #  Media and consumption cont. #  Media consumption paper (1000 words) #  Helpful links #   https://library.csus.edu EBSCO Statista  "}),a.add({id:390,href:'/notes/STATS50/STATS50-lecture-notes/',title:"STATS50-lecture-notes",section:"STATS50",content:"STATS 50 lecture notes #  File: STATS50-lecture-notes.pdf  "})})()